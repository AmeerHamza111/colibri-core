\hypertarget{classPatternModel}{}\section{Pattern\+Model$<$ Value\+Type, Value\+Handler, Map\+Type, Pattern\+Type $>$ Class Template Reference}
\label{classPatternModel}\index{Pattern\+Model$<$ Value\+Type, Value\+Handler, Map\+Type, Pattern\+Type $>$@{Pattern\+Model$<$ Value\+Type, Value\+Handler, Map\+Type, Pattern\+Type $>$}}


A model mapping patterns to values, gigh-\/level interface.  




{\ttfamily \#include $<$patternmodel.\+h$>$}

Inheritance diagram for Pattern\+Model$<$ Value\+Type, Value\+Handler, Map\+Type, Pattern\+Type $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=1.379310cm]{classPatternModel}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef Map\+Type\+::iterator \hyperlink{classPatternModel_a9254a562bb22d604b6338c6b2fce76e5}{iterator}
\item 
typedef Map\+Type\+::const\+\_\+iterator \hyperlink{classPatternModel_a6809324b33b5ea832f0f15d25db0b46b}{const\+\_\+iterator}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPatternModel_afc90f7dd876f3c602348275380503037}{Pattern\+Model} (\hyperlink{classIndexedCorpus}{Indexed\+Corpus} $\ast$corpus=N\+U\+L\+L)
\item 
\hyperlink{classPatternModel_a075916375572bbfb0cf2d22b7bf0c7f9}{Pattern\+Model} (std\+::istream $\ast$f, \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainmodel=N\+U\+L\+L, \hyperlink{classIndexedCorpus}{Indexed\+Corpus} $\ast$corpus=N\+U\+L\+L)
\item 
\hyperlink{classPatternModel_acf75d6956016d4ba882e9073a42296ac}{$\sim$\+Pattern\+Model} ()
\item 
\hyperlink{classPatternModel_a8252ea7d11076fbf961bb22cf679bacd}{Pattern\+Model} (const std\+::string \&filename, const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} \&options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainmodel=N\+U\+L\+L, \hyperlink{classIndexedCorpus}{Indexed\+Corpus} $\ast$corpus=N\+U\+L\+L)
\item 
virtual int \hyperlink{classPatternModel_ac4a38270c6a2dbcfccf0b8baebee11eb}{getmodeltype} () const 
\item 
virtual int \hyperlink{classPatternModel_a760a01e32f97b63400d13e69384dad86}{getmodelversion} () const 
\item 
virtual size\+\_\+t \hyperlink{classPatternModel_a2422cb944da209f399b3b10f3b1d2684}{size} () const 
\item 
virtual bool \hyperlink{classPatternModel_ad2fa89b6a2eb8d2aebb8553a9da42b84}{has} (const \hyperlink{classPattern}{Pattern} \&pattern) const 
\item 
virtual bool \hyperlink{classPatternModel_a3a5098f2c1606c0685ccf97ad9f6cad6}{has} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern) const 
\item 
virtual void \hyperlink{classPatternModel_ad9e711b16dc97fe4cb0fe5569b9327e4}{load} (std\+::string \&filename, const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} \&options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainmodel=N\+U\+L\+L)
\item 
virtual void \hyperlink{classPatternModel_a84f6c2854b85e6aac9739cdb5807190b}{load} (std\+::istream $\ast$f, const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} \&options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainmodel=N\+U\+L\+L)
\item 
\hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$ \hyperlink{classPatternModel_a21f827196f0475305ce3172220a63954}{getinterface} ()
\item 
virtual void \hyperlink{classPatternModel_a0631a4a6c003e4aa18ec82ad4748ef76}{train} (std\+::istream $\ast$in, \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainbymodel=N\+U\+L\+L, bool continued=false, uint32\+\_\+t firstsentence=1, bool ignoreerrors=false)
\item 
virtual void \hyperlink{classPatternModel_a143ea1e2907a1efd0550f52a51e55539}{train} (const std\+::string \&filename, \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainbymodel=N\+U\+L\+L, bool continued=false, uint32\+\_\+t firstsentence=1, bool ignoreerrors=false)
\item 
virtual int \hyperlink{classPatternModel_acba7487b306d552d62bfd1ee45c8b504}{computeskipgrams} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, int mintokens=2, const \hyperlink{classIndexReference}{Index\+Reference} $\ast$singleref=N\+U\+L\+L, const \hyperlink{classIndexedData}{Indexed\+Data} $\ast$multiplerefs=N\+U\+L\+L, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainbymodel=N\+U\+L\+L, std\+::vector$<$ \hyperlink{classPatternPointer}{Pattern\+Pointer} $>$ $\ast$targetcontainer=N\+U\+L\+L, const bool exhaustive=false, const int maxskips=3, const bool D\+E\+B\+U\+G=false)
\item 
virtual int \hyperlink{classPatternModel_ad9d08c290da84543b324d36ac76efeeb}{computeskipgrams} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} \&options, const \hyperlink{classIndexReference}{Index\+Reference} $\ast$singleref=N\+U\+L\+L, const \hyperlink{classIndexedData}{Indexed\+Data} $\ast$multiplerefs=N\+U\+L\+L, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainbymodel=N\+U\+L\+L, const bool exhaustive=false)
\item 
virtual std\+::vector$<$ \hyperlink{classPatternPointer}{Pattern\+Pointer} $>$ \hyperlink{classPatternModel_a559c400e5b8cfe2df18381ce8cdf61d1}{findskipgrams} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, unsigned int occurrencethreshold=1, int maxskips=3)
\item 
virtual void \hyperlink{classPatternModel_ad18615c995fc3a6336bfed45fe21f5ac}{trainskipgrams} (const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainbymodel=N\+U\+L\+L)
\item 
void \hyperlink{classPatternModel_a94648d91f0bb536c3295e0ccece2a2e7}{test} (Map\+Type \&target, std\+::istream $\ast$in)
\item 
void \hyperlink{classPatternModel_abf61a21bcfd5dd0131ae394486c70e2d}{write} (std\+::ostream $\ast$out)
\item 
void \hyperlink{classPatternModel_a5c9ba026899810524d2e8254089bde66}{write} (const std\+::string filename)
\item 
virtual int \hyperlink{classPatternModel_a545fbfefef4eadb268217ec781c494bb}{maxlength} () const 
\item 
virtual int \hyperlink{classPatternModel_a7a0208745487928ecb418baeb78e810f}{minlength} () const 
\item 
virtual unsigned int \hyperlink{classPatternModel_a013725360804aac3514eb8bb436102db}{occurrencecount} (const \hyperlink{classPattern}{Pattern} \&pattern)
\item 
virtual unsigned int \hyperlink{classPatternModel_a5a945f4e01dfd36a24ea7d2e69fce91c}{occurrencecount} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern)
\item 
virtual Value\+Type $\ast$ \hyperlink{classPatternModel_a1b6c55216886cd765ab3189c24f8da2a}{getdata} (const \hyperlink{classPattern}{Pattern} \&pattern, bool makeifnew=false)
\item 
virtual Value\+Type $\ast$ \hyperlink{classPatternModel_ad1c89dc32115373dec3b1a4e3cbeb700}{getdata} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, bool makeifnew=false)
\item 
virtual unsigned int \hyperlink{classPatternModel_a6e5ac4583443112eb1a78157aed967b5}{types} ()
\item 
virtual unsigned int \hyperlink{classPatternModel_a9e4a67d7c0136f9c9a8da56df5ffc18c}{tokens} () const 
\item 
unsigned char \hyperlink{classPatternModel_a1feab3a0fd585ca17f87b5af54fc7f61}{type} () const 
\item 
unsigned char \hyperlink{classPatternModel_a30dac843287129d9d4c3c34459697835}{version} () const 
\item 
void \hyperlink{classPatternModel_ad3b35422f9af77624180503e01a5881a}{output} (std\+::ostream $\ast$)
\item 
unsigned int \hyperlink{classPatternModel_a561547f4abe74d2138683bf279eceea7}{coveragecount} (const \hyperlink{classPattern}{Pattern} \&key)
\item 
double \hyperlink{classPatternModel_acffbefd7321ff9cd4032a1033933ed7a}{coverage} (const \hyperlink{classPattern}{Pattern} \&key)
\item 
std\+::vector$<$ \hyperlink{classPatternPointer}{Pattern\+Pointer} $>$ \hyperlink{classPatternModel_a340deff272001ac6f791bec792a03b45}{getreverseindex} (const \hyperlink{classIndexReference}{Index\+Reference} ref, int \hyperlink{classPatternModel_a013725360804aac3514eb8bb436102db}{occurrencecount}=0, int category=0, unsigned int \hyperlink{classPatternModel_a2422cb944da209f399b3b10f3b1d2684}{size}=0)
\item 
std\+::vector$<$ std\+::pair$<$ \hyperlink{classIndexReference}{Index\+Reference}, \hyperlink{classPatternPointer}{Pattern\+Pointer} $>$ $>$ \hyperlink{classPatternModel_acef58dc3b555f4eeec6fe55f423dc369}{getreverseindex\+\_\+bysentence} (int sentence)
\item 
std\+::vector$<$ std\+::pair$<$ \hyperlink{classIndexReference}{Index\+Reference}, \hyperlink{classPatternPointer}{Pattern\+Pointer} $>$ $>$ \hyperlink{classPatternModel_a3d606eb9dfabd1c0ffba6e7b96d55cfc}{getreverseindex\+\_\+right} (const \hyperlink{classIndexReference}{Index\+Reference} ref)
\item 
std\+::vector$<$ std\+::pair$<$ \hyperlink{classIndexReference}{Index\+Reference}, \hyperlink{classPatternPointer}{Pattern\+Pointer} $>$ $>$ \hyperlink{classPatternModel_ab2318a00ce10d348356070e567a2be3d}{getreverseindex\+\_\+left} (const \hyperlink{classIndexReference}{Index\+Reference} ref)
\item 
void \hyperlink{classPatternModel_af27c14d58d1b7624cf6737645bd35d77}{computestats} ()
\item 
virtual void \hyperlink{classPatternModel_a287b8993ee50fe32bb87b9de0aab352d}{resetstats} ()
\item 
virtual void \hyperlink{classPatternModel_ace39c4eb87c43a1c1f1e38597e44edad}{computecoveragestats} (int category=0, int n=0)
\item 
unsigned int \hyperlink{classPatternModel_ab7b6a79389ff67ca5af7b51a9144406f}{totaloccurrencesingroup} (int category, int n)
\item 
unsigned int \hyperlink{classPatternModel_a0b8154172f9d2884c8510559e2e1006c}{totalpatternsingroup} (int category, int n)
\item 
unsigned int \hyperlink{classPatternModel_a2fdc64527855d87e2c6c8c89ae5355a7}{totalwordtypesingroup} (int category, int n)
\item 
unsigned int \hyperlink{classPatternModel_a406c8d2456ff2db65abbf061a1036917}{totaltokensingroup} (int category, int n)
\item 
double \hyperlink{classPatternModel_a4ec1d0a963488d62afea4a67869758fa}{frequency} (const \hyperlink{classPattern}{Pattern} \&pattern)
\item 
virtual void \hyperlink{classPatternModel_a2016b988236f92fdf8d7ffcfe653c0e2}{add} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&patternpointer, const \hyperlink{classIndexReference}{Index\+Reference} \&ref)
\item 
virtual void \hyperlink{classPatternModel_aeb114aa9a51e696e0922f81b73c97112}{add} (const \hyperlink{classPattern}{Pattern} \&pattern, Value\+Type $\ast$value, const \hyperlink{classIndexReference}{Index\+Reference} \&ref)
\item 
virtual void \hyperlink{classPatternModel_a990365a2aa7d37adbcfb3de99cb32da3}{add} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, Value\+Type $\ast$value, const \hyperlink{classIndexReference}{Index\+Reference} \&ref)
\item 
unsigned int \hyperlink{classPatternModel_a517a1b52861ad721569234756c41d2fc}{prune} (int threshold, int \+\_\+n=0)
\item 
virtual unsigned int \hyperlink{classPatternModel_a4455376801a3ae1445d5a80a8f6276d1}{pruneskipgrams} (unsigned int threshold, int minskiptypes=2, int \+\_\+n=0)
\item 
unsigned int \hyperlink{classPatternModel_a079652a519c0abbf094e78f3b1e9ac22}{prunenotinset} (const std\+::unordered\+\_\+set$<$ \hyperlink{classPattern}{Pattern} $>$ \&s, int \+\_\+n)
\item 
{\footnotesize template$<$class Value\+Type2 , class Value\+Handler2 , class Map\+Type2 $>$ }\\unsigned int \hyperlink{classPatternModel_a25b7178a9c3ec629a26ca1b31e29d98e}{prunebymodel} (\hyperlink{classPatternModel}{Pattern\+Model}$<$ Value\+Type2, Value\+Handler2, Map\+Type2 $>$ \&secondmodel)
\item 
std\+::vector$<$ std\+::pair$<$ \hyperlink{classPattern}{Pattern}, int $>$ $>$ \hyperlink{classPatternModel_ae4b6fc4526f2bbcb1914c0ee8bbdf3c0}{getpatterns} (const \hyperlink{classPattern}{Pattern} \&pattern)
\item 
virtual void \hyperlink{classPatternModel_aba01edce114df253215e905e63acbee1}{print} (std\+::ostream $\ast$out, \hyperlink{classClassDecoder}{Class\+Decoder} \&decoder)
\item 
virtual void \hyperlink{classPatternModel_a0be389d2ec90c3d1ab368f915aa878f2}{printreverseindex} (std\+::ostream $\ast$out, \hyperlink{classClassDecoder}{Class\+Decoder} \&decoder)
\item 
void \hyperlink{classPatternModel_a251e7848e11e320ab6ccf249d910cfd5}{printmodel} (std\+::ostream $\ast$out, \hyperlink{classClassDecoder}{Class\+Decoder} \&decoder)
\item 
virtual void \hyperlink{classPatternModel_ae2c135f4a441d6b80c50e89699419e1c}{print} (std\+::ostream $\ast$out, \hyperlink{classClassDecoder}{Class\+Decoder} \&decoder, const \hyperlink{pattern_8h_a351dc5aa88481a949638aeb6cc5e6754}{Pattern\+Type} \&pattern, bool endline=true)
\item 
void \hyperlink{classPatternModel_a4b001eb3f0c864155cd35c92bbb451fb}{printpattern} (std\+::ostream $\ast$out, \hyperlink{classClassDecoder}{Class\+Decoder} \&decoder, const \hyperlink{classPattern}{Pattern} \&pattern, bool endline=true)
\item 
void \hyperlink{classPatternModel_a52421768bdfaf6041b9b9aac3007431b}{histogram} (std\+::map$<$ unsigned int, unsigned int $>$ \&hist, unsigned int threshold=0, unsigned int cap=0, int category=0, unsigned int \hyperlink{classPatternModel_a2422cb944da209f399b3b10f3b1d2684}{size}=0)
\item 
unsigned int \hyperlink{classPatternModel_ad2e98cec42e61474b46c0799d4da951e}{topthreshold} (int amount, int category=0, int \hyperlink{classPatternModel_a2422cb944da209f399b3b10f3b1d2684}{size}=0)
\item 
void \hyperlink{classPatternModel_a89cea4fdb95cf5f1e9a363c76300062e}{histogram} (std\+::ostream $\ast$O\+U\+T, unsigned int threshold=0, unsigned int cap=0, int category=0, unsigned int \hyperlink{classPatternModel_a2422cb944da209f399b3b10f3b1d2684}{size}=0)
\item 
void \hyperlink{classPatternModel_a6f4cc32e18eceda5029f215ab67f06e4}{info} (std\+::ostream $\ast$O\+U\+T)
\item 
void \hyperlink{classPatternModel_a83ea8018b62f30b57f0626e5bf7d5a24}{report} (std\+::ostream $\ast$O\+U\+T)
\item 
\hyperlink{classPatternSet}{Pattern\+Set}$<$ uint64\+\_\+t $>$ \hyperlink{classPatternModel_a95c603b1ed42603a2dcb22f25d3c2c50}{extractset} (int \hyperlink{classPatternModel_a7a0208745487928ecb418baeb78e810f}{minlength}=1, int \hyperlink{classPatternModel_a545fbfefef4eadb268217ec781c494bb}{maxlength}=1)
\item 
virtual void \hyperlink{classPatternModel_acff82b2b24874623673fad020c7c3c78}{outputrelations} (const \hyperlink{classPattern}{Pattern} \&pattern, \hyperlink{classClassDecoder}{Class\+Decoder} \&classdecoder, std\+::ostream $\ast$O\+U\+T)
\item 
virtual \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classPatternModel_a08a61e3c5dcb074e9567d5fbeeaa51e7}{getsubchildren} (const \hyperlink{classPattern}{Pattern} \&pattern, int=0, int=0, int=0)
\item 
virtual \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classPatternModel_ac3de813c88755705e817a6f019ae29c6}{getsubparents} (const \hyperlink{classPattern}{Pattern} \&pattern, int=0, int=0, int=0)
\item 
virtual \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classPatternModel_a93b191916d48602c8b2d62aa2ff9b5ac}{gettemplates} (const \hyperlink{classPattern}{Pattern} \&pattern, int=0)
\item 
virtual \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classPatternModel_af713e95d9be78c75c6a065f0f0845b19}{getinstances} (const \hyperlink{classPattern}{Pattern} \&pattern, int=0)
\item 
virtual \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classPatternModel_ab0b9ea8b905ce180eec004413192abaf}{getskipcontent} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern)
\item 
virtual \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classPatternModel_a6a4a0403bd746b120b405545a3ec2295}{getleftneighbours} (const \hyperlink{classPattern}{Pattern} \&pattern, int=0, int=0, int=0, int=0)
\item 
virtual \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classPatternModel_a0a5cffe0dd3e29485868a3fb013746d7}{getrightneighbours} (const \hyperlink{classPattern}{Pattern} \&pattern, int=0, int=0, int=0, int=0)
\item 
virtual \hyperlink{patternmodel_8h_ae13b52c8cf777358f19da17c90c7dac0}{t\+\_\+relationmap\+\_\+double} \hyperlink{classPatternModel_a3439e0f9443ff0aeb551ca2b09486f7c}{getnpmi} (const \hyperlink{classPattern}{Pattern} \&pattern, double threshold)
\item 
virtual int \hyperlink{classPatternModel_a833c6478ea967a4fa4c75c8ff971eac8}{computeflexgrams\+\_\+fromskipgrams} ()
\item 
virtual int \hyperlink{classPatternModel_ac892ccc87080bc5eec5e8cb15460a15a}{computeflexgrams\+\_\+fromcooc} ()
\item 
virtual void \hyperlink{classPatternModel_aef998f743259e8d85d48b81eede5bd00}{outputcooc\+\_\+npmi} (std\+::ostream $\ast$O\+U\+T, \hyperlink{classClassDecoder}{Class\+Decoder} \&classdecoder, double threshold)
\item 
virtual void \hyperlink{classPatternModel_ab9876cdcaeffbd2c04350e73b2be0bc3}{outputcooc} (std\+::ostream $\ast$O\+U\+T, \hyperlink{classClassDecoder}{Class\+Decoder} \&classdecoder, double threshold)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classIndexedCorpus}{Indexed\+Corpus} $\ast$ \hyperlink{classPatternModel_af816b73fbc0a1247f54fbb50593dce22}{reverseindex}
\begin{DoxyCompactList}\small\item\em Pointer to the reverse index and corpus data for this model (or N\+U\+L\+L) \end{DoxyCompactList}\item 
bool \hyperlink{classPatternModel_a42dc001ef7580e133518d4cc9164cad9}{reverseindex\+\_\+internal}
\item 
bool \hyperlink{classPatternModel_a56ba07cb9c7691cb228903681d707436}{hasskipgrams}
\begin{DoxyCompactList}\small\item\em Does this model have skipgrams? \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classPatternModel_a0e475078b9e3501c7ae8fc5d5683f671}{postread} (const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options)
\item 
virtual void \hyperlink{classPatternModel_a4dc600e5f375d412917c30c62265d6e8}{posttrain} (const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options)
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
unsigned char \hyperlink{classPatternModel_afd14feab6f5cebac0b02232ce3adf44b}{model\+\_\+type}
\item 
unsigned char \hyperlink{classPatternModel_a512b5e8516c92983f95141d24d944f1d}{model\+\_\+version}
\item 
uint64\+\_\+t \hyperlink{classPatternModel_ada5d1db54c4e30a705aa13ce619e6d9a}{totaltokens}
\begin{DoxyCompactList}\small\item\em Total number of tokens in the original corpus, so I\+N\+C\+L\+U\+D\+E\+S T\+O\+K\+E\+N\+S N\+O\+T C\+O\+V\+E\+R\+E\+D B\+Y T\+H\+E M\+O\+D\+E\+L! \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{classPatternModel_a154c6d3c25265c2c8a40e9e78d4e09ed}{totaltypes}
\begin{DoxyCompactList}\small\item\em Total number of unigram/word types in the original corpus, S\+O I\+N\+C\+L\+U\+D\+I\+N\+G N\+O\+T C\+O\+V\+E\+R\+E\+D B\+Y T\+H\+E M\+O\+D\+E\+L! \end{DoxyCompactList}\item 
int \hyperlink{classPatternModel_a9403f8a6b15d7b5bcc8f12981dbc66ff}{maxn}
\item 
int \hyperlink{classPatternModel_a22933685f5f30ace6099d44e65c3efb7}{minn}
\item 
std\+::set$<$ int $>$ \hyperlink{classPatternModel_a2fa59bed9f90745782983b4041981b88}{cache\+\_\+categories}
\item 
std\+::set$<$ int $>$ \hyperlink{classPatternModel_a2ac397c0ba615b4ac11d7014bea8efcb}{cache\+\_\+n}
\item 
std\+::map$<$ int, std\+::map$<$ int, unsigned int $>$ $>$ \hyperlink{classPatternModel_a9a4c974fe564fcad7471b1e05e231394}{cache\+\_\+grouptotal}
\begin{DoxyCompactList}\small\item\em total occurrences (used for frequency computation, within a group) \end{DoxyCompactList}\item 
std\+::map$<$ int, std\+::map$<$ int, unsigned int $>$ $>$ \hyperlink{classPatternModel_abf5c303232c7fcd54bbd73125be4ca53}{cache\+\_\+grouptotalpatterns}
\begin{DoxyCompactList}\small\item\em total distinct patterns per group \end{DoxyCompactList}\item 
std\+::map$<$ int, std\+::map$<$ int, unsigned int $>$ $>$ \hyperlink{classPatternModel_aa1055f5f99d2abb04c7a0bcc8b0dbc5b}{cache\+\_\+grouptotalwordtypes}
\begin{DoxyCompactList}\small\item\em total covered word types per group \end{DoxyCompactList}\item 
std\+::map$<$ int, std\+::map$<$ int, unsigned int $>$ $>$ \hyperlink{classPatternModel_a3b1718a6e2a3d0e2aa328fc18b3f2527}{cache\+\_\+grouptotaltokens}
\begin{DoxyCompactList}\small\item\em total covered tokens per group \end{DoxyCompactList}\item 
std\+::map$<$ int, std\+::vector$<$ uint32\+\_\+t $>$ $>$ \hyperlink{classPatternModel_a6136c80df09f3721420f97606c6412b6}{gapmasks}
\begin{DoxyCompactList}\small\item\em pre-\/computed masks representing possible gap configurations for various pattern lengths \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$class Pattern\+Model$<$ Value\+Type, Value\+Handler, Map\+Type, Pattern\+Type $>$}

A model mapping patterns to values, gigh-\/level interface. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Value\+Type} & The type of Value this model stores \\
\hline
{\em Value\+Handler} & A handler class for this type of value \\
\hline
{\em Map\+Type} & The type of container to use \\
\hline
\end{DoxyTemplParams}


\subsection{Member Typedef Documentation}
\hypertarget{classPatternModel_a6809324b33b5ea832f0f15d25db0b46b}{}\index{Pattern\+Model@{Pattern\+Model}!const\+\_\+iterator@{const\+\_\+iterator}}
\index{const\+\_\+iterator@{const\+\_\+iterator}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{const\+\_\+iterator}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ typedef Map\+Type\+::const\+\_\+iterator {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::{\bf const\+\_\+iterator}}\label{classPatternModel_a6809324b33b5ea832f0f15d25db0b46b}
\hypertarget{classPatternModel_a9254a562bb22d604b6338c6b2fce76e5}{}\index{Pattern\+Model@{Pattern\+Model}!iterator@{iterator}}
\index{iterator@{iterator}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{iterator}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ typedef Map\+Type\+::iterator {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::{\bf iterator}}\label{classPatternModel_a9254a562bb22d604b6338c6b2fce76e5}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classPatternModel_afc90f7dd876f3c602348275380503037}{}\index{Pattern\+Model@{Pattern\+Model}!Pattern\+Model@{Pattern\+Model}}
\index{Pattern\+Model@{Pattern\+Model}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{Pattern\+Model(\+Indexed\+Corpus $\ast$corpus=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::{\bf Pattern\+Model} (
\begin{DoxyParamCaption}
\item[{{\bf Indexed\+Corpus} $\ast$}]{corpus = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_afc90f7dd876f3c602348275380503037}
Begin a new pattern model, optionally pre-\/setting a reverseindex. \hypertarget{classPatternModel_a075916375572bbfb0cf2d22b7bf0c7f9}{}\index{Pattern\+Model@{Pattern\+Model}!Pattern\+Model@{Pattern\+Model}}
\index{Pattern\+Model@{Pattern\+Model}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{Pattern\+Model(std\+::istream $\ast$f, Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainmodel=\+N\+U\+L\+L, Indexed\+Corpus $\ast$corpus=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::{\bf Pattern\+Model} (
\begin{DoxyParamCaption}
\item[{std\+::istream $\ast$}]{f, }
\item[{{\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainmodel = {\ttfamily NULL}, }
\item[{{\bf Indexed\+Corpus} $\ast$}]{corpus = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a075916375572bbfb0cf2d22b7bf0c7f9}
Read a pattern model from an input stream 
\begin{DoxyParams}{Parameters}
{\em f} & The input stream \\
\hline
{\em options} & Options for reading, these act as filter for the data, allowing you to raise thresholds etc \\
\hline
{\em constrainmodel} & Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
{\em corpus} & Pointer to the loaded corpus, used as a reverse index. \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_acf75d6956016d4ba882e9073a42296ac}{}\index{Pattern\+Model@{Pattern\+Model}!````~Pattern\+Model@{$\sim$\+Pattern\+Model}}
\index{````~Pattern\+Model@{$\sim$\+Pattern\+Model}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{$\sim$\+Pattern\+Model()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::$\sim${\bf Pattern\+Model} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_acf75d6956016d4ba882e9073a42296ac}
\hypertarget{classPatternModel_a8252ea7d11076fbf961bb22cf679bacd}{}\index{Pattern\+Model@{Pattern\+Model}!Pattern\+Model@{Pattern\+Model}}
\index{Pattern\+Model@{Pattern\+Model}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{Pattern\+Model(const std\+::string \&filename, const Pattern\+Model\+Options \&options, Pattern\+Model\+Interface $\ast$constrainmodel=\+N\+U\+L\+L, Indexed\+Corpus $\ast$corpus=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::{\bf Pattern\+Model} (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{filename, }
\item[{const {\bf Pattern\+Model\+Options} \&}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainmodel = {\ttfamily NULL}, }
\item[{{\bf Indexed\+Corpus} $\ast$}]{corpus = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a8252ea7d11076fbf961bb22cf679bacd}
Read a pattern model from file 
\begin{DoxyParams}{Parameters}
{\em filename} & The input filename \\
\hline
{\em options} & Options for reading, these act as filter for the data, allowing you to raise thresholds etc \\
\hline
{\em constrainmodel} & Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
{\em corpus} & Pointer to the loaded corpus, used as a reverse index. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\hypertarget{classPatternModel_a2016b988236f92fdf8d7ffcfe653c0e2}{}\index{Pattern\+Model@{Pattern\+Model}!add@{add}}
\index{add@{add}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{add(const Pattern\+Pointer \&patternpointer, const Index\+Reference \&ref)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::add (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{patternpointer, }
\item[{const {\bf Index\+Reference} \&}]{ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a2016b988236f92fdf8d7ffcfe653c0e2}
Add a pattern, with a given position, to the model. This is called during training at every time an instance of a pattern is found in the data. This is the high-\/level version. 
\begin{DoxyParams}{Parameters}
{\em pattern} & The pattern to add (a patternpointer) \\
\hline
{\em ref} & The position in the corpus where the patterns occurs \\
\hline
\end{DoxyParams}


Reimplemented in \hyperlink{classIndexedPatternPointerModel_aa0bec6fcd651ec169fb2c3b0b141bb35}{Indexed\+Pattern\+Pointer\+Model$<$ Map\+Type $>$}, and \hyperlink{classPatternPointerModel_abd66744c99c4c124054f558bccb45f11}{Pattern\+Pointer\+Model$<$ Value\+Type, Value\+Handler, Map\+Type $>$}.

\hypertarget{classPatternModel_aeb114aa9a51e696e0922f81b73c97112}{}\index{Pattern\+Model@{Pattern\+Model}!add@{add}}
\index{add@{add}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{add(const Pattern \&pattern, Value\+Type $\ast$value, const Index\+Reference \&ref)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::add (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{Value\+Type $\ast$}]{value, }
\item[{const {\bf Index\+Reference} \&}]{ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_aeb114aa9a51e696e0922f81b73c97112}
Add a pattern, with a given position, and a value to the model. This is called during training at every time an instance of a pattern is found in the data. This is the low-\/level version. 
\begin{DoxyParams}{Parameters}
{\em pattern} & The pattern to add \\
\hline
{\em value} & A pointer to the value for this pattern, what kind of value depends on the Value\+Type template parameter. \\
\hline
{\em ref} & The position in the corpus where the patterns occurs \\
\hline
\end{DoxyParams}


Reimplemented in \hyperlink{classIndexedPatternModel_a9ae48ed363f333a57cbec0538a434497}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_a9ae48ed363f333a57cbec0538a434497}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_a990365a2aa7d37adbcfb3de99cb32da3}{}\index{Pattern\+Model@{Pattern\+Model}!add@{add}}
\index{add@{add}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{add(const Pattern\+Pointer \&pattern, Value\+Type $\ast$value, const Index\+Reference \&ref)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::add (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{Value\+Type $\ast$}]{value, }
\item[{const {\bf Index\+Reference} \&}]{ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a990365a2aa7d37adbcfb3de99cb32da3}


Reimplemented in \hyperlink{classIndexedPatternPointerModel_acb3c231cbc2b01e028abc6b256505551}{Indexed\+Pattern\+Pointer\+Model$<$ Map\+Type $>$}, \hyperlink{classPatternPointerModel_ad105d1f22571a5756db140f094803c9e}{Pattern\+Pointer\+Model$<$ Value\+Type, Value\+Handler, Map\+Type $>$}, \hyperlink{classIndexedPatternModel_a27d944449ea3e5f6d1c578770b07ad13}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_a27d944449ea3e5f6d1c578770b07ad13}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_ace39c4eb87c43a1c1f1e38597e44edad}{}\index{Pattern\+Model@{Pattern\+Model}!computecoveragestats@{computecoveragestats}}
\index{computecoveragestats@{computecoveragestats}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{computecoveragestats(int category=0, int n=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::computecoveragestats (
\begin{DoxyParamCaption}
\item[{int}]{category = {\ttfamily 0}, }
\item[{int}]{n = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ace39c4eb87c43a1c1f1e38597e44edad}
Compute coverage statistics on the model, will generally be called automatically by methods who use it, and the statistics are cached after computation. 

Reimplemented in \hyperlink{classIndexedPatternModel_a0f0da07b70336e9699accedc2cde5351}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_a0f0da07b70336e9699accedc2cde5351}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_ac892ccc87080bc5eec5e8cb15460a15a}{}\index{Pattern\+Model@{Pattern\+Model}!computeflexgrams\+\_\+fromcooc@{computeflexgrams\+\_\+fromcooc}}
\index{computeflexgrams\+\_\+fromcooc@{computeflexgrams\+\_\+fromcooc}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{computeflexgrams\+\_\+fromcooc()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::computeflexgrams\+\_\+fromcooc (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ac892ccc87080bc5eec5e8cb15460a15a}
\hypertarget{classPatternModel_a833c6478ea967a4fa4c75c8ff971eac8}{}\index{Pattern\+Model@{Pattern\+Model}!computeflexgrams\+\_\+fromskipgrams@{computeflexgrams\+\_\+fromskipgrams}}
\index{computeflexgrams\+\_\+fromskipgrams@{computeflexgrams\+\_\+fromskipgrams}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{computeflexgrams\+\_\+fromskipgrams()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::computeflexgrams\+\_\+fromskipgrams (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a833c6478ea967a4fa4c75c8ff971eac8}


Reimplemented in \hyperlink{classIndexedPatternModel_a838f141f5f7cf888ce44bfc1b7a14ba3}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_a838f141f5f7cf888ce44bfc1b7a14ba3}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_acba7487b306d552d62bfd1ee45c8b504}{}\index{Pattern\+Model@{Pattern\+Model}!computeskipgrams@{computeskipgrams}}
\index{computeskipgrams@{computeskipgrams}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{computeskipgrams(const Pattern\+Pointer \&pattern, int mintokens=2, const Index\+Reference $\ast$singleref=\+N\+U\+L\+L, const Indexed\+Data $\ast$multiplerefs=\+N\+U\+L\+L, Pattern\+Model\+Interface $\ast$constrainbymodel=\+N\+U\+L\+L, std\+::vector$<$ Pattern\+Pointer $>$ $\ast$targetcontainer=\+N\+U\+L\+L, const bool exhaustive=false, const int maxskips=3, const bool D\+E\+B\+U\+G=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::computeskipgrams (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{int}]{mintokens = {\ttfamily 2}, }
\item[{const {\bf Index\+Reference} $\ast$}]{singleref = {\ttfamily NULL}, }
\item[{const {\bf Indexed\+Data} $\ast$}]{multiplerefs = {\ttfamily NULL}, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainbymodel = {\ttfamily NULL}, }
\item[{std\+::vector$<$ {\bf Pattern\+Pointer} $>$ $\ast$}]{targetcontainer = {\ttfamily NULL}, }
\item[{const bool}]{exhaustive = {\ttfamily false}, }
\item[{const int}]{maxskips = {\ttfamily 3}, }
\item[{const bool}]{D\+E\+B\+U\+G = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_acba7487b306d552d62bfd1ee45c8b504}
Low-\/level function to compute skipgrams for a given pattern . See higher-\/level function instead \hypertarget{classPatternModel_ad9d08c290da84543b324d36ac76efeeb}{}\index{Pattern\+Model@{Pattern\+Model}!computeskipgrams@{computeskipgrams}}
\index{computeskipgrams@{computeskipgrams}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{computeskipgrams(const Pattern\+Pointer \&pattern, Pattern\+Model\+Options \&options, const Index\+Reference $\ast$singleref=\+N\+U\+L\+L, const Indexed\+Data $\ast$multiplerefs=\+N\+U\+L\+L, Pattern\+Model\+Interface $\ast$constrainbymodel=\+N\+U\+L\+L, const bool exhaustive=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::computeskipgrams (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{{\bf Pattern\+Model\+Options} \&}]{options, }
\item[{const {\bf Index\+Reference} $\ast$}]{singleref = {\ttfamily NULL}, }
\item[{const {\bf Indexed\+Data} $\ast$}]{multiplerefs = {\ttfamily NULL}, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainbymodel = {\ttfamily NULL}, }
\item[{const bool}]{exhaustive = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ad9d08c290da84543b324d36ac76efeeb}
Low-\/level function to compute skipgrams for a given pattern. See \hyperlink{classPatternModel_ad18615c995fc3a6336bfed45fe21f5ac}{trainskipgrams()} instead. \hypertarget{classPatternModel_af27c14d58d1b7624cf6737645bd35d77}{}\index{Pattern\+Model@{Pattern\+Model}!computestats@{computestats}}
\index{computestats@{computestats}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{computestats()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::computestats (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_af27c14d58d1b7624cf6737645bd35d77}
Compute statistics on the model, will generally be called automatically by methods who use it, and the statistics are cached after computation. \hypertarget{classPatternModel_acffbefd7321ff9cd4032a1033933ed7a}{}\index{Pattern\+Model@{Pattern\+Model}!coverage@{coverage}}
\index{coverage@{coverage}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{coverage(const Pattern \&key)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ double {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::coverage (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{key}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_acffbefd7321ff9cd4032a1033933ed7a}
Return coverage as a fraction of the total number of tokens in the model. For unindexed models this is a maximal projection rather than exact number. \hypertarget{classPatternModel_a561547f4abe74d2138683bf279eceea7}{}\index{Pattern\+Model@{Pattern\+Model}!coveragecount@{coveragecount}}
\index{coveragecount@{coveragecount}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{coveragecount(const Pattern \&key)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::coveragecount (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{key}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a561547f4abe74d2138683bf279eceea7}
Returns the coverage count for the given pattern, for unindexed models, the coverage count is a mere maximum projection equal to the product of the occurence count and the size. \hypertarget{classPatternModel_a95c603b1ed42603a2dcb22f25d3c2c50}{}\index{Pattern\+Model@{Pattern\+Model}!extractset@{extractset}}
\index{extractset@{extractset}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{extractset(int minlength=1, int maxlength=1)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ {\bf Pattern\+Set}$<$uint64\+\_\+t$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::extractset (
\begin{DoxyParamCaption}
\item[{int}]{minlength = {\ttfamily 1}, }
\item[{int}]{maxlength = {\ttfamily 1}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a95c603b1ed42603a2dcb22f25d3c2c50}
Returns a \hyperlink{classPatternSet}{Pattern\+Set} containing patterns of the specified length. Patterns are actively reconstructed from patterns in the model, if necessary. So this includes patterns that are not in the model explicitly (i.\+e, smaller patterns that have been pruned. \hypertarget{classPatternModel_a559c400e5b8cfe2df18381ce8cdf61d1}{}\index{Pattern\+Model@{Pattern\+Model}!findskipgrams@{findskipgrams}}
\index{findskipgrams@{findskipgrams}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{findskipgrams(const Pattern\+Pointer \&pattern, unsigned int occurrencethreshold=1, int maxskips=3)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual std\+::vector$<${\bf Pattern\+Pointer}$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::findskipgrams (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{unsigned int}]{occurrencethreshold = {\ttfamily 1}, }
\item[{int}]{maxskips = {\ttfamily 3}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a559c400e5b8cfe2df18381ce8cdf61d1}
Returns a vector of all skipgrams that can be extracted from the given pattern \hypertarget{classPatternModel_a4ec1d0a963488d62afea4a67869758fa}{}\index{Pattern\+Model@{Pattern\+Model}!frequency@{frequency}}
\index{frequency@{frequency}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{frequency(const Pattern \&pattern)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ double {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::frequency (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a4ec1d0a963488d62afea4a67869758fa}
Returns the frequency of a pattern within its own group (category and size). For instance, if you pass a bigram you will get the occurence count as a fraction of the total occurrences of bigrams. 

Implements \hyperlink{classPatternModelInterface_abab22952ac502743377e3a5a524e2ae1}{Pattern\+Model\+Interface}.

\hypertarget{classPatternModel_a1b6c55216886cd765ab3189c24f8da2a}{}\index{Pattern\+Model@{Pattern\+Model}!getdata@{getdata}}
\index{getdata@{getdata}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getdata(const Pattern \&pattern, bool makeifnew=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual Value\+Type$\ast$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getdata (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{bool}]{makeifnew = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a1b6c55216886cd765ab3189c24f8da2a}
Get the value stored for the specified pattern. 
\begin{DoxyParams}{Parameters}
{\em makeifnew} & Add the pattern with empty value if it does not exist (default\+: false) \\
\hline
\end{DoxyParams}


Reimplemented in \hyperlink{classIndexedPatternModel_af242c0b747c2467e9e89f1cd731fe2d1}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_af242c0b747c2467e9e89f1cd731fe2d1}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_ad1c89dc32115373dec3b1a4e3cbeb700}{}\index{Pattern\+Model@{Pattern\+Model}!getdata@{getdata}}
\index{getdata@{getdata}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getdata(const Pattern\+Pointer \&pattern, bool makeifnew=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual Value\+Type$\ast$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getdata (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{bool}]{makeifnew = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ad1c89dc32115373dec3b1a4e3cbeb700}


Reimplemented in \hyperlink{classIndexedPatternModel_ac5a8ebe51c1a999a06c97ffc34d58401}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_ac5a8ebe51c1a999a06c97ffc34d58401}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_af713e95d9be78c75c6a065f0f0845b19}{}\index{Pattern\+Model@{Pattern\+Model}!getinstances@{getinstances}}
\index{getinstances@{getinstances}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getinstances(const Pattern \&pattern, int=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual {\bf t\+\_\+relationmap} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getinstances (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{int}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_af713e95d9be78c75c6a065f0f0845b19}
\hypertarget{classPatternModel_a21f827196f0475305ce3172220a63954}{}\index{Pattern\+Model@{Pattern\+Model}!getinterface@{getinterface}}
\index{getinterface@{getinterface}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getinterface()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ {\bf Pattern\+Model\+Interface}$\ast$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getinterface (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a21f827196f0475305ce3172220a63954}
Returns a more generic but limited \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} instance (polymorphism) \hypertarget{classPatternModel_a6a4a0403bd746b120b405545a3ec2295}{}\index{Pattern\+Model@{Pattern\+Model}!getleftneighbours@{getleftneighbours}}
\index{getleftneighbours@{getleftneighbours}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getleftneighbours(const Pattern \&pattern, int=0, int=0, int=0, int=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual {\bf t\+\_\+relationmap} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getleftneighbours (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a6a4a0403bd746b120b405545a3ec2295}
\hypertarget{classPatternModel_ac4a38270c6a2dbcfccf0b8baebee11eb}{}\index{Pattern\+Model@{Pattern\+Model}!getmodeltype@{getmodeltype}}
\index{getmodeltype@{getmodeltype}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getmodeltype() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getmodeltype (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ac4a38270c6a2dbcfccf0b8baebee11eb}
Returns the type of model (a value from Model\+Type) 

Implements \hyperlink{classPatternModelInterface_ad485931462c2f1c1bcd0aac13ec3028b}{Pattern\+Model\+Interface}.



Reimplemented in \hyperlink{classIndexedPatternPointerModel_a2cf62012c68c8557403226ff478500e9}{Indexed\+Pattern\+Pointer\+Model$<$ Map\+Type $>$}, \hyperlink{classPatternPointerModel_a6588706e670ebd3b14e2ab71c19011b7}{Pattern\+Pointer\+Model$<$ Value\+Type, Value\+Handler, Map\+Type $>$}, \hyperlink{classIndexedPatternModel_a63f42808d22dd3a813242332ad42ee6c}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_a63f42808d22dd3a813242332ad42ee6c}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_a760a01e32f97b63400d13e69384dad86}{}\index{Pattern\+Model@{Pattern\+Model}!getmodelversion@{getmodelversion}}
\index{getmodelversion@{getmodelversion}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getmodelversion() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getmodelversion (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a760a01e32f97b63400d13e69384dad86}
Returns the version of the model implementation and binary serialisation format 

Implements \hyperlink{classPatternModelInterface_a0d58b42e55df75e04faae361677aa777}{Pattern\+Model\+Interface}.



Reimplemented in \hyperlink{classIndexedPatternPointerModel_a34a68ddd193a441242b8d24fca7392b8}{Indexed\+Pattern\+Pointer\+Model$<$ Map\+Type $>$}, \hyperlink{classPatternPointerModel_a84979d2ff5033607dba04bb2210108d2}{Pattern\+Pointer\+Model$<$ Value\+Type, Value\+Handler, Map\+Type $>$}, \hyperlink{classIndexedPatternModel_a50e185e2f7e48751f8633d4b981089bc}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_a50e185e2f7e48751f8633d4b981089bc}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_a3439e0f9443ff0aeb551ca2b09486f7c}{}\index{Pattern\+Model@{Pattern\+Model}!getnpmi@{getnpmi}}
\index{getnpmi@{getnpmi}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getnpmi(const Pattern \&pattern, double threshold)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual {\bf t\+\_\+relationmap\+\_\+double} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getnpmi (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{double}]{threshold}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a3439e0f9443ff0aeb551ca2b09486f7c}
\hypertarget{classPatternModel_ae4b6fc4526f2bbcb1914c0ee8bbdf3c0}{}\index{Pattern\+Model@{Pattern\+Model}!getpatterns@{getpatterns}}
\index{getpatterns@{getpatterns}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getpatterns(const Pattern \&pattern)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ std\+::vector$<$std\+::pair$<${\bf Pattern}, int$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getpatterns (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_ae4b6fc4526f2bbcb1914c0ee8bbdf3c0}
get all patterns in pattern that occur in the patternmodel as a vector of pairs of Patterns and occurrence count. \hypertarget{classPatternModel_a340deff272001ac6f791bec792a03b45}{}\index{Pattern\+Model@{Pattern\+Model}!getreverseindex@{getreverseindex}}
\index{getreverseindex@{getreverseindex}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getreverseindex(const Index\+Reference ref, int occurrencecount=0, int category=0, unsigned int size=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ std\+::vector$<${\bf Pattern\+Pointer}$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getreverseindex (
\begin{DoxyParamCaption}
\item[{const {\bf Index\+Reference}}]{ref, }
\item[{int}]{occurrencecount = {\ttfamily 0}, }
\item[{int}]{category = {\ttfamily 0}, }
\item[{unsigned int}]{size = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a340deff272001ac6f791bec792a03b45}
Given a position in the corpus , return a vector of all the patterns that cover this position. 
\begin{DoxyParams}{Parameters}
{\em ref} & The position in the corpus \\
\hline
{\em occurrencecount} & If set above zero, filters to only include patterns occurring above this threshold \\
\hline
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) to include only this category. Set to 0 for unfiltered (default) \\
\hline
{\em size} & Set to any value above zero to only include patterns of the specified length. \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_acef58dc3b555f4eeec6fe55f423dc369}{}\index{Pattern\+Model@{Pattern\+Model}!getreverseindex\+\_\+bysentence@{getreverseindex\+\_\+bysentence}}
\index{getreverseindex\+\_\+bysentence@{getreverseindex\+\_\+bysentence}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getreverseindex\+\_\+bysentence(int sentence)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ std\+::vector$<$std\+::pair$<${\bf Index\+Reference},{\bf Pattern\+Pointer}$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getreverseindex\+\_\+bysentence (
\begin{DoxyParamCaption}
\item[{int}]{sentence}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_acef58dc3b555f4eeec6fe55f423dc369}
Returns pairs of positions and patterns, consisting of all patterns found in the specified sentence (or whatever unit delimites your corpus) 
\begin{DoxyParams}{Parameters}
{\em sentence} & The sentence index (starts at 1) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_ab2318a00ce10d348356070e567a2be3d}{}\index{Pattern\+Model@{Pattern\+Model}!getreverseindex\+\_\+left@{getreverseindex\+\_\+left}}
\index{getreverseindex\+\_\+left@{getreverseindex\+\_\+left}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getreverseindex\+\_\+left(const Index\+Reference ref)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ std\+::vector$<$std\+::pair$<${\bf Index\+Reference},{\bf Pattern\+Pointer}$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getreverseindex\+\_\+left (
\begin{DoxyParamCaption}
\item[{const {\bf Index\+Reference}}]{ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_ab2318a00ce10d348356070e567a2be3d}
Given a position in the corpus , return a vector of all the positions and patterns (as pairs) that occur to the left of this position 
\begin{DoxyParams}{Parameters}
{\em ref} & The position in the corpus \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a3d606eb9dfabd1c0ffba6e7b96d55cfc}{}\index{Pattern\+Model@{Pattern\+Model}!getreverseindex\+\_\+right@{getreverseindex\+\_\+right}}
\index{getreverseindex\+\_\+right@{getreverseindex\+\_\+right}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getreverseindex\+\_\+right(const Index\+Reference ref)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ std\+::vector$<$std\+::pair$<${\bf Index\+Reference},{\bf Pattern\+Pointer}$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getreverseindex\+\_\+right (
\begin{DoxyParamCaption}
\item[{const {\bf Index\+Reference}}]{ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a3d606eb9dfabd1c0ffba6e7b96d55cfc}
Given a position in the corpus , return a vector of all the positions and patterns (as pairs) that occur to the right of this position 
\begin{DoxyParams}{Parameters}
{\em ref} & The position in the corpus \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a0a5cffe0dd3e29485868a3fb013746d7}{}\index{Pattern\+Model@{Pattern\+Model}!getrightneighbours@{getrightneighbours}}
\index{getrightneighbours@{getrightneighbours}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getrightneighbours(const Pattern \&pattern, int=0, int=0, int=0, int=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual {\bf t\+\_\+relationmap} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getrightneighbours (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a0a5cffe0dd3e29485868a3fb013746d7}
\hypertarget{classPatternModel_ab0b9ea8b905ce180eec004413192abaf}{}\index{Pattern\+Model@{Pattern\+Model}!getskipcontent@{getskipcontent}}
\index{getskipcontent@{getskipcontent}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getskipcontent(const Pattern\+Pointer \&pattern)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual {\bf t\+\_\+relationmap} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getskipcontent (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ab0b9ea8b905ce180eec004413192abaf}


Reimplemented in \hyperlink{classIndexedPatternModel_a5dfb36835fbf8c1f0aed894217838c78}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_a5dfb36835fbf8c1f0aed894217838c78}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_a08a61e3c5dcb074e9567d5fbeeaa51e7}{}\index{Pattern\+Model@{Pattern\+Model}!getsubchildren@{getsubchildren}}
\index{getsubchildren@{getsubchildren}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getsubchildren(const Pattern \&pattern, int=0, int=0, int=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual {\bf t\+\_\+relationmap} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getsubchildren (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a08a61e3c5dcb074e9567d5fbeeaa51e7}
\hypertarget{classPatternModel_ac3de813c88755705e817a6f019ae29c6}{}\index{Pattern\+Model@{Pattern\+Model}!getsubparents@{getsubparents}}
\index{getsubparents@{getsubparents}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getsubparents(const Pattern \&pattern, int=0, int=0, int=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual {\bf t\+\_\+relationmap} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::getsubparents (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ac3de813c88755705e817a6f019ae29c6}
\hypertarget{classPatternModel_a93b191916d48602c8b2d62aa2ff9b5ac}{}\index{Pattern\+Model@{Pattern\+Model}!gettemplates@{gettemplates}}
\index{gettemplates@{gettemplates}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{gettemplates(const Pattern \&pattern, int=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual {\bf t\+\_\+relationmap} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::gettemplates (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{int}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a93b191916d48602c8b2d62aa2ff9b5ac}
\hypertarget{classPatternModel_ad2fa89b6a2eb8d2aebb8553a9da42b84}{}\index{Pattern\+Model@{Pattern\+Model}!has@{has}}
\index{has@{has}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{has(const Pattern \&pattern) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual bool {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::has (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ad2fa89b6a2eb8d2aebb8553a9da42b84}
Checks whether the given pattern occurs in the model 

Implements \hyperlink{classPatternStoreInterface_aec9f27496b38f8db1eced920fb2dc9fe}{Pattern\+Store\+Interface}.

\hypertarget{classPatternModel_a3a5098f2c1606c0685ccf97ad9f6cad6}{}\index{Pattern\+Model@{Pattern\+Model}!has@{has}}
\index{has@{has}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{has(const Pattern\+Pointer \&pattern) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual bool {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::has (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a3a5098f2c1606c0685ccf97ad9f6cad6}
Does the pattern occur in the pattern store? 

Implements \hyperlink{classPatternStoreInterface_a6b3e80cd9021201ce8992ad6c293a354}{Pattern\+Store\+Interface}.

\hypertarget{classPatternModel_a52421768bdfaf6041b9b9aac3007431b}{}\index{Pattern\+Model@{Pattern\+Model}!histogram@{histogram}}
\index{histogram@{histogram}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{histogram(std\+::map$<$ unsigned int, unsigned int $>$ \&hist, unsigned int threshold=0, unsigned int cap=0, int category=0, unsigned int size=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::histogram (
\begin{DoxyParamCaption}
\item[{std\+::map$<$ unsigned int, unsigned int $>$ \&}]{hist, }
\item[{unsigned int}]{threshold = {\ttfamily 0}, }
\item[{unsigned int}]{cap = {\ttfamily 0}, }
\item[{int}]{category = {\ttfamily 0}, }
\item[{unsigned int}]{size = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a52421768bdfaf6041b9b9aac3007431b}
Generate a histogram for the occurrence count of patterns 
\begin{DoxyParams}{Parameters}
{\em hist} & This will contain the to-\/be-\/computed histogram \\
\hline
{\em threshold} & Include only patterns at or above this occurrence threshold \\
\hline
{\em cap} & Include only this many of the top frequencies (0=unconstrained) \\
\hline
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) to filter or to 0 to cover all \\
\hline
{\em size} & Set to any value above zero to only include only patterns of the specified length. (0 for all sizes) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a89cea4fdb95cf5f1e9a363c76300062e}{}\index{Pattern\+Model@{Pattern\+Model}!histogram@{histogram}}
\index{histogram@{histogram}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{histogram(std\+::ostream $\ast$\+O\+U\+T, unsigned int threshold=0, unsigned int cap=0, int category=0, unsigned int size=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::histogram (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{O\+U\+T, }
\item[{unsigned int}]{threshold = {\ttfamily 0}, }
\item[{unsigned int}]{cap = {\ttfamily 0}, }
\item[{int}]{category = {\ttfamily 0}, }
\item[{unsigned int}]{size = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a89cea4fdb95cf5f1e9a363c76300062e}
Generate a histogram for the occurrence count of patterns and output it to the output stream. 
\begin{DoxyParams}{Parameters}
{\em O\+U\+T} & the output stream \\
\hline
{\em threshold} & Include only patterns at or above this occurrence threshold \\
\hline
{\em cap} & Include only this many of the top frequencies (0=unconstrained) \\
\hline
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) to filter or to 0 to cover all \\
\hline
{\em size} & Set to any value above zero to only include only patterns of the specified length. (0 for all sizes) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a6f4cc32e18eceda5029f215ab67f06e4}{}\index{Pattern\+Model@{Pattern\+Model}!info@{info}}
\index{info@{info}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{info(std\+::ostream $\ast$\+O\+U\+T)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::info (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{O\+U\+T}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a6f4cc32e18eceda5029f215ab67f06e4}
Output information about the model to the output stream, includes some statistics and technical details such as space requirements. \hypertarget{classPatternModel_ad9e711b16dc97fe4cb0fe5569b9327e4}{}\index{Pattern\+Model@{Pattern\+Model}!load@{load}}
\index{load@{load}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{load(std\+::string \&filename, const Pattern\+Model\+Options \&options, Pattern\+Model\+Interface $\ast$constrainmodel=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::load (
\begin{DoxyParamCaption}
\item[{std\+::string \&}]{filename, }
\item[{const {\bf Pattern\+Model\+Options} \&}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainmodel = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ad9e711b16dc97fe4cb0fe5569b9327e4}
Read a pattern model from file 
\begin{DoxyParams}{Parameters}
{\em filename} & The input filename \\
\hline
{\em options} & Options for reading, these act as filter for the data, allowing you to raise thresholds etc \\
\hline
{\em constrainmodel} & Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a84f6c2854b85e6aac9739cdb5807190b}{}\index{Pattern\+Model@{Pattern\+Model}!load@{load}}
\index{load@{load}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{load(std\+::istream $\ast$f, const Pattern\+Model\+Options \&options, Pattern\+Model\+Interface $\ast$constrainmodel=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::load (
\begin{DoxyParamCaption}
\item[{std\+::istream $\ast$}]{f, }
\item[{const {\bf Pattern\+Model\+Options} \&}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainmodel = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a84f6c2854b85e6aac9739cdb5807190b}
Read a pattern model from an input stream 
\begin{DoxyParams}{Parameters}
{\em f} & The input stream \\
\hline
{\em options} & Options for reading, these act as filter for the data, allowing you to raise thresholds etc \\
\hline
{\em constrainmodel} & Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a545fbfefef4eadb268217ec781c494bb}{}\index{Pattern\+Model@{Pattern\+Model}!maxlength@{maxlength}}
\index{maxlength@{maxlength}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{maxlength() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::maxlength (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a545fbfefef4eadb268217ec781c494bb}
Returns the maximum length of patterns in this model 

Implements \hyperlink{classPatternModelInterface_acbe234679e86792765d3afade8ce014c}{Pattern\+Model\+Interface}.

\hypertarget{classPatternModel_a7a0208745487928ecb418baeb78e810f}{}\index{Pattern\+Model@{Pattern\+Model}!minlength@{minlength}}
\index{minlength@{minlength}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{minlength() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::minlength (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a7a0208745487928ecb418baeb78e810f}
Returns the minimum length of patterns in this model 

Implements \hyperlink{classPatternModelInterface_a53325f7b36c9cf0de4954b618eff2416}{Pattern\+Model\+Interface}.

\hypertarget{classPatternModel_a013725360804aac3514eb8bb436102db}{}\index{Pattern\+Model@{Pattern\+Model}!occurrencecount@{occurrencecount}}
\index{occurrencecount@{occurrencecount}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{occurrencecount(const Pattern \&pattern)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::occurrencecount (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a013725360804aac3514eb8bb436102db}
Returns the occurrenc count of the specified pattern, will return 0 if it does not exist in the model 

Implements \hyperlink{classPatternModelInterface_afd9ec4756bb723ee6bf94321f05f1b71}{Pattern\+Model\+Interface}.

\hypertarget{classPatternModel_a5a945f4e01dfd36a24ea7d2e69fce91c}{}\index{Pattern\+Model@{Pattern\+Model}!occurrencecount@{occurrencecount}}
\index{occurrencecount@{occurrencecount}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{occurrencecount(const Pattern\+Pointer \&pattern)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::occurrencecount (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a5a945f4e01dfd36a24ea7d2e69fce91c}
\hypertarget{classPatternModel_ad3b35422f9af77624180503e01a5881a}{}\index{Pattern\+Model@{Pattern\+Model}!output@{output}}
\index{output@{output}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{output(std\+::ostream $\ast$)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::output (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{}
\end{DoxyParamCaption}
)}\label{classPatternModel_ad3b35422f9af77624180503e01a5881a}
\hypertarget{classPatternModel_ab9876cdcaeffbd2c04350e73b2be0bc3}{}\index{Pattern\+Model@{Pattern\+Model}!outputcooc@{outputcooc}}
\index{outputcooc@{outputcooc}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{outputcooc(std\+::ostream $\ast$\+O\+U\+T, Class\+Decoder \&classdecoder, double threshold)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::outputcooc (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{O\+U\+T, }
\item[{{\bf Class\+Decoder} \&}]{classdecoder, }
\item[{double}]{threshold}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ab9876cdcaeffbd2c04350e73b2be0bc3}


Reimplemented in \hyperlink{classIndexedPatternModel_a7029fb323b1ef87bcf821050e78e5cd9}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_a7029fb323b1ef87bcf821050e78e5cd9}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_aef998f743259e8d85d48b81eede5bd00}{}\index{Pattern\+Model@{Pattern\+Model}!outputcooc\+\_\+npmi@{outputcooc\+\_\+npmi}}
\index{outputcooc\+\_\+npmi@{outputcooc\+\_\+npmi}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{outputcooc\+\_\+npmi(std\+::ostream $\ast$\+O\+U\+T, Class\+Decoder \&classdecoder, double threshold)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::outputcooc\+\_\+npmi (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{O\+U\+T, }
\item[{{\bf Class\+Decoder} \&}]{classdecoder, }
\item[{double}]{threshold}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_aef998f743259e8d85d48b81eede5bd00}


Reimplemented in \hyperlink{classIndexedPatternModel_a17e2553ba9520ac45bac77f0948b1b21}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_a17e2553ba9520ac45bac77f0948b1b21}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_acff82b2b24874623673fad020c7c3c78}{}\index{Pattern\+Model@{Pattern\+Model}!outputrelations@{outputrelations}}
\index{outputrelations@{outputrelations}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{outputrelations(const Pattern \&pattern, Class\+Decoder \&classdecoder, std\+::ostream $\ast$\+O\+U\+T)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::outputrelations (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{{\bf Class\+Decoder} \&}]{classdecoder, }
\item[{std\+::ostream $\ast$}]{O\+U\+T}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_acff82b2b24874623673fad020c7c3c78}
\hypertarget{classPatternModel_a0e475078b9e3501c7ae8fc5d5683f671}{}\index{Pattern\+Model@{Pattern\+Model}!postread@{postread}}
\index{postread@{postread}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{postread(const Pattern\+Model\+Options options)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::postread (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Model\+Options}}]{options}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classPatternModel_a0e475078b9e3501c7ae8fc5d5683f671}


Reimplemented in \hyperlink{classIndexedPatternModel_a14708a972c0c3297421b370bbdc75b65}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_a14708a972c0c3297421b370bbdc75b65}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_a4dc600e5f375d412917c30c62265d6e8}{}\index{Pattern\+Model@{Pattern\+Model}!posttrain@{posttrain}}
\index{posttrain@{posttrain}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{posttrain(const Pattern\+Model\+Options options)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::posttrain (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Model\+Options}}]{options}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classPatternModel_a4dc600e5f375d412917c30c62265d6e8}


Reimplemented in \hyperlink{classIndexedPatternModel_a5314a6b877df1447d28128fb9d9e67b3}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_a5314a6b877df1447d28128fb9d9e67b3}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_aba01edce114df253215e905e63acbee1}{}\index{Pattern\+Model@{Pattern\+Model}!print@{print}}
\index{print@{print}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{print(std\+::ostream $\ast$out, Class\+Decoder \&decoder)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::print (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{out, }
\item[{{\bf Class\+Decoder} \&}]{decoder}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_aba01edce114df253215e905e63acbee1}
Print the contents of the pattern model, i.\+e. all patterns and associated counts, to the output stream. 
\begin{DoxyParams}{Parameters}
{\em out} & The output stream \\
\hline
{\em decoder} & The class decoder to use \\
\hline
\end{DoxyParams}


Reimplemented in \hyperlink{classIndexedPatternModel_ab139c59cacc6cabe5f1004c741feb9f6}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_ab139c59cacc6cabe5f1004c741feb9f6}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_ae2c135f4a441d6b80c50e89699419e1c}{}\index{Pattern\+Model@{Pattern\+Model}!print@{print}}
\index{print@{print}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{print(std\+::ostream $\ast$out, Class\+Decoder \&decoder, const Pattern\+Type \&pattern, bool endline=true)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::print (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{out, }
\item[{{\bf Class\+Decoder} \&}]{decoder, }
\item[{const {\bf Pattern\+Type} \&}]{pattern, }
\item[{bool}]{endline = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ae2c135f4a441d6b80c50e89699419e1c}
Print for one pattern only. 
\begin{DoxyParams}{Parameters}
{\em out} & The output stream \\
\hline
{\em decoder} & The class decoder to use \\
\hline
\end{DoxyParams}


Reimplemented in \hyperlink{classIndexedPatternModel_a3a2833e7343e15d7079ca40fe0d13652}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_a251e7848e11e320ab6ccf249d910cfd5}{}\index{Pattern\+Model@{Pattern\+Model}!printmodel@{printmodel}}
\index{printmodel@{printmodel}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{printmodel(std\+::ostream $\ast$out, Class\+Decoder \&decoder)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::printmodel (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{out, }
\item[{{\bf Class\+Decoder} \&}]{decoder}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a251e7848e11e320ab6ccf249d910cfd5}
Just an alias for \hyperlink{classPatternModel_aba01edce114df253215e905e63acbee1}{print()} \hypertarget{classPatternModel_a4b001eb3f0c864155cd35c92bbb451fb}{}\index{Pattern\+Model@{Pattern\+Model}!printpattern@{printpattern}}
\index{printpattern@{printpattern}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{printpattern(std\+::ostream $\ast$out, Class\+Decoder \&decoder, const Pattern \&pattern, bool endline=true)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::printpattern (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{out, }
\item[{{\bf Class\+Decoder} \&}]{decoder, }
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{bool}]{endline = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a4b001eb3f0c864155cd35c92bbb451fb}
Alias for per-\/pattern \hyperlink{classPatternModel_aba01edce114df253215e905e63acbee1}{print()} \hypertarget{classPatternModel_a0be389d2ec90c3d1ab368f915aa878f2}{}\index{Pattern\+Model@{Pattern\+Model}!printreverseindex@{printreverseindex}}
\index{printreverseindex@{printreverseindex}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{printreverseindex(std\+::ostream $\ast$out, Class\+Decoder \&decoder)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::printreverseindex (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{out, }
\item[{{\bf Class\+Decoder} \&}]{decoder}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a0be389d2ec90c3d1ab368f915aa878f2}
Print the full reverse index, a mapping of indices and all patterns that occur at those positions. 
\begin{DoxyParams}{Parameters}
{\em out} & The output stream \\
\hline
{\em decoder} & The class decoder to use \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a517a1b52861ad721569234756c41d2fc}{}\index{Pattern\+Model@{Pattern\+Model}!prune@{prune}}
\index{prune@{prune}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{prune(int threshold, int \+\_\+n=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::prune (
\begin{DoxyParamCaption}
\item[{int}]{threshold, }
\item[{int}]{\+\_\+n = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a517a1b52861ad721569234756c41d2fc}
Prune all patterns under the specified occurrence threshold (or -\/1 for all). Pruning can be limited to patterns of a particular size only. 
\begin{DoxyParams}{Parameters}
{\em threshold} & The occurrence threshold (set to -\/1 to prune everything) \\
\hline
{\em \+\_\+n} & The size constraint, limit to patterns of this size only (set to 0 for no constraint, default) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of distinct patterns pruned 
\end{DoxyReturn}
\hypertarget{classPatternModel_a25b7178a9c3ec629a26ca1b31e29d98e}{}\index{Pattern\+Model@{Pattern\+Model}!prunebymodel@{prunebymodel}}
\index{prunebymodel@{prunebymodel}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{prunebymodel(\+Pattern\+Model$<$ Value\+Type2, Value\+Handler2, Map\+Type2 $>$ \&secondmodel)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ template$<$class Value\+Type2 , class Value\+Handler2 , class Map\+Type2 $>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::prunebymodel (
\begin{DoxyParamCaption}
\item[{{\bf Pattern\+Model}$<$ Value\+Type2, Value\+Handler2, Map\+Type2 $>$ \&}]{secondmodel}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a25b7178a9c3ec629a26ca1b31e29d98e}
Prune all patterns that are not in the second model \begin{DoxyReturn}{Returns}
the number of distinct patterns pruned 
\end{DoxyReturn}
\hypertarget{classPatternModel_a079652a519c0abbf094e78f3b1e9ac22}{}\index{Pattern\+Model@{Pattern\+Model}!prunenotinset@{prunenotinset}}
\index{prunenotinset@{prunenotinset}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{prunenotinset(const std\+::unordered\+\_\+set$<$ Pattern $>$ \&s, int \+\_\+n)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::prunenotinset (
\begin{DoxyParamCaption}
\item[{const std\+::unordered\+\_\+set$<$ {\bf Pattern} $>$ \&}]{s, }
\item[{int}]{\+\_\+n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a079652a519c0abbf094e78f3b1e9ac22}
Prune all patterns that are not in the specified set. 
\begin{DoxyParams}{Parameters}
{\em s} & The set containing the patterns not to prune \\
\hline
{\em \+\_\+n} & The size constraint, limit to patterns of this size only (set to 0 for no constraint, default) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of distinct patterns pruned 
\end{DoxyReturn}
\hypertarget{classPatternModel_a4455376801a3ae1445d5a80a8f6276d1}{}\index{Pattern\+Model@{Pattern\+Model}!pruneskipgrams@{pruneskipgrams}}
\index{pruneskipgrams@{pruneskipgrams}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{pruneskipgrams(unsigned int threshold, int minskiptypes=2, int \+\_\+n=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::pruneskipgrams (
\begin{DoxyParamCaption}
\item[{unsigned int}]{threshold, }
\item[{int}]{minskiptypes = {\ttfamily 2}, }
\item[{int}]{\+\_\+n = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a4455376801a3ae1445d5a80a8f6276d1}
Prune all skipgrams under the specified occurrence threshold (or -\/1 for all). Pruning can be limited to patterns of a particular size only. 
\begin{DoxyParams}{Parameters}
{\em threshold} & The occurrence threshold (set to -\/1 to prune everything) \\
\hline
{\em \+\_\+n} & The size constraint, limit to patterns of this size only (set to 0 for no constraint, default) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of distinct patterns pruned 
\end{DoxyReturn}
\hypertarget{classPatternModel_a83ea8018b62f30b57f0626e5bf7d5a24}{}\index{Pattern\+Model@{Pattern\+Model}!report@{report}}
\index{report@{report}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{report(std\+::ostream $\ast$\+O\+U\+T)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::report (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{O\+U\+T}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a83ea8018b62f30b57f0626e5bf7d5a24}
Output an elaborate statistical report to the output stream. Computes on first call when necessary. \hypertarget{classPatternModel_a287b8993ee50fe32bb87b9de0aab352d}{}\index{Pattern\+Model@{Pattern\+Model}!resetstats@{resetstats}}
\index{resetstats@{resetstats}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{resetstats()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::resetstats (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a287b8993ee50fe32bb87b9de0aab352d}
\hypertarget{classPatternModel_a2422cb944da209f399b3b10f3b1d2684}{}\index{Pattern\+Model@{Pattern\+Model}!size@{size}}
\index{size@{size}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{size() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual size\+\_\+t {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a2422cb944da209f399b3b10f3b1d2684}
Returns the number of distinct patterns in the model 

Implements \hyperlink{classPatternStoreInterface_a225c319d318aad157512cd0001b05eb2}{Pattern\+Store\+Interface}.

\hypertarget{classPatternModel_a94648d91f0bb536c3295e0ccece2a2e7}{}\index{Pattern\+Model@{Pattern\+Model}!test@{test}}
\index{test@{test}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{test(\+Map\+Type \&target, std\+::istream $\ast$in)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::test (
\begin{DoxyParamCaption}
\item[{Map\+Type \&}]{target, }
\item[{std\+::istream $\ast$}]{in}
\end{DoxyParamCaption}
)}\label{classPatternModel_a94648d91f0bb536c3295e0ccece2a2e7}
\hypertarget{classPatternModel_a9e4a67d7c0136f9c9a8da56df5ffc18c}{}\index{Pattern\+Model@{Pattern\+Model}!tokens@{tokens}}
\index{tokens@{tokens}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{tokens() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::tokens (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a9e4a67d7c0136f9c9a8da56df5ffc18c}
Return the total amount of word/unigram tokens in the model 

Implements \hyperlink{classPatternModelInterface_aafea9a0f8fd453b85cffd18709a42ae7}{Pattern\+Model\+Interface}.

\hypertarget{classPatternModel_ad2e98cec42e61474b46c0799d4da951e}{}\index{Pattern\+Model@{Pattern\+Model}!topthreshold@{topthreshold}}
\index{topthreshold@{topthreshold}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{topthreshold(int amount, int category=0, int size=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::topthreshold (
\begin{DoxyParamCaption}
\item[{int}]{amount, }
\item[{int}]{category = {\ttfamily 0}, }
\item[{int}]{size = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_ad2e98cec42e61474b46c0799d4da951e}
\hypertarget{classPatternModel_ab7b6a79389ff67ca5af7b51a9144406f}{}\index{Pattern\+Model@{Pattern\+Model}!totaloccurrencesingroup@{totaloccurrencesingroup}}
\index{totaloccurrencesingroup@{totaloccurrencesingroup}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{totaloccurrencesingroup(int category, int n)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::totaloccurrencesingroup (
\begin{DoxyParamCaption}
\item[{int}]{category, }
\item[{int}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_ab7b6a79389ff67ca5af7b51a9144406f}
Obtains statistics of the model\+: returns the total amount of occurrences within the specified group, the group consist of a category and a size. 
\begin{DoxyParams}{Parameters}
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) or to 0 to cover all \\
\hline
{\em n} & Set to any value above zero to only cover only patterns of the specified length. (0 for all sizes) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a0b8154172f9d2884c8510559e2e1006c}{}\index{Pattern\+Model@{Pattern\+Model}!totalpatternsingroup@{totalpatternsingroup}}
\index{totalpatternsingroup@{totalpatternsingroup}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{totalpatternsingroup(int category, int n)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::totalpatternsingroup (
\begin{DoxyParamCaption}
\item[{int}]{category, }
\item[{int}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a0b8154172f9d2884c8510559e2e1006c}
Obtains statistics of the model\+: returns the total amount of distinct patterns within the specified group, the group consist of a category and a size. 
\begin{DoxyParams}{Parameters}
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) or to 0 to cover all \\
\hline
{\em n} & Set to any value above zero to only cover only patterns of the specified length. (0 for all sizes) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a406c8d2456ff2db65abbf061a1036917}{}\index{Pattern\+Model@{Pattern\+Model}!totaltokensingroup@{totaltokensingroup}}
\index{totaltokensingroup@{totaltokensingroup}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{totaltokensingroup(int category, int n)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::totaltokensingroup (
\begin{DoxyParamCaption}
\item[{int}]{category, }
\item[{int}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a406c8d2456ff2db65abbf061a1036917}
Obtains statistics of the model\+: returns the total amount of covered tokens within the specified group, the group consist of a category and a size. 
\begin{DoxyParams}{Parameters}
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) or to 0 to cover all \\
\hline
{\em n} & Set to any value above zero to only cover only patterns of the specified length. (0 for all sizes) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a2fdc64527855d87e2c6c8c89ae5355a7}{}\index{Pattern\+Model@{Pattern\+Model}!totalwordtypesingroup@{totalwordtypesingroup}}
\index{totalwordtypesingroup@{totalwordtypesingroup}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{totalwordtypesingroup(int category, int n)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::totalwordtypesingroup (
\begin{DoxyParamCaption}
\item[{int}]{category, }
\item[{int}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a2fdc64527855d87e2c6c8c89ae5355a7}
Obtains statistics of the model\+: returns the total amount of word/unigtams types within the specified group, the group consist of a category and a size. 
\begin{DoxyParams}{Parameters}
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) or to 0 to cover all \\
\hline
{\em n} & Set to any value above zero to only cover only patterns of the specified length. (0 for all sizes) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a0631a4a6c003e4aa18ec82ad4748ef76}{}\index{Pattern\+Model@{Pattern\+Model}!train@{train}}
\index{train@{train}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{train(std\+::istream $\ast$in, Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainbymodel=\+N\+U\+L\+L, bool continued=false, uint32\+\_\+t firstsentence=1, bool ignoreerrors=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::train (
\begin{DoxyParamCaption}
\item[{std\+::istream $\ast$}]{in, }
\item[{{\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainbymodel = {\ttfamily NULL}, }
\item[{bool}]{continued = {\ttfamily false}, }
\item[{uint32\+\_\+t}]{firstsentence = {\ttfamily 1}, }
\item[{bool}]{ignoreerrors = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a0631a4a6c003e4aa18ec82ad4748ef76}
Train a pattern model on corpus data (given an input stream) 
\begin{DoxyParams}{Parameters}
{\em in} & The input stream of the corpus data ($\ast$.colibri.\+dat), may be N\+U\+L\+L if a reverse index is loaded. \\
\hline
{\em options} & Options for training \\
\hline
{\em constrainbymodel} & Pointer to another pattern model which should be used to constrain the training of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
{\em continued} & Continued training on the same corpus data \\
\hline
{\em firstsentence} & First sentence index, useful for augmenting a model with another corpus (keep continued set to false in this case), defaults to 1 \\
\hline
{\em ignoreerrors} & Try to ignore errors (use for debug only) \\
\hline
\end{DoxyParams}


Reimplemented in \hyperlink{classIndexedPatternModel_ad416961213cc18e4c4a3d9f9e71d445e}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_ad416961213cc18e4c4a3d9f9e71d445e}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_a143ea1e2907a1efd0550f52a51e55539}{}\index{Pattern\+Model@{Pattern\+Model}!train@{train}}
\index{train@{train}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{train(const std\+::string \&filename, Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainbymodel=\+N\+U\+L\+L, bool continued=false, uint32\+\_\+t firstsentence=1, bool ignoreerrors=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::train (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{filename, }
\item[{{\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainbymodel = {\ttfamily NULL}, }
\item[{bool}]{continued = {\ttfamily false}, }
\item[{uint32\+\_\+t}]{firstsentence = {\ttfamily 1}, }
\item[{bool}]{ignoreerrors = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a143ea1e2907a1efd0550f52a51e55539}
Train a pattern model on corpus data 
\begin{DoxyParams}{Parameters}
{\em filename} & The filename of the corpus data ($\ast$.colibri.\+dat) \\
\hline
{\em options} & Options for training \\
\hline
{\em constrainbymodel} & Pointer to another pattern model which should be used to constrain the training of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
\end{DoxyParams}


Reimplemented in \hyperlink{classIndexedPatternModel_a22f094eef93f4afbfed7697724975220}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_a22f094eef93f4afbfed7697724975220}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_ad18615c995fc3a6336bfed45fe21f5ac}{}\index{Pattern\+Model@{Pattern\+Model}!trainskipgrams@{trainskipgrams}}
\index{trainskipgrams@{trainskipgrams}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{trainskipgrams(const Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainbymodel=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::trainskipgrams (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainbymodel = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ad18615c995fc3a6336bfed45fe21f5ac}
Train skipgrams, for indexed models only 

Reimplemented in \hyperlink{classIndexedPatternModel_a0bd2f75e24f53a70170468bb1dc4caaf}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}, and \hyperlink{classIndexedPatternModel_a0bd2f75e24f53a70170468bb1dc4caaf}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Pointer $>$}.

\hypertarget{classPatternModel_a1feab3a0fd585ca17f87b5af54fc7f61}{}\index{Pattern\+Model@{Pattern\+Model}!type@{type}}
\index{type@{type}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{type() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ unsigned char {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::type (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a1feab3a0fd585ca17f87b5af54fc7f61}
\hypertarget{classPatternModel_a6e5ac4583443112eb1a78157aed967b5}{}\index{Pattern\+Model@{Pattern\+Model}!types@{types}}
\index{types@{types}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{types()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ virtual unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::types (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a6e5ac4583443112eb1a78157aed967b5}
Return the total amount of word/unigram types in the model 

Implements \hyperlink{classPatternModelInterface_a5f3fab33835e8b01bf30b20793746e24}{Pattern\+Model\+Interface}.

\hypertarget{classPatternModel_a30dac843287129d9d4c3c34459697835}{}\index{Pattern\+Model@{Pattern\+Model}!version@{version}}
\index{version@{version}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{version() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ unsigned char {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::version (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a30dac843287129d9d4c3c34459697835}
\hypertarget{classPatternModel_abf61a21bcfd5dd0131ae394486c70e2d}{}\index{Pattern\+Model@{Pattern\+Model}!write@{write}}
\index{write@{write}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{write(std\+::ostream $\ast$out)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::write (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{out}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_abf61a21bcfd5dd0131ae394486c70e2d}
Write the pattern model to output stream \hypertarget{classPatternModel_a5c9ba026899810524d2e8254089bde66}{}\index{Pattern\+Model@{Pattern\+Model}!write@{write}}
\index{write@{write}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{write(const std\+::string filename)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::write (
\begin{DoxyParamCaption}
\item[{const std\+::string}]{filename}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a5c9ba026899810524d2e8254089bde66}
Save the entire pattern model to file 

\subsection{Member Data Documentation}
\hypertarget{classPatternModel_a2fa59bed9f90745782983b4041981b88}{}\index{Pattern\+Model@{Pattern\+Model}!cache\+\_\+categories@{cache\+\_\+categories}}
\index{cache\+\_\+categories@{cache\+\_\+categories}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{cache\+\_\+categories}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ std\+::set$<$int$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::cache\+\_\+categories\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a2fa59bed9f90745782983b4041981b88}
\hypertarget{classPatternModel_a9a4c974fe564fcad7471b1e05e231394}{}\index{Pattern\+Model@{Pattern\+Model}!cache\+\_\+grouptotal@{cache\+\_\+grouptotal}}
\index{cache\+\_\+grouptotal@{cache\+\_\+grouptotal}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{cache\+\_\+grouptotal}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ std\+::map$<$int,std\+::map$<$int,unsigned int$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::cache\+\_\+grouptotal\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a9a4c974fe564fcad7471b1e05e231394}


total occurrences (used for frequency computation, within a group) 

\hypertarget{classPatternModel_abf5c303232c7fcd54bbd73125be4ca53}{}\index{Pattern\+Model@{Pattern\+Model}!cache\+\_\+grouptotalpatterns@{cache\+\_\+grouptotalpatterns}}
\index{cache\+\_\+grouptotalpatterns@{cache\+\_\+grouptotalpatterns}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{cache\+\_\+grouptotalpatterns}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ std\+::map$<$int,std\+::map$<$int,unsigned int$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::cache\+\_\+grouptotalpatterns\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_abf5c303232c7fcd54bbd73125be4ca53}


total distinct patterns per group 

\hypertarget{classPatternModel_a3b1718a6e2a3d0e2aa328fc18b3f2527}{}\index{Pattern\+Model@{Pattern\+Model}!cache\+\_\+grouptotaltokens@{cache\+\_\+grouptotaltokens}}
\index{cache\+\_\+grouptotaltokens@{cache\+\_\+grouptotaltokens}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{cache\+\_\+grouptotaltokens}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ std\+::map$<$int,std\+::map$<$int,unsigned int$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::cache\+\_\+grouptotaltokens\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a3b1718a6e2a3d0e2aa328fc18b3f2527}


total covered tokens per group 

\hypertarget{classPatternModel_aa1055f5f99d2abb04c7a0bcc8b0dbc5b}{}\index{Pattern\+Model@{Pattern\+Model}!cache\+\_\+grouptotalwordtypes@{cache\+\_\+grouptotalwordtypes}}
\index{cache\+\_\+grouptotalwordtypes@{cache\+\_\+grouptotalwordtypes}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{cache\+\_\+grouptotalwordtypes}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ std\+::map$<$int,std\+::map$<$int,unsigned int$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::cache\+\_\+grouptotalwordtypes\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_aa1055f5f99d2abb04c7a0bcc8b0dbc5b}


total covered word types per group 

\hypertarget{classPatternModel_a2ac397c0ba615b4ac11d7014bea8efcb}{}\index{Pattern\+Model@{Pattern\+Model}!cache\+\_\+n@{cache\+\_\+n}}
\index{cache\+\_\+n@{cache\+\_\+n}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{cache\+\_\+n}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ std\+::set$<$int$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::cache\+\_\+n\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a2ac397c0ba615b4ac11d7014bea8efcb}
\hypertarget{classPatternModel_a6136c80df09f3721420f97606c6412b6}{}\index{Pattern\+Model@{Pattern\+Model}!gapmasks@{gapmasks}}
\index{gapmasks@{gapmasks}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{gapmasks}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ std\+::map$<$int, std\+::vector$<$ uint32\+\_\+t $>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::gapmasks\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a6136c80df09f3721420f97606c6412b6}


pre-\/computed masks representing possible gap configurations for various pattern lengths 

\hypertarget{classPatternModel_a56ba07cb9c7691cb228903681d707436}{}\index{Pattern\+Model@{Pattern\+Model}!hasskipgrams@{hasskipgrams}}
\index{hasskipgrams@{hasskipgrams}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{hasskipgrams}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ bool {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::hasskipgrams}\label{classPatternModel_a56ba07cb9c7691cb228903681d707436}


Does this model have skipgrams? 

\hypertarget{classPatternModel_a9403f8a6b15d7b5bcc8f12981dbc66ff}{}\index{Pattern\+Model@{Pattern\+Model}!maxn@{maxn}}
\index{maxn@{maxn}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{maxn}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::maxn\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a9403f8a6b15d7b5bcc8f12981dbc66ff}
\hypertarget{classPatternModel_a22933685f5f30ace6099d44e65c3efb7}{}\index{Pattern\+Model@{Pattern\+Model}!minn@{minn}}
\index{minn@{minn}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{minn}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::minn\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a22933685f5f30ace6099d44e65c3efb7}
\hypertarget{classPatternModel_afd14feab6f5cebac0b02232ce3adf44b}{}\index{Pattern\+Model@{Pattern\+Model}!model\+\_\+type@{model\+\_\+type}}
\index{model\+\_\+type@{model\+\_\+type}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{model\+\_\+type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ unsigned char {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::model\+\_\+type\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_afd14feab6f5cebac0b02232ce3adf44b}
\hypertarget{classPatternModel_a512b5e8516c92983f95141d24d944f1d}{}\index{Pattern\+Model@{Pattern\+Model}!model\+\_\+version@{model\+\_\+version}}
\index{model\+\_\+version@{model\+\_\+version}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{model\+\_\+version}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ unsigned char {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::model\+\_\+version\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a512b5e8516c92983f95141d24d944f1d}
\hypertarget{classPatternModel_af816b73fbc0a1247f54fbb50593dce22}{}\index{Pattern\+Model@{Pattern\+Model}!reverseindex@{reverseindex}}
\index{reverseindex@{reverseindex}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{reverseindex}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ {\bf Indexed\+Corpus}$\ast$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::reverseindex}\label{classPatternModel_af816b73fbc0a1247f54fbb50593dce22}


Pointer to the reverse index and corpus data for this model (or N\+U\+L\+L) 

\hypertarget{classPatternModel_a42dc001ef7580e133518d4cc9164cad9}{}\index{Pattern\+Model@{Pattern\+Model}!reverseindex\+\_\+internal@{reverseindex\+\_\+internal}}
\index{reverseindex\+\_\+internal@{reverseindex\+\_\+internal}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{reverseindex\+\_\+internal}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ bool {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::reverseindex\+\_\+internal}\label{classPatternModel_a42dc001ef7580e133518d4cc9164cad9}
\hypertarget{classPatternModel_ada5d1db54c4e30a705aa13ce619e6d9a}{}\index{Pattern\+Model@{Pattern\+Model}!totaltokens@{totaltokens}}
\index{totaltokens@{totaltokens}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{totaltokens}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ uint64\+\_\+t {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::totaltokens\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_ada5d1db54c4e30a705aa13ce619e6d9a}


Total number of tokens in the original corpus, so I\+N\+C\+L\+U\+D\+E\+S T\+O\+K\+E\+N\+S N\+O\+T C\+O\+V\+E\+R\+E\+D B\+Y T\+H\+E M\+O\+D\+E\+L! 

\hypertarget{classPatternModel_a154c6d3c25265c2c8a40e9e78d4e09ed}{}\index{Pattern\+Model@{Pattern\+Model}!totaltypes@{totaltypes}}
\index{totaltypes@{totaltypes}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{totaltypes}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$, class Pattern\+Type = Pattern$>$ uint64\+\_\+t {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type, {\bf Pattern\+Type} $>$\+::totaltypes\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a154c6d3c25265c2c8a40e9e78d4e09ed}


Total number of unigram/word types in the original corpus, S\+O I\+N\+C\+L\+U\+D\+I\+N\+G N\+O\+T C\+O\+V\+E\+R\+E\+D B\+Y T\+H\+E M\+O\+D\+E\+L! 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/\hyperlink{patternmodel_8h}{patternmodel.\+h}\end{DoxyCompactItemize}
