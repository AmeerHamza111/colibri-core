\hypertarget{classPatternModel}{}\section{Pattern\+Model$<$ Value\+Type, Value\+Handler, Map\+Type $>$ Class Template Reference}
\label{classPatternModel}\index{Pattern\+Model$<$ Value\+Type, Value\+Handler, Map\+Type $>$@{Pattern\+Model$<$ Value\+Type, Value\+Handler, Map\+Type $>$}}


A model mapping patterns to values, gigh-\/level interface.  




{\ttfamily \#include $<$patternmodel.\+h$>$}

Inheritance diagram for Pattern\+Model$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=1.702128cm]{classPatternModel}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef Map\+Type\+::iterator \hyperlink{classPatternModel_a8aedb15ca2b6f5e3d619c1878d5c0639}{iterator}
\item 
typedef Map\+Type\+::const\+\_\+iterator \hyperlink{classPatternModel_aecfc44c56122e8037bb634a3d66bac0a}{const\+\_\+iterator}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPatternModel_ade6d8f3c3bae062c06881d96809ea4ff}{Pattern\+Model} (\hyperlink{classIndexedCorpus}{Indexed\+Corpus} $\ast$corpus=N\+U\+L\+L)
\item 
\hyperlink{classPatternModel_a9f1e66e0893ead99e75013cb578cd54a}{Pattern\+Model} (std\+::istream $\ast$f, \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainmodel=N\+U\+L\+L, \hyperlink{classIndexedCorpus}{Indexed\+Corpus} $\ast$corpus=N\+U\+L\+L)
\item 
\hyperlink{classPatternModel_afd68d5b590a3b477f7fdee2921755a44}{Pattern\+Model} (const std\+::string filename, const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainmodel=N\+U\+L\+L, \hyperlink{classIndexedCorpus}{Indexed\+Corpus} $\ast$corpus=N\+U\+L\+L)
\item 
virtual int \hyperlink{classPatternModel_aadea1e70400eb2aeced1ca1648cf9cd9}{getmodeltype} () const 
\item 
virtual int \hyperlink{classPatternModel_ac2f98f98d449951caa82894be78e9fe6}{getmodelversion} () const 
\item 
virtual size\+\_\+t \hyperlink{classPatternModel_a25f387acaf981af9962195bd05b3e7e2}{size} () const 
\item 
virtual bool \hyperlink{classPatternModel_a577eb056f583b4efc943ac4e7a581b1b}{has} (const \hyperlink{classPattern}{Pattern} \&pattern) const 
\item 
virtual bool \hyperlink{classPatternModel_af94a590e3c5eacde04cb55430198acfa}{has} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern) const 
\item 
virtual void \hyperlink{classPatternModel_a26de418f6998cac0f484a958597afccc}{load} (std\+::string filename, const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainmodel=N\+U\+L\+L)
\item 
virtual void \hyperlink{classPatternModel_acbfb81964c7a6eb13d846dc11d2cc667}{load} (std\+::istream $\ast$f, const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainmodel=N\+U\+L\+L)
\item 
\hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$ \hyperlink{classPatternModel_a837bdbf478b7ea8a51ad674418926175}{getinterface} ()
\item 
virtual void \hyperlink{classPatternModel_ac1e8a9a955f8da64abe95179482a6b55}{train} (std\+::istream $\ast$in, \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainbymodel=N\+U\+L\+L)
\item 
virtual void \hyperlink{classPatternModel_ac2390acee4c9aeecf1bce2d0b312bb4c}{train} (const std\+::string filename, const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainbymodel=N\+U\+L\+L)
\item 
virtual int \hyperlink{classPatternModel_aa8a7898c399c670792af12f509adcd28}{computeskipgrams} (const \hyperlink{classPattern}{Pattern} \&pattern, int mintokens=2, const \hyperlink{classIndexReference}{Index\+Reference} $\ast$singleref=N\+U\+L\+L, const \hyperlink{classIndexedData}{Indexed\+Data} $\ast$multiplerefs=N\+U\+L\+L, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainbymodel=N\+U\+L\+L, std\+::vector$<$ \hyperlink{classPattern}{Pattern} $>$ $\ast$targetcontainer=N\+U\+L\+L, const bool exhaustive=false, const bool D\+E\+B\+U\+G=false)
\item 
virtual int \hyperlink{classPatternModel_a00b3338b6e79a3dbc9b5f95cb0171494}{computeskipgrams} (const \hyperlink{classPattern}{Pattern} \&pattern, \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} \&options, const \hyperlink{classIndexReference}{Index\+Reference} $\ast$singleref=N\+U\+L\+L, const \hyperlink{classIndexedData}{Indexed\+Data} $\ast$multiplerefs=N\+U\+L\+L, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainbymodel=N\+U\+L\+L, const bool exhaustive=false)
\item 
virtual std\+::vector$<$ \hyperlink{classPattern}{Pattern} $>$ \hyperlink{classPatternModel_aa4aa18a4d9e7554a3c798872e915e8a0}{findskipgrams} (const \hyperlink{classPattern}{Pattern} \&pattern, unsigned int occurrencethreshold=1)
\item 
virtual void \hyperlink{classPatternModel_acd4e0ecc0e796c894b994859b2c5ffb6}{trainskipgrams} (const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainbymodel=N\+U\+L\+L)
\item 
void \hyperlink{classPatternModel_a21fb390761ae0fc47e3a48621c94698b}{test} (Map\+Type \&target, std\+::istream $\ast$in)
\item 
void \hyperlink{classPatternModel_a3456e788caacd51fe3c7fb8fdf547723}{write} (std\+::ostream $\ast$out)
\item 
void \hyperlink{classPatternModel_a73654320cd52e691fd7df037cf3ff013}{write} (const std\+::string filename)
\item 
virtual int \hyperlink{classPatternModel_ac0d63c6c6ada696e3a247e25df8487ec}{maxlength} () const 
\item 
virtual int \hyperlink{classPatternModel_a4777ec9b1e76ef3c2ccbc981dad15129}{minlength} () const 
\item 
virtual unsigned int \hyperlink{classPatternModel_a8f5bc659abbbdd456937e85642a97d40}{occurrencecount} (const \hyperlink{classPattern}{Pattern} \&pattern)
\item 
virtual Value\+Type $\ast$ \hyperlink{classPatternModel_aaec0fa3d026d88bc5b8e2dc5f0994015}{getdata} (const \hyperlink{classPattern}{Pattern} \&pattern, bool makeifnew=false)
\item 
virtual Value\+Type $\ast$ \hyperlink{classPatternModel_a1baf331b3a10a45fdadd6a835a744cf3}{getdata} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&patternpointer, bool makeifnew=false)
\item 
virtual unsigned int \hyperlink{classPatternModel_af5df3d30417804589c552320add3285a}{types} ()
\item 
virtual unsigned int \hyperlink{classPatternModel_afac99feddfa4cf1dc44090c5148e518a}{tokens} () const 
\item 
unsigned char \hyperlink{classPatternModel_a7df468e440b875af0d9321d090f87dab}{type} () const 
\item 
unsigned char \hyperlink{classPatternModel_af56c31e031bb51d47e98cc433a46556e}{version} () const 
\item 
void \hyperlink{classPatternModel_aafa8d87b4b2269e796d97902f3214d22}{output} (std\+::ostream $\ast$)
\item 
unsigned int \hyperlink{classPatternModel_a5bad2b94ec96880f3e4307d55c42e492}{coveragecount} (const \hyperlink{classPattern}{Pattern} \&key)
\item 
double \hyperlink{classPatternModel_a07eb601afe937b144e100cd96d091d3a}{coverage} (const \hyperlink{classPattern}{Pattern} \&key)
\item 
std\+::vector$<$ \hyperlink{classPattern}{Pattern} $>$ \hyperlink{classPatternModel_a6b37ea19d0646bff54cae15290fc884c}{getreverseindex} (const \hyperlink{classIndexReference}{Index\+Reference} ref, int \hyperlink{classPatternModel_a8f5bc659abbbdd456937e85642a97d40}{occurrencecount}=0, int category=0, unsigned int \hyperlink{classPatternModel_a25f387acaf981af9962195bd05b3e7e2}{size}=0)
\item 
std\+::vector$<$ std\+::pair$<$ \hyperlink{classIndexReference}{Index\+Reference}, \hyperlink{classPattern}{Pattern} $>$ $>$ \hyperlink{classPatternModel_abca7b37dfacef90de4e2139acb99cedb}{getreverseindex\+\_\+bysentence} (int sentence)
\item 
std\+::vector$<$ std\+::pair$<$ \hyperlink{classIndexReference}{Index\+Reference}, \hyperlink{classPattern}{Pattern} $>$ $>$ \hyperlink{classPatternModel_a0c49738d4296c9dde3ee2796d6b66814}{getreverseindex\+\_\+right} (const \hyperlink{classIndexReference}{Index\+Reference} ref)
\item 
std\+::vector$<$ std\+::pair$<$ \hyperlink{classIndexReference}{Index\+Reference}, \hyperlink{classPattern}{Pattern} $>$ $>$ \hyperlink{classPatternModel_aec29a383939fa71f61edfea80ea1b2d0}{getreverseindex\+\_\+left} (const \hyperlink{classIndexReference}{Index\+Reference} ref)
\item 
void \hyperlink{classPatternModel_a06b0d7452c19849930d6b3d19888130d}{computestats} ()
\item 
virtual void \hyperlink{classPatternModel_ae36bb1e641f954ee78a5fbab98ae069a}{computecoveragestats} ()
\item 
unsigned int \hyperlink{classPatternModel_a4ad5fd4ad8ed72160938ca9a30d26201}{totaloccurrencesingroup} (int category, int n)
\item 
unsigned int \hyperlink{classPatternModel_a38fd6f8f536a802d6653665aa4d48cbf}{totalpatternsingroup} (int category, int n)
\item 
unsigned int \hyperlink{classPatternModel_a23de99349652ec0774db5d09593bd255}{totalwordtypesingroup} (int category, int n)
\item 
unsigned int \hyperlink{classPatternModel_aaa5f43e06e2262fc4387729fc6265050}{totaltokensingroup} (int category, int n)
\item 
double \hyperlink{classPatternModel_a0927686caf05d2e1accff6e158a75188}{frequency} (const \hyperlink{classPattern}{Pattern} \&pattern)
\item 
virtual void \hyperlink{classPatternModel_a0cdb8badafbce0f56089f7c2b8f4716a}{add} (const \hyperlink{classPattern}{Pattern} \&pattern, Value\+Type $\ast$value, const \hyperlink{classIndexReference}{Index\+Reference} \&ref)
\item 
virtual void \hyperlink{classPatternModel_ad16097db7894d75815cd40ef5acc99a5}{add} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, Value\+Type $\ast$value, const \hyperlink{classIndexReference}{Index\+Reference} \&ref)
\item 
unsigned int \hyperlink{classPatternModel_a3698c1c47789b2fb2eae65d96ed4e3ab}{prune} (int threshold, int \+\_\+n=0)
\item 
virtual unsigned int \hyperlink{classPatternModel_a30da80bd942ab1bac95ac9945f465702}{pruneskipgrams} (unsigned int threshold, int minskiptypes=2, int \+\_\+n=0)
\item 
unsigned int \hyperlink{classPatternModel_ab4429ca9cb19f12e4b0bb7b8cb0e6fe7}{prunenotinset} (const std\+::unordered\+\_\+set$<$ \hyperlink{classPattern}{Pattern} $>$ \&s, int \+\_\+n)
\item 
{\footnotesize template$<$class Value\+Type2 , class Value\+Handler2 , class Map\+Type2 $>$ }\\unsigned int \hyperlink{classPatternModel_a787ccf34c969a5e14aa2e1bdcb164ee7}{prunebymodel} (\hyperlink{classPatternModel}{Pattern\+Model}$<$ Value\+Type2, Value\+Handler2, Map\+Type2 $>$ \&secondmodel)
\item 
std\+::vector$<$ std\+::pair$<$ \hyperlink{classPattern}{Pattern}, int $>$ $>$ \hyperlink{classPatternModel_ad5d110daa1691b266ad325b1a2f7a842}{getpatterns} (const \hyperlink{classPattern}{Pattern} \&pattern)
\item 
virtual void \hyperlink{classPatternModel_a6d645bd24603696e77d6904c09d9b39c}{print} (std\+::ostream $\ast$out, \hyperlink{classClassDecoder}{Class\+Decoder} \&decoder)
\item 
virtual void \hyperlink{classPatternModel_aa5d23339ceb528e9cb7a02640bce392c}{printreverseindex} (std\+::ostream $\ast$out, \hyperlink{classClassDecoder}{Class\+Decoder} \&decoder)
\item 
void \hyperlink{classPatternModel_a30b0bf9471b82119000b38c620ffc21e}{printmodel} (std\+::ostream $\ast$out, \hyperlink{classClassDecoder}{Class\+Decoder} \&decoder)
\item 
virtual void \hyperlink{classPatternModel_a58bbe1d44c4daf8560872f97d124a836}{print} (std\+::ostream $\ast$out, \hyperlink{classClassDecoder}{Class\+Decoder} \&decoder, const \hyperlink{classPattern}{Pattern} \&pattern, bool endline=true)
\item 
void \hyperlink{classPatternModel_aaa497ee9bd6b1abe6ab4451fbf7272f4}{printpattern} (std\+::ostream $\ast$out, \hyperlink{classClassDecoder}{Class\+Decoder} \&decoder, const \hyperlink{classPattern}{Pattern} \&pattern, bool endline=true)
\item 
void \hyperlink{classPatternModel_a72c97f76cca2ba56099eb1559a7b0ddd}{histogram} (std\+::map$<$ unsigned int, unsigned int $>$ \&hist, unsigned int threshold=0, unsigned int cap=0, int category=0, unsigned int \hyperlink{classPatternModel_a25f387acaf981af9962195bd05b3e7e2}{size}=0)
\item 
unsigned int \hyperlink{classPatternModel_a1e4c12ee56b5ae88f4a5b140ac6a6a0a}{topthreshold} (int amount, int category=0, int \hyperlink{classPatternModel_a25f387acaf981af9962195bd05b3e7e2}{size}=0)
\item 
void \hyperlink{classPatternModel_a9edf12738542d8d8b0cc9aa06b5a69b2}{histogram} (std\+::ostream $\ast$O\+U\+T, unsigned int threshold=0, unsigned int cap=0, int category=0, unsigned int \hyperlink{classPatternModel_a25f387acaf981af9962195bd05b3e7e2}{size}=0)
\item 
void \hyperlink{classPatternModel_a231e5e4c9ed49764b24718e4269b4256}{info} (std\+::ostream $\ast$O\+U\+T)
\item 
void \hyperlink{classPatternModel_aee8c647241c7ec1a80e088b13e232a06}{report} (std\+::ostream $\ast$O\+U\+T)
\item 
\hyperlink{classPatternSet}{Pattern\+Set}$<$ uint64\+\_\+t $>$ \hyperlink{classPatternModel_a8881489a5a99215499809c6dcbe704e9}{extractset} (int \hyperlink{classPatternModel_a4777ec9b1e76ef3c2ccbc981dad15129}{minlength}=1, int \hyperlink{classPatternModel_ac0d63c6c6ada696e3a247e25df8487ec}{maxlength}=1)
\item 
virtual void \hyperlink{classPatternModel_aa350e235140e580526d381c626355b58}{outputrelations} (const \hyperlink{classPattern}{Pattern} \&pattern, \hyperlink{classClassDecoder}{Class\+Decoder} \&classdecoder, std\+::ostream $\ast$O\+U\+T)
\item 
virtual \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classPatternModel_a3b0fa1ea8423db319dfd6f338f7b2b40}{getsubchildren} (const \hyperlink{classPattern}{Pattern} \&pattern, int=0, int=0, int=0)
\item 
virtual \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classPatternModel_a5fb7d6ef4e82a300557f2e0350209a6f}{getsubparents} (const \hyperlink{classPattern}{Pattern} \&pattern, int=0, int=0, int=0)
\item 
virtual \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classPatternModel_a997f4cfc3e65fb218097061f9d4429ca}{gettemplates} (const \hyperlink{classPattern}{Pattern} \&pattern, int=0)
\item 
virtual \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classPatternModel_a564b582aba0eedacd4b0b6f2fa693f7d}{getinstances} (const \hyperlink{classPattern}{Pattern} \&pattern, int=0)
\item 
virtual \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classPatternModel_aa9d5de68d7989ba234d2628ab4af35fb}{getskipcontent} (const \hyperlink{classPattern}{Pattern} \&pattern)
\item 
virtual \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classPatternModel_aea7593acd2798e2e77ed5cb4e75d3f67}{getleftneighbours} (const \hyperlink{classPattern}{Pattern} \&pattern, int=0, int=0, int=0, int=0)
\item 
virtual \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classPatternModel_ad34484b6262acb5967de624a14e73085}{getrightneighbours} (const \hyperlink{classPattern}{Pattern} \&pattern, int=0, int=0, int=0, int=0)
\item 
virtual \hyperlink{patternmodel_8h_ae13b52c8cf777358f19da17c90c7dac0}{t\+\_\+relationmap\+\_\+double} \hyperlink{classPatternModel_a0be06240959a62b03473c7a00ccebdd1}{getnpmi} (const \hyperlink{classPattern}{Pattern} \&pattern, double threshold)
\item 
virtual int \hyperlink{classPatternModel_ab393fff93aae08db7456a9e60296a0b3}{computeflexgrams\+\_\+fromskipgrams} ()
\item 
virtual int \hyperlink{classPatternModel_abc0a0314553ad6237838b44f14e45309}{computeflexgrams\+\_\+fromcooc} ()
\item 
virtual void \hyperlink{classPatternModel_a45da84761e93772df0465bca2780b9b3}{outputcooc\+\_\+npmi} (std\+::ostream $\ast$O\+U\+T, \hyperlink{classClassDecoder}{Class\+Decoder} \&classdecoder, double threshold)
\item 
virtual void \hyperlink{classPatternModel_a107980d1345c1f20ba3284474220ee7e}{outputcooc} (std\+::ostream $\ast$O\+U\+T, \hyperlink{classClassDecoder}{Class\+Decoder} \&classdecoder, double threshold)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classIndexedCorpus}{Indexed\+Corpus} $\ast$ \hyperlink{classPatternModel_a17ad27133991f964ccd23bb09bf64e5a}{reverseindex}
\begin{DoxyCompactList}\small\item\em Pointer to the reverse index for this model (or N\+U\+L\+L) \end{DoxyCompactList}\item 
bool \hyperlink{classPatternModel_a2f1b4eec80a00ef9c6effea477cc98f4}{externalreverseindex}
\begin{DoxyCompactList}\small\item\em true if reverse index was loaded externally and passed to the model (implies it won\textquotesingle{}t be destroyed when the model is) //only used by \hyperlink{classIndexedPatternModel}{Indexed\+Pattern\+Model} but stored here to ease things for cython \end{DoxyCompactList}\item 
bool \hyperlink{classPatternModel_a9534e66035de7df26c9cd257e2faf7d1}{hasskipgrams}
\begin{DoxyCompactList}\small\item\em Does this model have skipgrams? \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classPatternModel_a3746e351f393bb6201f3b8df92881bb7}{postread} (const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options)
\item 
virtual void \hyperlink{classPatternModel_a5447228ff966dcb3c93c8c787ce31386}{posttrain} (const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options)
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
unsigned char \hyperlink{classPatternModel_af28152ff3d5060e48c18423b8629d1eb}{model\+\_\+type}
\item 
unsigned char \hyperlink{classPatternModel_a032f1517ae658e81fa2ca3360aba62a2}{model\+\_\+version}
\item 
uint64\+\_\+t \hyperlink{classPatternModel_a4667c917fab96ae756ee61693220f44e}{totaltokens}
\begin{DoxyCompactList}\small\item\em Total number of tokens in the original corpus, so I\+N\+C\+L\+U\+D\+E\+S T\+O\+K\+E\+N\+S N\+O\+T C\+O\+V\+E\+R\+E\+D B\+Y T\+H\+E M\+O\+D\+E\+L! \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{classPatternModel_af9de224847465b75a9be436b1990cef7}{totaltypes}
\begin{DoxyCompactList}\small\item\em Total number of unigram/word types in the original corpus, S\+O I\+N\+C\+L\+U\+D\+I\+N\+G N\+O\+T C\+O\+V\+E\+R\+E\+D B\+Y T\+H\+E M\+O\+D\+E\+L! \end{DoxyCompactList}\item 
int \hyperlink{classPatternModel_ac0e501edfcca21facfe0137ed5140c87}{maxn}
\item 
int \hyperlink{classPatternModel_abed492e59e656226b1c48b10c2904618}{minn}
\item 
std\+::set$<$ int $>$ \hyperlink{classPatternModel_a2f9145b11bff161df5db3bcd33300319}{cache\+\_\+categories}
\item 
std\+::set$<$ int $>$ \hyperlink{classPatternModel_a18c0c93e988cce16fdeb5a8a65e878b1}{cache\+\_\+n}
\item 
std\+::map$<$ int, std\+::map$<$ int, unsigned int $>$ $>$ \hyperlink{classPatternModel_a8ef56e648dc462352079542e9528df09}{cache\+\_\+grouptotal}
\begin{DoxyCompactList}\small\item\em total occurrences (used for frequency computation, within a group) \end{DoxyCompactList}\item 
std\+::map$<$ int, std\+::map$<$ int, unsigned int $>$ $>$ \hyperlink{classPatternModel_a05db7c45b9368438f34dba519df3bb3e}{cache\+\_\+grouptotalpatterns}
\begin{DoxyCompactList}\small\item\em total distinct patterns per group \end{DoxyCompactList}\item 
std\+::map$<$ int, std\+::map$<$ int, unsigned int $>$ $>$ \hyperlink{classPatternModel_a4dee966a62bacaab4d107bb4ec5050c0}{cache\+\_\+grouptotalwordtypes}
\begin{DoxyCompactList}\small\item\em total covered word types per group \end{DoxyCompactList}\item 
std\+::map$<$ int, std\+::map$<$ int, unsigned int $>$ $>$ \hyperlink{classPatternModel_aebbf8c45dfa1993d1a9dd262b2b30783}{cache\+\_\+grouptotaltokens}
\begin{DoxyCompactList}\small\item\em total covered tokens per group \end{DoxyCompactList}\item 
std\+::map$<$ int, std\+::vector$<$ std\+::vector$<$ std\+::pair$<$ int, int $>$ $>$ $>$ $>$ \hyperlink{classPatternModel_a1070e4e96457caf4ae35d23c1e9ac5c3}{gapconf}
\begin{DoxyCompactList}\small\item\em pre-\/computed structure of possible gap configurations various pattern lengths \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$class Pattern\+Model$<$ Value\+Type, Value\+Handler, Map\+Type $>$}

A model mapping patterns to values, gigh-\/level interface. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Value\+Type} & The type of Value this model stores \\
\hline
{\em Value\+Handler} & A handler class for this type of value \\
\hline
{\em Map\+Type} & The type of container to use \\
\hline
\end{DoxyTemplParams}


\subsection{Member Typedef Documentation}
\hypertarget{classPatternModel_aecfc44c56122e8037bb634a3d66bac0a}{}\index{Pattern\+Model@{Pattern\+Model}!const\+\_\+iterator@{const\+\_\+iterator}}
\index{const\+\_\+iterator@{const\+\_\+iterator}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{const\+\_\+iterator}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ typedef Map\+Type\+::const\+\_\+iterator {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::{\bf const\+\_\+iterator}}\label{classPatternModel_aecfc44c56122e8037bb634a3d66bac0a}
\hypertarget{classPatternModel_a8aedb15ca2b6f5e3d619c1878d5c0639}{}\index{Pattern\+Model@{Pattern\+Model}!iterator@{iterator}}
\index{iterator@{iterator}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{iterator}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ typedef Map\+Type\+::iterator {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::{\bf iterator}}\label{classPatternModel_a8aedb15ca2b6f5e3d619c1878d5c0639}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classPatternModel_ade6d8f3c3bae062c06881d96809ea4ff}{}\index{Pattern\+Model@{Pattern\+Model}!Pattern\+Model@{Pattern\+Model}}
\index{Pattern\+Model@{Pattern\+Model}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{Pattern\+Model(\+Indexed\+Corpus $\ast$corpus=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::{\bf Pattern\+Model} (
\begin{DoxyParamCaption}
\item[{{\bf Indexed\+Corpus} $\ast$}]{corpus = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_ade6d8f3c3bae062c06881d96809ea4ff}
Begin a new pattern model, optionally pre-\/setting a reverseindex. \hypertarget{classPatternModel_a9f1e66e0893ead99e75013cb578cd54a}{}\index{Pattern\+Model@{Pattern\+Model}!Pattern\+Model@{Pattern\+Model}}
\index{Pattern\+Model@{Pattern\+Model}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{Pattern\+Model(std\+::istream $\ast$f, Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainmodel=\+N\+U\+L\+L, Indexed\+Corpus $\ast$corpus=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::{\bf Pattern\+Model} (
\begin{DoxyParamCaption}
\item[{std\+::istream $\ast$}]{f, }
\item[{{\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainmodel = {\ttfamily NULL}, }
\item[{{\bf Indexed\+Corpus} $\ast$}]{corpus = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a9f1e66e0893ead99e75013cb578cd54a}
Read a pattern model from an input stream 
\begin{DoxyParams}{Parameters}
{\em f} & The input stream \\
\hline
{\em options} & Options for reading, these act as filter for the data, allowing you to raise thresholds etc \\
\hline
{\em constrainmodel} & Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
{\em corpus} & Pointer to the loaded corpus, used as a reverse index. \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_afd68d5b590a3b477f7fdee2921755a44}{}\index{Pattern\+Model@{Pattern\+Model}!Pattern\+Model@{Pattern\+Model}}
\index{Pattern\+Model@{Pattern\+Model}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{Pattern\+Model(const std\+::string filename, const Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainmodel=\+N\+U\+L\+L, Indexed\+Corpus $\ast$corpus=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::{\bf Pattern\+Model} (
\begin{DoxyParamCaption}
\item[{const std\+::string}]{filename, }
\item[{const {\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainmodel = {\ttfamily NULL}, }
\item[{{\bf Indexed\+Corpus} $\ast$}]{corpus = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_afd68d5b590a3b477f7fdee2921755a44}
Read a pattern model from file 
\begin{DoxyParams}{Parameters}
{\em filename} & The input filename \\
\hline
{\em options} & Options for reading, these act as filter for the data, allowing you to raise thresholds etc \\
\hline
{\em constrainmodel} & Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
{\em corpus} & Pointer to the loaded corpus, used as a reverse index. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\hypertarget{classPatternModel_a0cdb8badafbce0f56089f7c2b8f4716a}{}\index{Pattern\+Model@{Pattern\+Model}!add@{add}}
\index{add@{add}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{add(const Pattern \&pattern, Value\+Type $\ast$value, const Index\+Reference \&ref)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::add (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{Value\+Type $\ast$}]{value, }
\item[{const {\bf Index\+Reference} \&}]{ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a0cdb8badafbce0f56089f7c2b8f4716a}
Add a pattern, with a given position, and a value to the model. This is called during training at every time an instance of a pattern is found in the data. 
\begin{DoxyParams}{Parameters}
{\em pattern} & The pattern to add \\
\hline
{\em value} & A pointer to the value for this pattern, what kind of value depends on the Value\+Type template parameter. \\
\hline
{\em ref} & The position in the corpus where the patterns occurs \\
\hline
\end{DoxyParams}


Reimplemented in \hyperlink{classIndexedPatternModel_a41367fc32c9fa72d1a88e60d749015a5}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_ad16097db7894d75815cd40ef5acc99a5}{}\index{Pattern\+Model@{Pattern\+Model}!add@{add}}
\index{add@{add}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{add(const Pattern\+Pointer \&pattern, Value\+Type $\ast$value, const Index\+Reference \&ref)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::add (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{Value\+Type $\ast$}]{value, }
\item[{const {\bf Index\+Reference} \&}]{ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ad16097db7894d75815cd40ef5acc99a5}


Reimplemented in \hyperlink{classIndexedPatternModel_a83e3a00515a9ad419b4a2f820278c5f7}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_ae36bb1e641f954ee78a5fbab98ae069a}{}\index{Pattern\+Model@{Pattern\+Model}!computecoveragestats@{computecoveragestats}}
\index{computecoveragestats@{computecoveragestats}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{computecoveragestats()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::computecoveragestats (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ae36bb1e641f954ee78a5fbab98ae069a}
Compute coverage statistics on the model, will generally be called automatically by methods who use it, and the statistics are cached after computation. 

Reimplemented in \hyperlink{classIndexedPatternModel_acf70c3536f4869b3e8330289f7409bf5}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_abc0a0314553ad6237838b44f14e45309}{}\index{Pattern\+Model@{Pattern\+Model}!computeflexgrams\+\_\+fromcooc@{computeflexgrams\+\_\+fromcooc}}
\index{computeflexgrams\+\_\+fromcooc@{computeflexgrams\+\_\+fromcooc}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{computeflexgrams\+\_\+fromcooc()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::computeflexgrams\+\_\+fromcooc (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_abc0a0314553ad6237838b44f14e45309}
\hypertarget{classPatternModel_ab393fff93aae08db7456a9e60296a0b3}{}\index{Pattern\+Model@{Pattern\+Model}!computeflexgrams\+\_\+fromskipgrams@{computeflexgrams\+\_\+fromskipgrams}}
\index{computeflexgrams\+\_\+fromskipgrams@{computeflexgrams\+\_\+fromskipgrams}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{computeflexgrams\+\_\+fromskipgrams()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::computeflexgrams\+\_\+fromskipgrams (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ab393fff93aae08db7456a9e60296a0b3}


Reimplemented in \hyperlink{classIndexedPatternModel_ad3b8e1405429aa869501f9117664b0d5}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_aa8a7898c399c670792af12f509adcd28}{}\index{Pattern\+Model@{Pattern\+Model}!computeskipgrams@{computeskipgrams}}
\index{computeskipgrams@{computeskipgrams}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{computeskipgrams(const Pattern \&pattern, int mintokens=2, const Index\+Reference $\ast$singleref=\+N\+U\+L\+L, const Indexed\+Data $\ast$multiplerefs=\+N\+U\+L\+L, Pattern\+Model\+Interface $\ast$constrainbymodel=\+N\+U\+L\+L, std\+::vector$<$ Pattern $>$ $\ast$targetcontainer=\+N\+U\+L\+L, const bool exhaustive=false, const bool D\+E\+B\+U\+G=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::computeskipgrams (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{int}]{mintokens = {\ttfamily 2}, }
\item[{const {\bf Index\+Reference} $\ast$}]{singleref = {\ttfamily NULL}, }
\item[{const {\bf Indexed\+Data} $\ast$}]{multiplerefs = {\ttfamily NULL}, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainbymodel = {\ttfamily NULL}, }
\item[{std\+::vector$<$ {\bf Pattern} $>$ $\ast$}]{targetcontainer = {\ttfamily NULL}, }
\item[{const bool}]{exhaustive = {\ttfamily false}, }
\item[{const bool}]{D\+E\+B\+U\+G = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_aa8a7898c399c670792af12f509adcd28}
Low-\/level function to compute skipgrams for a given pattern . See higher-\/level function instead \hypertarget{classPatternModel_a00b3338b6e79a3dbc9b5f95cb0171494}{}\index{Pattern\+Model@{Pattern\+Model}!computeskipgrams@{computeskipgrams}}
\index{computeskipgrams@{computeskipgrams}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{computeskipgrams(const Pattern \&pattern, Pattern\+Model\+Options \&options, const Index\+Reference $\ast$singleref=\+N\+U\+L\+L, const Indexed\+Data $\ast$multiplerefs=\+N\+U\+L\+L, Pattern\+Model\+Interface $\ast$constrainbymodel=\+N\+U\+L\+L, const bool exhaustive=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::computeskipgrams (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{{\bf Pattern\+Model\+Options} \&}]{options, }
\item[{const {\bf Index\+Reference} $\ast$}]{singleref = {\ttfamily NULL}, }
\item[{const {\bf Indexed\+Data} $\ast$}]{multiplerefs = {\ttfamily NULL}, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainbymodel = {\ttfamily NULL}, }
\item[{const bool}]{exhaustive = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a00b3338b6e79a3dbc9b5f95cb0171494}
Low-\/level function to compute skipgrams for a given pattern. See \hyperlink{classPatternModel_acd4e0ecc0e796c894b994859b2c5ffb6}{trainskipgrams()} instead. \hypertarget{classPatternModel_a06b0d7452c19849930d6b3d19888130d}{}\index{Pattern\+Model@{Pattern\+Model}!computestats@{computestats}}
\index{computestats@{computestats}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{computestats()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::computestats (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a06b0d7452c19849930d6b3d19888130d}
Compute statistics on the model, will generally be called automatically by methods who use it, and the statistics are cached after computation. \hypertarget{classPatternModel_a07eb601afe937b144e100cd96d091d3a}{}\index{Pattern\+Model@{Pattern\+Model}!coverage@{coverage}}
\index{coverage@{coverage}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{coverage(const Pattern \&key)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ double {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::coverage (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{key}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a07eb601afe937b144e100cd96d091d3a}
Return coverage as a fraction of the total number of tokens in the model. For unindexed models this is a maximal projection rather than exact number. \hypertarget{classPatternModel_a5bad2b94ec96880f3e4307d55c42e492}{}\index{Pattern\+Model@{Pattern\+Model}!coveragecount@{coveragecount}}
\index{coveragecount@{coveragecount}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{coveragecount(const Pattern \&key)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::coveragecount (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{key}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a5bad2b94ec96880f3e4307d55c42e492}
Returns the coverage count for the given pattern, for unindexed models, the coverage count is a mere maximum projection equal to the product of the occurence count and the size. \hypertarget{classPatternModel_a8881489a5a99215499809c6dcbe704e9}{}\index{Pattern\+Model@{Pattern\+Model}!extractset@{extractset}}
\index{extractset@{extractset}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{extractset(int minlength=1, int maxlength=1)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ {\bf Pattern\+Set}$<$uint64\+\_\+t$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::extractset (
\begin{DoxyParamCaption}
\item[{int}]{minlength = {\ttfamily 1}, }
\item[{int}]{maxlength = {\ttfamily 1}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a8881489a5a99215499809c6dcbe704e9}
Returns a \hyperlink{classPatternSet}{Pattern\+Set} containing patterns of the specified length. Patterns are actively reconstructed from patterns in the model, if necessary. So this includes patterns that are not in the model explicitly (i.\+e, smaller patterns that have been pruned. \hypertarget{classPatternModel_aa4aa18a4d9e7554a3c798872e915e8a0}{}\index{Pattern\+Model@{Pattern\+Model}!findskipgrams@{findskipgrams}}
\index{findskipgrams@{findskipgrams}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{findskipgrams(const Pattern \&pattern, unsigned int occurrencethreshold=1)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual std\+::vector$<${\bf Pattern}$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::findskipgrams (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{unsigned int}]{occurrencethreshold = {\ttfamily 1}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_aa4aa18a4d9e7554a3c798872e915e8a0}
Returns a vector of all skipgrams that can be extracted from the tigven pattern \hypertarget{classPatternModel_a0927686caf05d2e1accff6e158a75188}{}\index{Pattern\+Model@{Pattern\+Model}!frequency@{frequency}}
\index{frequency@{frequency}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{frequency(const Pattern \&pattern)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ double {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::frequency (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a0927686caf05d2e1accff6e158a75188}
Returns the frequency of a pattern within its own group (category and size). For instance, if you pass a bigram you will get the occurence count as a fraction of the total occurrences of bigrams. 

Implements \hyperlink{classPatternModelInterface_abab22952ac502743377e3a5a524e2ae1}{Pattern\+Model\+Interface}.

\hypertarget{classPatternModel_aaec0fa3d026d88bc5b8e2dc5f0994015}{}\index{Pattern\+Model@{Pattern\+Model}!getdata@{getdata}}
\index{getdata@{getdata}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getdata(const Pattern \&pattern, bool makeifnew=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual Value\+Type$\ast$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getdata (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{bool}]{makeifnew = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_aaec0fa3d026d88bc5b8e2dc5f0994015}
Get the value stored for the specified pattern. 
\begin{DoxyParams}{Parameters}
{\em makeifnew} & Add the pattern with empty value if it does not exist (default\+: false) \\
\hline
\end{DoxyParams}


Reimplemented in \hyperlink{classIndexedPatternModel_a1ee41056c7235bf03573e6532cd5efce}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_a1baf331b3a10a45fdadd6a835a744cf3}{}\index{Pattern\+Model@{Pattern\+Model}!getdata@{getdata}}
\index{getdata@{getdata}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getdata(const Pattern\+Pointer \&patternpointer, bool makeifnew=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual Value\+Type$\ast$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getdata (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{patternpointer, }
\item[{bool}]{makeifnew = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a1baf331b3a10a45fdadd6a835a744cf3}


Reimplemented in \hyperlink{classIndexedPatternModel_a9311529a1123f602720b9e95f3f89236}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_a564b582aba0eedacd4b0b6f2fa693f7d}{}\index{Pattern\+Model@{Pattern\+Model}!getinstances@{getinstances}}
\index{getinstances@{getinstances}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getinstances(const Pattern \&pattern, int=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual {\bf t\+\_\+relationmap} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getinstances (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{int}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a564b582aba0eedacd4b0b6f2fa693f7d}
\hypertarget{classPatternModel_a837bdbf478b7ea8a51ad674418926175}{}\index{Pattern\+Model@{Pattern\+Model}!getinterface@{getinterface}}
\index{getinterface@{getinterface}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getinterface()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ {\bf Pattern\+Model\+Interface}$\ast$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getinterface (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a837bdbf478b7ea8a51ad674418926175}
Returns a more generic but limited \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} instance (polymorphism) \hypertarget{classPatternModel_aea7593acd2798e2e77ed5cb4e75d3f67}{}\index{Pattern\+Model@{Pattern\+Model}!getleftneighbours@{getleftneighbours}}
\index{getleftneighbours@{getleftneighbours}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getleftneighbours(const Pattern \&pattern, int=0, int=0, int=0, int=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual {\bf t\+\_\+relationmap} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getleftneighbours (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_aea7593acd2798e2e77ed5cb4e75d3f67}
\hypertarget{classPatternModel_aadea1e70400eb2aeced1ca1648cf9cd9}{}\index{Pattern\+Model@{Pattern\+Model}!getmodeltype@{getmodeltype}}
\index{getmodeltype@{getmodeltype}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getmodeltype() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getmodeltype (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_aadea1e70400eb2aeced1ca1648cf9cd9}
Returns the type of model (a value from Model\+Type) 

Implements \hyperlink{classPatternModelInterface_ad485931462c2f1c1bcd0aac13ec3028b}{Pattern\+Model\+Interface}.



Reimplemented in \hyperlink{classIndexedPatternModel_adeb6b2bce5dc4fcdd9f8ec9f723d0f5b}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_ac2f98f98d449951caa82894be78e9fe6}{}\index{Pattern\+Model@{Pattern\+Model}!getmodelversion@{getmodelversion}}
\index{getmodelversion@{getmodelversion}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getmodelversion() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getmodelversion (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ac2f98f98d449951caa82894be78e9fe6}
Returns the version of the model implementation and binary serialisation format 

Implements \hyperlink{classPatternModelInterface_a0d58b42e55df75e04faae361677aa777}{Pattern\+Model\+Interface}.



Reimplemented in \hyperlink{classIndexedPatternModel_adabaad88e64edd1c4762a56c86d1bae4}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_a0be06240959a62b03473c7a00ccebdd1}{}\index{Pattern\+Model@{Pattern\+Model}!getnpmi@{getnpmi}}
\index{getnpmi@{getnpmi}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getnpmi(const Pattern \&pattern, double threshold)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual {\bf t\+\_\+relationmap\+\_\+double} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getnpmi (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{double}]{threshold}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a0be06240959a62b03473c7a00ccebdd1}
\hypertarget{classPatternModel_ad5d110daa1691b266ad325b1a2f7a842}{}\index{Pattern\+Model@{Pattern\+Model}!getpatterns@{getpatterns}}
\index{getpatterns@{getpatterns}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getpatterns(const Pattern \&pattern)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ std\+::vector$<$std\+::pair$<${\bf Pattern}, int$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getpatterns (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_ad5d110daa1691b266ad325b1a2f7a842}
get all patterns in pattern that occur in the patternmodel as a vector of pairs of Patterns and occurrence count. \hypertarget{classPatternModel_a6b37ea19d0646bff54cae15290fc884c}{}\index{Pattern\+Model@{Pattern\+Model}!getreverseindex@{getreverseindex}}
\index{getreverseindex@{getreverseindex}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getreverseindex(const Index\+Reference ref, int occurrencecount=0, int category=0, unsigned int size=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ std\+::vector$<${\bf Pattern}$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getreverseindex (
\begin{DoxyParamCaption}
\item[{const {\bf Index\+Reference}}]{ref, }
\item[{int}]{occurrencecount = {\ttfamily 0}, }
\item[{int}]{category = {\ttfamily 0}, }
\item[{unsigned int}]{size = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a6b37ea19d0646bff54cae15290fc884c}
Given a position in the corpus , return a vector of all the patterns that cover this position. 
\begin{DoxyParams}{Parameters}
{\em ref} & The position in the corpus \\
\hline
{\em occurrencecount} & If set above zero, filters to only include patterns occurring above this threshold \\
\hline
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) to include only this category. Set to 0 for unfiltered (default) \\
\hline
{\em size} & Set to any value above zero to only include patterns of the specified length. \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_abca7b37dfacef90de4e2139acb99cedb}{}\index{Pattern\+Model@{Pattern\+Model}!getreverseindex\+\_\+bysentence@{getreverseindex\+\_\+bysentence}}
\index{getreverseindex\+\_\+bysentence@{getreverseindex\+\_\+bysentence}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getreverseindex\+\_\+bysentence(int sentence)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ std\+::vector$<$std\+::pair$<${\bf Index\+Reference},{\bf Pattern}$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getreverseindex\+\_\+bysentence (
\begin{DoxyParamCaption}
\item[{int}]{sentence}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_abca7b37dfacef90de4e2139acb99cedb}
Returns pairs of positions and patterns, consisting of all patterns found in the specified sentence (or whatever unit delimites your corpus) 
\begin{DoxyParams}{Parameters}
{\em sentence} & The sentence index (starts at 1) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_aec29a383939fa71f61edfea80ea1b2d0}{}\index{Pattern\+Model@{Pattern\+Model}!getreverseindex\+\_\+left@{getreverseindex\+\_\+left}}
\index{getreverseindex\+\_\+left@{getreverseindex\+\_\+left}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getreverseindex\+\_\+left(const Index\+Reference ref)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ std\+::vector$<$std\+::pair$<${\bf Index\+Reference},{\bf Pattern}$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getreverseindex\+\_\+left (
\begin{DoxyParamCaption}
\item[{const {\bf Index\+Reference}}]{ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_aec29a383939fa71f61edfea80ea1b2d0}
Given a position in the corpus , return a vector of all the positions and patterns (as pairs) that occur to the left of this position 
\begin{DoxyParams}{Parameters}
{\em ref} & The position in the corpus \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a0c49738d4296c9dde3ee2796d6b66814}{}\index{Pattern\+Model@{Pattern\+Model}!getreverseindex\+\_\+right@{getreverseindex\+\_\+right}}
\index{getreverseindex\+\_\+right@{getreverseindex\+\_\+right}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getreverseindex\+\_\+right(const Index\+Reference ref)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ std\+::vector$<$std\+::pair$<${\bf Index\+Reference},{\bf Pattern}$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getreverseindex\+\_\+right (
\begin{DoxyParamCaption}
\item[{const {\bf Index\+Reference}}]{ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a0c49738d4296c9dde3ee2796d6b66814}
Given a position in the corpus , return a vector of all the positions and patterns (as pairs) that occur to the right of this position 
\begin{DoxyParams}{Parameters}
{\em ref} & The position in the corpus \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_ad34484b6262acb5967de624a14e73085}{}\index{Pattern\+Model@{Pattern\+Model}!getrightneighbours@{getrightneighbours}}
\index{getrightneighbours@{getrightneighbours}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getrightneighbours(const Pattern \&pattern, int=0, int=0, int=0, int=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual {\bf t\+\_\+relationmap} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getrightneighbours (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ad34484b6262acb5967de624a14e73085}
\hypertarget{classPatternModel_aa9d5de68d7989ba234d2628ab4af35fb}{}\index{Pattern\+Model@{Pattern\+Model}!getskipcontent@{getskipcontent}}
\index{getskipcontent@{getskipcontent}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getskipcontent(const Pattern \&pattern)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual {\bf t\+\_\+relationmap} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getskipcontent (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_aa9d5de68d7989ba234d2628ab4af35fb}


Reimplemented in \hyperlink{classIndexedPatternModel_ac2478fc9fd1eabfc616c1692fc2a58d9}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_a3b0fa1ea8423db319dfd6f338f7b2b40}{}\index{Pattern\+Model@{Pattern\+Model}!getsubchildren@{getsubchildren}}
\index{getsubchildren@{getsubchildren}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getsubchildren(const Pattern \&pattern, int=0, int=0, int=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual {\bf t\+\_\+relationmap} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getsubchildren (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a3b0fa1ea8423db319dfd6f338f7b2b40}
\hypertarget{classPatternModel_a5fb7d6ef4e82a300557f2e0350209a6f}{}\index{Pattern\+Model@{Pattern\+Model}!getsubparents@{getsubparents}}
\index{getsubparents@{getsubparents}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{getsubparents(const Pattern \&pattern, int=0, int=0, int=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual {\bf t\+\_\+relationmap} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::getsubparents (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}, }
\item[{int}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a5fb7d6ef4e82a300557f2e0350209a6f}
\hypertarget{classPatternModel_a997f4cfc3e65fb218097061f9d4429ca}{}\index{Pattern\+Model@{Pattern\+Model}!gettemplates@{gettemplates}}
\index{gettemplates@{gettemplates}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{gettemplates(const Pattern \&pattern, int=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual {\bf t\+\_\+relationmap} {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::gettemplates (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{int}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a997f4cfc3e65fb218097061f9d4429ca}
\hypertarget{classPatternModel_a577eb056f583b4efc943ac4e7a581b1b}{}\index{Pattern\+Model@{Pattern\+Model}!has@{has}}
\index{has@{has}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{has(const Pattern \&pattern) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual bool {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::has (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a577eb056f583b4efc943ac4e7a581b1b}
Checks whether the given pattern occurs in the model 

Implements \hyperlink{classPatternStoreInterface_aec9f27496b38f8db1eced920fb2dc9fe}{Pattern\+Store\+Interface}.

\hypertarget{classPatternModel_af94a590e3c5eacde04cb55430198acfa}{}\index{Pattern\+Model@{Pattern\+Model}!has@{has}}
\index{has@{has}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{has(const Pattern\+Pointer \&pattern) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual bool {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::has (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_af94a590e3c5eacde04cb55430198acfa}
Does the pattern occur in the pattern store? 

Implements \hyperlink{classPatternStoreInterface_a6b3e80cd9021201ce8992ad6c293a354}{Pattern\+Store\+Interface}.

\hypertarget{classPatternModel_a72c97f76cca2ba56099eb1559a7b0ddd}{}\index{Pattern\+Model@{Pattern\+Model}!histogram@{histogram}}
\index{histogram@{histogram}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{histogram(std\+::map$<$ unsigned int, unsigned int $>$ \&hist, unsigned int threshold=0, unsigned int cap=0, int category=0, unsigned int size=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::histogram (
\begin{DoxyParamCaption}
\item[{std\+::map$<$ unsigned int, unsigned int $>$ \&}]{hist, }
\item[{unsigned int}]{threshold = {\ttfamily 0}, }
\item[{unsigned int}]{cap = {\ttfamily 0}, }
\item[{int}]{category = {\ttfamily 0}, }
\item[{unsigned int}]{size = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a72c97f76cca2ba56099eb1559a7b0ddd}
Generate a histogram for the occurrence count of patterns 
\begin{DoxyParams}{Parameters}
{\em hist} & This will contain the to-\/be-\/computed histogram \\
\hline
{\em threshold} & Include only patterns at or above this occurrence threshold \\
\hline
{\em cap} & Include only this many of the top frequencies (0=unconstrained) \\
\hline
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) to filter or to 0 to cover all \\
\hline
{\em size} & Set to any value above zero to only include only patterns of the specified length. (0 for all sizes) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a9edf12738542d8d8b0cc9aa06b5a69b2}{}\index{Pattern\+Model@{Pattern\+Model}!histogram@{histogram}}
\index{histogram@{histogram}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{histogram(std\+::ostream $\ast$\+O\+U\+T, unsigned int threshold=0, unsigned int cap=0, int category=0, unsigned int size=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::histogram (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{O\+U\+T, }
\item[{unsigned int}]{threshold = {\ttfamily 0}, }
\item[{unsigned int}]{cap = {\ttfamily 0}, }
\item[{int}]{category = {\ttfamily 0}, }
\item[{unsigned int}]{size = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a9edf12738542d8d8b0cc9aa06b5a69b2}
Generate a histogram for the occurrence count of patterns and output it to the output stream. 
\begin{DoxyParams}{Parameters}
{\em O\+U\+T} & the output stream \\
\hline
{\em threshold} & Include only patterns at or above this occurrence threshold \\
\hline
{\em cap} & Include only this many of the top frequencies (0=unconstrained) \\
\hline
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) to filter or to 0 to cover all \\
\hline
{\em size} & Set to any value above zero to only include only patterns of the specified length. (0 for all sizes) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a231e5e4c9ed49764b24718e4269b4256}{}\index{Pattern\+Model@{Pattern\+Model}!info@{info}}
\index{info@{info}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{info(std\+::ostream $\ast$\+O\+U\+T)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::info (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{O\+U\+T}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a231e5e4c9ed49764b24718e4269b4256}
Output information about the model to the output stream, includes some statistics and technical details such as space requirements. \hypertarget{classPatternModel_a26de418f6998cac0f484a958597afccc}{}\index{Pattern\+Model@{Pattern\+Model}!load@{load}}
\index{load@{load}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{load(std\+::string filename, const Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainmodel=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::load (
\begin{DoxyParamCaption}
\item[{std\+::string}]{filename, }
\item[{const {\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainmodel = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a26de418f6998cac0f484a958597afccc}
Read a pattern model from file 
\begin{DoxyParams}{Parameters}
{\em filename} & The input filename \\
\hline
{\em options} & Options for reading, these act as filter for the data, allowing you to raise thresholds etc \\
\hline
{\em constrainmodel} & Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_acbfb81964c7a6eb13d846dc11d2cc667}{}\index{Pattern\+Model@{Pattern\+Model}!load@{load}}
\index{load@{load}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{load(std\+::istream $\ast$f, const Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainmodel=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::load (
\begin{DoxyParamCaption}
\item[{std\+::istream $\ast$}]{f, }
\item[{const {\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainmodel = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_acbfb81964c7a6eb13d846dc11d2cc667}
Read a pattern model from an input stream 
\begin{DoxyParams}{Parameters}
{\em f} & The input stream \\
\hline
{\em options} & Options for reading, these act as filter for the data, allowing you to raise thresholds etc \\
\hline
{\em constrainmodel} & Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_ac0d63c6c6ada696e3a247e25df8487ec}{}\index{Pattern\+Model@{Pattern\+Model}!maxlength@{maxlength}}
\index{maxlength@{maxlength}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{maxlength() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::maxlength (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ac0d63c6c6ada696e3a247e25df8487ec}
Returns the maximum length of patterns in this model 

Implements \hyperlink{classPatternModelInterface_acbe234679e86792765d3afade8ce014c}{Pattern\+Model\+Interface}.

\hypertarget{classPatternModel_a4777ec9b1e76ef3c2ccbc981dad15129}{}\index{Pattern\+Model@{Pattern\+Model}!minlength@{minlength}}
\index{minlength@{minlength}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{minlength() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::minlength (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a4777ec9b1e76ef3c2ccbc981dad15129}
Returns the minimum length of patterns in this model 

Implements \hyperlink{classPatternModelInterface_a53325f7b36c9cf0de4954b618eff2416}{Pattern\+Model\+Interface}.

\hypertarget{classPatternModel_a8f5bc659abbbdd456937e85642a97d40}{}\index{Pattern\+Model@{Pattern\+Model}!occurrencecount@{occurrencecount}}
\index{occurrencecount@{occurrencecount}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{occurrencecount(const Pattern \&pattern)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::occurrencecount (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a8f5bc659abbbdd456937e85642a97d40}
Returns the occurrenc count of the specified pattern, will return 0 if it does not exist in the model 

Implements \hyperlink{classPatternModelInterface_afd9ec4756bb723ee6bf94321f05f1b71}{Pattern\+Model\+Interface}.

\hypertarget{classPatternModel_aafa8d87b4b2269e796d97902f3214d22}{}\index{Pattern\+Model@{Pattern\+Model}!output@{output}}
\index{output@{output}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{output(std\+::ostream $\ast$)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::output (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{}
\end{DoxyParamCaption}
)}\label{classPatternModel_aafa8d87b4b2269e796d97902f3214d22}
\hypertarget{classPatternModel_a107980d1345c1f20ba3284474220ee7e}{}\index{Pattern\+Model@{Pattern\+Model}!outputcooc@{outputcooc}}
\index{outputcooc@{outputcooc}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{outputcooc(std\+::ostream $\ast$\+O\+U\+T, Class\+Decoder \&classdecoder, double threshold)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::outputcooc (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{O\+U\+T, }
\item[{{\bf Class\+Decoder} \&}]{classdecoder, }
\item[{double}]{threshold}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a107980d1345c1f20ba3284474220ee7e}


Reimplemented in \hyperlink{classIndexedPatternModel_a6ab1e2d6bf0a8aeed25a39c306e51c34}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_a45da84761e93772df0465bca2780b9b3}{}\index{Pattern\+Model@{Pattern\+Model}!outputcooc\+\_\+npmi@{outputcooc\+\_\+npmi}}
\index{outputcooc\+\_\+npmi@{outputcooc\+\_\+npmi}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{outputcooc\+\_\+npmi(std\+::ostream $\ast$\+O\+U\+T, Class\+Decoder \&classdecoder, double threshold)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::outputcooc\+\_\+npmi (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{O\+U\+T, }
\item[{{\bf Class\+Decoder} \&}]{classdecoder, }
\item[{double}]{threshold}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a45da84761e93772df0465bca2780b9b3}


Reimplemented in \hyperlink{classIndexedPatternModel_a4e8d1bf4017173e8214cfd37bab576c1}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_aa350e235140e580526d381c626355b58}{}\index{Pattern\+Model@{Pattern\+Model}!outputrelations@{outputrelations}}
\index{outputrelations@{outputrelations}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{outputrelations(const Pattern \&pattern, Class\+Decoder \&classdecoder, std\+::ostream $\ast$\+O\+U\+T)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::outputrelations (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{{\bf Class\+Decoder} \&}]{classdecoder, }
\item[{std\+::ostream $\ast$}]{O\+U\+T}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_aa350e235140e580526d381c626355b58}
\hypertarget{classPatternModel_a3746e351f393bb6201f3b8df92881bb7}{}\index{Pattern\+Model@{Pattern\+Model}!postread@{postread}}
\index{postread@{postread}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{postread(const Pattern\+Model\+Options options)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::postread (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Model\+Options}}]{options}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classPatternModel_a3746e351f393bb6201f3b8df92881bb7}


Reimplemented in \hyperlink{classIndexedPatternModel_a82f5f4fffea239a4f5bde4d346691f5d}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_a5447228ff966dcb3c93c8c787ce31386}{}\index{Pattern\+Model@{Pattern\+Model}!posttrain@{posttrain}}
\index{posttrain@{posttrain}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{posttrain(const Pattern\+Model\+Options options)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::posttrain (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Model\+Options}}]{options}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classPatternModel_a5447228ff966dcb3c93c8c787ce31386}


Reimplemented in \hyperlink{classIndexedPatternModel_a4a39df881afb2ef2c6c4a29afe9aa6ff}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_a6d645bd24603696e77d6904c09d9b39c}{}\index{Pattern\+Model@{Pattern\+Model}!print@{print}}
\index{print@{print}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{print(std\+::ostream $\ast$out, Class\+Decoder \&decoder)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::print (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{out, }
\item[{{\bf Class\+Decoder} \&}]{decoder}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a6d645bd24603696e77d6904c09d9b39c}
Print the contents of the pattern model, i.\+e. all patterns and associated counts, to the output stream. 
\begin{DoxyParams}{Parameters}
{\em out} & The output stream \\
\hline
{\em decoder} & The class decoder to use \\
\hline
\end{DoxyParams}


Reimplemented in \hyperlink{classIndexedPatternModel_a4a5f41aa99e3b93a9a816e9c21b9b790}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_a58bbe1d44c4daf8560872f97d124a836}{}\index{Pattern\+Model@{Pattern\+Model}!print@{print}}
\index{print@{print}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{print(std\+::ostream $\ast$out, Class\+Decoder \&decoder, const Pattern \&pattern, bool endline=true)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::print (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{out, }
\item[{{\bf Class\+Decoder} \&}]{decoder, }
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{bool}]{endline = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a58bbe1d44c4daf8560872f97d124a836}
Print for one pattern only. 
\begin{DoxyParams}{Parameters}
{\em out} & The output stream \\
\hline
{\em decoder} & The class decoder to use \\
\hline
\end{DoxyParams}


Reimplemented in \hyperlink{classIndexedPatternModel_aed4218c952b051b523d8d5a31c5c00fb}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_a30b0bf9471b82119000b38c620ffc21e}{}\index{Pattern\+Model@{Pattern\+Model}!printmodel@{printmodel}}
\index{printmodel@{printmodel}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{printmodel(std\+::ostream $\ast$out, Class\+Decoder \&decoder)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::printmodel (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{out, }
\item[{{\bf Class\+Decoder} \&}]{decoder}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a30b0bf9471b82119000b38c620ffc21e}
Just an alias for \hyperlink{classPatternModel_a6d645bd24603696e77d6904c09d9b39c}{print()} \hypertarget{classPatternModel_aaa497ee9bd6b1abe6ab4451fbf7272f4}{}\index{Pattern\+Model@{Pattern\+Model}!printpattern@{printpattern}}
\index{printpattern@{printpattern}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{printpattern(std\+::ostream $\ast$out, Class\+Decoder \&decoder, const Pattern \&pattern, bool endline=true)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::printpattern (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{out, }
\item[{{\bf Class\+Decoder} \&}]{decoder, }
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{bool}]{endline = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_aaa497ee9bd6b1abe6ab4451fbf7272f4}
Alias for per-\/pattern \hyperlink{classPatternModel_a6d645bd24603696e77d6904c09d9b39c}{print()} \hypertarget{classPatternModel_aa5d23339ceb528e9cb7a02640bce392c}{}\index{Pattern\+Model@{Pattern\+Model}!printreverseindex@{printreverseindex}}
\index{printreverseindex@{printreverseindex}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{printreverseindex(std\+::ostream $\ast$out, Class\+Decoder \&decoder)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::printreverseindex (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{out, }
\item[{{\bf Class\+Decoder} \&}]{decoder}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_aa5d23339ceb528e9cb7a02640bce392c}
Print the full reverse index, a mapping of indices and all patterns that occur at those positions. 
\begin{DoxyParams}{Parameters}
{\em out} & The output stream \\
\hline
{\em decoder} & The class decoder to use \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a3698c1c47789b2fb2eae65d96ed4e3ab}{}\index{Pattern\+Model@{Pattern\+Model}!prune@{prune}}
\index{prune@{prune}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{prune(int threshold, int \+\_\+n=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::prune (
\begin{DoxyParamCaption}
\item[{int}]{threshold, }
\item[{int}]{\+\_\+n = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a3698c1c47789b2fb2eae65d96ed4e3ab}
Prune all patterns under the specified occurrence threshold (or -\/1 for all). Pruning can be limited to patterns of a particular size only. 
\begin{DoxyParams}{Parameters}
{\em threshold} & The occurrence threshold (set to -\/1 to prune everything) \\
\hline
{\em \+\_\+n} & The size constraint, limit to patterns of this size only (set to 0 for no constraint, default) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of distinct patterns pruned 
\end{DoxyReturn}
\hypertarget{classPatternModel_a787ccf34c969a5e14aa2e1bdcb164ee7}{}\index{Pattern\+Model@{Pattern\+Model}!prunebymodel@{prunebymodel}}
\index{prunebymodel@{prunebymodel}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{prunebymodel(\+Pattern\+Model$<$ Value\+Type2, Value\+Handler2, Map\+Type2 $>$ \&secondmodel)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ template$<$class Value\+Type2 , class Value\+Handler2 , class Map\+Type2 $>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::prunebymodel (
\begin{DoxyParamCaption}
\item[{{\bf Pattern\+Model}$<$ Value\+Type2, Value\+Handler2, Map\+Type2 $>$ \&}]{secondmodel}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a787ccf34c969a5e14aa2e1bdcb164ee7}
Prune all patterns that are not in the second model \begin{DoxyReturn}{Returns}
the number of distinct patterns pruned 
\end{DoxyReturn}
\hypertarget{classPatternModel_ab4429ca9cb19f12e4b0bb7b8cb0e6fe7}{}\index{Pattern\+Model@{Pattern\+Model}!prunenotinset@{prunenotinset}}
\index{prunenotinset@{prunenotinset}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{prunenotinset(const std\+::unordered\+\_\+set$<$ Pattern $>$ \&s, int \+\_\+n)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::prunenotinset (
\begin{DoxyParamCaption}
\item[{const std\+::unordered\+\_\+set$<$ {\bf Pattern} $>$ \&}]{s, }
\item[{int}]{\+\_\+n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_ab4429ca9cb19f12e4b0bb7b8cb0e6fe7}
Prune all patterns that are not in the specified set. 
\begin{DoxyParams}{Parameters}
{\em s} & The set containing the patterns not to prune \\
\hline
{\em \+\_\+n} & The size constraint, limit to patterns of this size only (set to 0 for no constraint, default) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of distinct patterns pruned 
\end{DoxyReturn}
\hypertarget{classPatternModel_a30da80bd942ab1bac95ac9945f465702}{}\index{Pattern\+Model@{Pattern\+Model}!pruneskipgrams@{pruneskipgrams}}
\index{pruneskipgrams@{pruneskipgrams}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{pruneskipgrams(unsigned int threshold, int minskiptypes=2, int \+\_\+n=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::pruneskipgrams (
\begin{DoxyParamCaption}
\item[{unsigned int}]{threshold, }
\item[{int}]{minskiptypes = {\ttfamily 2}, }
\item[{int}]{\+\_\+n = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a30da80bd942ab1bac95ac9945f465702}
Prune all skipgrams under the specified occurrence threshold (or -\/1 for all). Pruning can be limited to patterns of a particular size only. 
\begin{DoxyParams}{Parameters}
{\em threshold} & The occurrence threshold (set to -\/1 to prune everything) \\
\hline
{\em \+\_\+n} & The size constraint, limit to patterns of this size only (set to 0 for no constraint, default) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of distinct patterns pruned 
\end{DoxyReturn}
\hypertarget{classPatternModel_aee8c647241c7ec1a80e088b13e232a06}{}\index{Pattern\+Model@{Pattern\+Model}!report@{report}}
\index{report@{report}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{report(std\+::ostream $\ast$\+O\+U\+T)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::report (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{O\+U\+T}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_aee8c647241c7ec1a80e088b13e232a06}
Output an elaborate statistical report to the output stream. Computes on first call when necessary. \hypertarget{classPatternModel_a25f387acaf981af9962195bd05b3e7e2}{}\index{Pattern\+Model@{Pattern\+Model}!size@{size}}
\index{size@{size}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{size() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual size\+\_\+t {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_a25f387acaf981af9962195bd05b3e7e2}
Returns the number of distinct patterns in the model 

Implements \hyperlink{classPatternStoreInterface_a225c319d318aad157512cd0001b05eb2}{Pattern\+Store\+Interface}.

\hypertarget{classPatternModel_a21fb390761ae0fc47e3a48621c94698b}{}\index{Pattern\+Model@{Pattern\+Model}!test@{test}}
\index{test@{test}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{test(\+Map\+Type \&target, std\+::istream $\ast$in)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::test (
\begin{DoxyParamCaption}
\item[{Map\+Type \&}]{target, }
\item[{std\+::istream $\ast$}]{in}
\end{DoxyParamCaption}
)}\label{classPatternModel_a21fb390761ae0fc47e3a48621c94698b}
\hypertarget{classPatternModel_afac99feddfa4cf1dc44090c5148e518a}{}\index{Pattern\+Model@{Pattern\+Model}!tokens@{tokens}}
\index{tokens@{tokens}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{tokens() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::tokens (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_afac99feddfa4cf1dc44090c5148e518a}
Return the total amount of word/unigram tokens in the model 

Implements \hyperlink{classPatternModelInterface_aafea9a0f8fd453b85cffd18709a42ae7}{Pattern\+Model\+Interface}.

\hypertarget{classPatternModel_a1e4c12ee56b5ae88f4a5b140ac6a6a0a}{}\index{Pattern\+Model@{Pattern\+Model}!topthreshold@{topthreshold}}
\index{topthreshold@{topthreshold}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{topthreshold(int amount, int category=0, int size=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::topthreshold (
\begin{DoxyParamCaption}
\item[{int}]{amount, }
\item[{int}]{category = {\ttfamily 0}, }
\item[{int}]{size = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a1e4c12ee56b5ae88f4a5b140ac6a6a0a}
\hypertarget{classPatternModel_a4ad5fd4ad8ed72160938ca9a30d26201}{}\index{Pattern\+Model@{Pattern\+Model}!totaloccurrencesingroup@{totaloccurrencesingroup}}
\index{totaloccurrencesingroup@{totaloccurrencesingroup}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{totaloccurrencesingroup(int category, int n)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::totaloccurrencesingroup (
\begin{DoxyParamCaption}
\item[{int}]{category, }
\item[{int}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a4ad5fd4ad8ed72160938ca9a30d26201}
Obtains statistics of the model\+: returns the total amount of occurrences within the specified group, the group consist of a category and a size. 
\begin{DoxyParams}{Parameters}
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) or to 0 to cover all \\
\hline
{\em n} & Set to any value above zero to only cover only patterns of the specified length. (0 for all sizes) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a38fd6f8f536a802d6653665aa4d48cbf}{}\index{Pattern\+Model@{Pattern\+Model}!totalpatternsingroup@{totalpatternsingroup}}
\index{totalpatternsingroup@{totalpatternsingroup}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{totalpatternsingroup(int category, int n)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::totalpatternsingroup (
\begin{DoxyParamCaption}
\item[{int}]{category, }
\item[{int}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a38fd6f8f536a802d6653665aa4d48cbf}
Obtains statistics of the model\+: returns the total amount of distinct patterns within the specified group, the group consist of a category and a size. 
\begin{DoxyParams}{Parameters}
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) or to 0 to cover all \\
\hline
{\em n} & Set to any value above zero to only cover only patterns of the specified length. (0 for all sizes) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_aaa5f43e06e2262fc4387729fc6265050}{}\index{Pattern\+Model@{Pattern\+Model}!totaltokensingroup@{totaltokensingroup}}
\index{totaltokensingroup@{totaltokensingroup}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{totaltokensingroup(int category, int n)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::totaltokensingroup (
\begin{DoxyParamCaption}
\item[{int}]{category, }
\item[{int}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_aaa5f43e06e2262fc4387729fc6265050}
Obtains statistics of the model\+: returns the total amount of covered tokens within the specified group, the group consist of a category and a size. 
\begin{DoxyParams}{Parameters}
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) or to 0 to cover all \\
\hline
{\em n} & Set to any value above zero to only cover only patterns of the specified length. (0 for all sizes) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_a23de99349652ec0774db5d09593bd255}{}\index{Pattern\+Model@{Pattern\+Model}!totalwordtypesingroup@{totalwordtypesingroup}}
\index{totalwordtypesingroup@{totalwordtypesingroup}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{totalwordtypesingroup(int category, int n)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::totalwordtypesingroup (
\begin{DoxyParamCaption}
\item[{int}]{category, }
\item[{int}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a23de99349652ec0774db5d09593bd255}
Obtains statistics of the model\+: returns the total amount of word/unigtams types within the specified group, the group consist of a category and a size. 
\begin{DoxyParams}{Parameters}
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) or to 0 to cover all \\
\hline
{\em n} & Set to any value above zero to only cover only patterns of the specified length. (0 for all sizes) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_ac1e8a9a955f8da64abe95179482a6b55}{}\index{Pattern\+Model@{Pattern\+Model}!train@{train}}
\index{train@{train}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{train(std\+::istream $\ast$in, Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainbymodel=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::train (
\begin{DoxyParamCaption}
\item[{std\+::istream $\ast$}]{in, }
\item[{{\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainbymodel = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ac1e8a9a955f8da64abe95179482a6b55}
Train a pattern model on corpus data (given an input stream) 
\begin{DoxyParams}{Parameters}
{\em in} & The input stream of the corpus data ($\ast$.colibri.\+dat) \\
\hline
{\em options} & Options for training \\
\hline
{\em constrainbymodel} & Pointer to another pattern model which should be used to constrain the training of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_ac2390acee4c9aeecf1bce2d0b312bb4c}{}\index{Pattern\+Model@{Pattern\+Model}!train@{train}}
\index{train@{train}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{train(const std\+::string filename, const Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainbymodel=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::train (
\begin{DoxyParamCaption}
\item[{const std\+::string}]{filename, }
\item[{const {\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainbymodel = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_ac2390acee4c9aeecf1bce2d0b312bb4c}
Train a pattern model on corpus data 
\begin{DoxyParams}{Parameters}
{\em filename} & The filename of the corpus data ($\ast$.colibri.\+dat) \\
\hline
{\em options} & Options for training \\
\hline
{\em constrainbymodel} & Pointer to another pattern model which should be used to constrain the training of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
\end{DoxyParams}
\hypertarget{classPatternModel_acd4e0ecc0e796c894b994859b2c5ffb6}{}\index{Pattern\+Model@{Pattern\+Model}!trainskipgrams@{trainskipgrams}}
\index{trainskipgrams@{trainskipgrams}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{trainskipgrams(const Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainbymodel=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::trainskipgrams (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainbymodel = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_acd4e0ecc0e796c894b994859b2c5ffb6}
Train skipgrams, for indexed models only 

Reimplemented in \hyperlink{classIndexedPatternModel_acf0b5ec19f8b76b875dbef07ca0cb398}{Indexed\+Pattern\+Model$<$ Map\+Type $>$}.

\hypertarget{classPatternModel_a7df468e440b875af0d9321d090f87dab}{}\index{Pattern\+Model@{Pattern\+Model}!type@{type}}
\index{type@{type}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{type() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ unsigned char {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::type (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a7df468e440b875af0d9321d090f87dab}
\hypertarget{classPatternModel_af5df3d30417804589c552320add3285a}{}\index{Pattern\+Model@{Pattern\+Model}!types@{types}}
\index{types@{types}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{types()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ virtual unsigned int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::types (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classPatternModel_af5df3d30417804589c552320add3285a}
Return the total amount of word/unigram types in the model 

Implements \hyperlink{classPatternModelInterface_a5f3fab33835e8b01bf30b20793746e24}{Pattern\+Model\+Interface}.

\hypertarget{classPatternModel_af56c31e031bb51d47e98cc433a46556e}{}\index{Pattern\+Model@{Pattern\+Model}!version@{version}}
\index{version@{version}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{version() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ unsigned char {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::version (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_af56c31e031bb51d47e98cc433a46556e}
\hypertarget{classPatternModel_a3456e788caacd51fe3c7fb8fdf547723}{}\index{Pattern\+Model@{Pattern\+Model}!write@{write}}
\index{write@{write}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{write(std\+::ostream $\ast$out)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::write (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{out}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a3456e788caacd51fe3c7fb8fdf547723}
Write the pattern model to output stream \hypertarget{classPatternModel_a73654320cd52e691fd7df037cf3ff013}{}\index{Pattern\+Model@{Pattern\+Model}!write@{write}}
\index{write@{write}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{write(const std\+::string filename)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ void {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::write (
\begin{DoxyParamCaption}
\item[{const std\+::string}]{filename}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classPatternModel_a73654320cd52e691fd7df037cf3ff013}
Save the entire pattern model to file 

\subsection{Member Data Documentation}
\hypertarget{classPatternModel_a2f9145b11bff161df5db3bcd33300319}{}\index{Pattern\+Model@{Pattern\+Model}!cache\+\_\+categories@{cache\+\_\+categories}}
\index{cache\+\_\+categories@{cache\+\_\+categories}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{cache\+\_\+categories}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ std\+::set$<$int$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::cache\+\_\+categories\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a2f9145b11bff161df5db3bcd33300319}
\hypertarget{classPatternModel_a8ef56e648dc462352079542e9528df09}{}\index{Pattern\+Model@{Pattern\+Model}!cache\+\_\+grouptotal@{cache\+\_\+grouptotal}}
\index{cache\+\_\+grouptotal@{cache\+\_\+grouptotal}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{cache\+\_\+grouptotal}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ std\+::map$<$int,std\+::map$<$int,unsigned int$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::cache\+\_\+grouptotal\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a8ef56e648dc462352079542e9528df09}


total occurrences (used for frequency computation, within a group) 

\hypertarget{classPatternModel_a05db7c45b9368438f34dba519df3bb3e}{}\index{Pattern\+Model@{Pattern\+Model}!cache\+\_\+grouptotalpatterns@{cache\+\_\+grouptotalpatterns}}
\index{cache\+\_\+grouptotalpatterns@{cache\+\_\+grouptotalpatterns}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{cache\+\_\+grouptotalpatterns}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ std\+::map$<$int,std\+::map$<$int,unsigned int$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::cache\+\_\+grouptotalpatterns\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a05db7c45b9368438f34dba519df3bb3e}


total distinct patterns per group 

\hypertarget{classPatternModel_aebbf8c45dfa1993d1a9dd262b2b30783}{}\index{Pattern\+Model@{Pattern\+Model}!cache\+\_\+grouptotaltokens@{cache\+\_\+grouptotaltokens}}
\index{cache\+\_\+grouptotaltokens@{cache\+\_\+grouptotaltokens}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{cache\+\_\+grouptotaltokens}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ std\+::map$<$int,std\+::map$<$int,unsigned int$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::cache\+\_\+grouptotaltokens\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_aebbf8c45dfa1993d1a9dd262b2b30783}


total covered tokens per group 

\hypertarget{classPatternModel_a4dee966a62bacaab4d107bb4ec5050c0}{}\index{Pattern\+Model@{Pattern\+Model}!cache\+\_\+grouptotalwordtypes@{cache\+\_\+grouptotalwordtypes}}
\index{cache\+\_\+grouptotalwordtypes@{cache\+\_\+grouptotalwordtypes}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{cache\+\_\+grouptotalwordtypes}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ std\+::map$<$int,std\+::map$<$int,unsigned int$>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::cache\+\_\+grouptotalwordtypes\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a4dee966a62bacaab4d107bb4ec5050c0}


total covered word types per group 

\hypertarget{classPatternModel_a18c0c93e988cce16fdeb5a8a65e878b1}{}\index{Pattern\+Model@{Pattern\+Model}!cache\+\_\+n@{cache\+\_\+n}}
\index{cache\+\_\+n@{cache\+\_\+n}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{cache\+\_\+n}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ std\+::set$<$int$>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::cache\+\_\+n\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a18c0c93e988cce16fdeb5a8a65e878b1}
\hypertarget{classPatternModel_a2f1b4eec80a00ef9c6effea477cc98f4}{}\index{Pattern\+Model@{Pattern\+Model}!externalreverseindex@{externalreverseindex}}
\index{externalreverseindex@{externalreverseindex}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{externalreverseindex}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ bool {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::externalreverseindex}\label{classPatternModel_a2f1b4eec80a00ef9c6effea477cc98f4}


true if reverse index was loaded externally and passed to the model (implies it won\textquotesingle{}t be destroyed when the model is) //only used by \hyperlink{classIndexedPatternModel}{Indexed\+Pattern\+Model} but stored here to ease things for cython 

\hypertarget{classPatternModel_a1070e4e96457caf4ae35d23c1e9ac5c3}{}\index{Pattern\+Model@{Pattern\+Model}!gapconf@{gapconf}}
\index{gapconf@{gapconf}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{gapconf}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ std\+::map$<$int, std\+::vector$<$ std\+::vector$<$ std\+::pair$<$int,int$>$ $>$ $>$ $>$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::gapconf\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a1070e4e96457caf4ae35d23c1e9ac5c3}


pre-\/computed structure of possible gap configurations various pattern lengths 

\hypertarget{classPatternModel_a9534e66035de7df26c9cd257e2faf7d1}{}\index{Pattern\+Model@{Pattern\+Model}!hasskipgrams@{hasskipgrams}}
\index{hasskipgrams@{hasskipgrams}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{hasskipgrams}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ bool {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::hasskipgrams}\label{classPatternModel_a9534e66035de7df26c9cd257e2faf7d1}


Does this model have skipgrams? 

\hypertarget{classPatternModel_ac0e501edfcca21facfe0137ed5140c87}{}\index{Pattern\+Model@{Pattern\+Model}!maxn@{maxn}}
\index{maxn@{maxn}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{maxn}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::maxn\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_ac0e501edfcca21facfe0137ed5140c87}
\hypertarget{classPatternModel_abed492e59e656226b1c48b10c2904618}{}\index{Pattern\+Model@{Pattern\+Model}!minn@{minn}}
\index{minn@{minn}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{minn}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ int {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::minn\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_abed492e59e656226b1c48b10c2904618}
\hypertarget{classPatternModel_af28152ff3d5060e48c18423b8629d1eb}{}\index{Pattern\+Model@{Pattern\+Model}!model\+\_\+type@{model\+\_\+type}}
\index{model\+\_\+type@{model\+\_\+type}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{model\+\_\+type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ unsigned char {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::model\+\_\+type\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_af28152ff3d5060e48c18423b8629d1eb}
\hypertarget{classPatternModel_a032f1517ae658e81fa2ca3360aba62a2}{}\index{Pattern\+Model@{Pattern\+Model}!model\+\_\+version@{model\+\_\+version}}
\index{model\+\_\+version@{model\+\_\+version}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{model\+\_\+version}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ unsigned char {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::model\+\_\+version\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a032f1517ae658e81fa2ca3360aba62a2}
\hypertarget{classPatternModel_a17ad27133991f964ccd23bb09bf64e5a}{}\index{Pattern\+Model@{Pattern\+Model}!reverseindex@{reverseindex}}
\index{reverseindex@{reverseindex}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{reverseindex}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ {\bf Indexed\+Corpus}$\ast$ {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::reverseindex}\label{classPatternModel_a17ad27133991f964ccd23bb09bf64e5a}


Pointer to the reverse index for this model (or N\+U\+L\+L) 

\hypertarget{classPatternModel_a4667c917fab96ae756ee61693220f44e}{}\index{Pattern\+Model@{Pattern\+Model}!totaltokens@{totaltokens}}
\index{totaltokens@{totaltokens}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{totaltokens}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ uint64\+\_\+t {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::totaltokens\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_a4667c917fab96ae756ee61693220f44e}


Total number of tokens in the original corpus, so I\+N\+C\+L\+U\+D\+E\+S T\+O\+K\+E\+N\+S N\+O\+T C\+O\+V\+E\+R\+E\+D B\+Y T\+H\+E M\+O\+D\+E\+L! 

\hypertarget{classPatternModel_af9de224847465b75a9be436b1990cef7}{}\index{Pattern\+Model@{Pattern\+Model}!totaltypes@{totaltypes}}
\index{totaltypes@{totaltypes}!Pattern\+Model@{Pattern\+Model}}
\subsubsection[{totaltypes}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Value\+Type, class Value\+Handler = Base\+Value\+Handler$<$\+Value\+Type$>$, class Map\+Type = Pattern\+Map$<$\+Value\+Type, Base\+Value\+Handler$<$\+Value\+Type$>$$>$$>$ uint64\+\_\+t {\bf Pattern\+Model}$<$ Value\+Type, Value\+Handler, Map\+Type $>$\+::totaltypes\hspace{0.3cm}{\ttfamily [protected]}}\label{classPatternModel_af9de224847465b75a9be436b1990cef7}


Total number of unigram/word types in the original corpus, S\+O I\+N\+C\+L\+U\+D\+I\+N\+G N\+O\+T C\+O\+V\+E\+R\+E\+D B\+Y T\+H\+E M\+O\+D\+E\+L! 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/\hyperlink{patternmodel_8h}{patternmodel.\+h}\end{DoxyCompactItemize}
