\section{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\hyperlink{classAbstractValueHandler}{Abstract\+Value\+Handler$<$ Value\+Type $>$} \\*Abstract value handler class, all value handlers are derived from this. Value handlers are interfaces to the values in \hyperlink{classPattern}{Pattern} Maps. They are used to abstract from the actual value data type and provide some common methods required for all values, as well at methods for serialisation from/to binary file. All are derived from the abstract class \hyperlink{classAbstractValueHandler}{Abstract\+Value\+Handler} }{\pageref{classAbstractValueHandler}}{}
\item\contentsline{section}{\hyperlink{classAlignedPatternMap}{Aligned\+Pattern\+Map$<$ Value\+Type, Value\+Handler, Nested\+Size\+Type $>$} \\*A nested pattern map, useful for storing patterns that map to other patterns, which in turn map to values. An example is phrase-\/translation tables in Machine Translation }{\pageref{classAlignedPatternMap}}{}
\item\contentsline{section}{\hyperlink{classArrayValueHandler}{Array\+Value\+Handler$<$ T, N, countindex $>$} }{\pageref{classArrayValueHandler}}{}
\item\contentsline{section}{\hyperlink{classBaseValueHandler}{Base\+Value\+Handler$<$ Value\+Type $>$} \\*This templated class can be used for all numeric base types (such as int, uint16\+\_\+t, float, etc) }{\pageref{classBaseValueHandler}}{}
\item\contentsline{section}{\hyperlink{classClassDecoder}{Class\+Decoder} \\*Class for decoding binary class-\/encoded data back to plain-\/text. The \hyperlink{classClassDecoder}{Class\+Decoder} maintains a mapping of classes (integers) to words. It allows decoding of a corpus that was losslessly compressed by substituting words for classes. The classes are distributed based on word frequency, with frequent words receiving a lower class number that can be represented in fewer bytes, and rare words receiving a higher class number }{\pageref{classClassDecoder}}{}
\item\contentsline{section}{\hyperlink{classClassEncoder}{Class\+Encoder} \\*Class for encoding plain-\/text to binary class-\/encoded data. The \hyperlink{classClassEncoder}{Class\+Encoder} maintains a mapping of words to classes (integers). It allows a corpus to be losslessly compressed by substituting words for classes. The classes are distributed based on word frequency, with frequent words receiving a lower class number that can be represented in fewer bytes, and rare words receiving a higher class number }{\pageref{classClassEncoder}}{}
\item\contentsline{section}{\hyperlink{structstd_1_1hash_3_01const_01Pattern_01_5_01_4}{std\+::hash$<$ const Pattern $\ast$ $>$} }{\pageref{structstd_1_1hash_3_01const_01Pattern_01_5_01_4}}{}
\item\contentsline{section}{\hyperlink{structstd_1_1hash_3_01const_01PatternPointer_01_5_01_4}{std\+::hash$<$ const Pattern\+Pointer $\ast$ $>$} }{\pageref{structstd_1_1hash_3_01const_01PatternPointer_01_5_01_4}}{}
\item\contentsline{section}{\hyperlink{structstd_1_1hash_3_01Pattern_01_4}{std\+::hash$<$ Pattern $>$} }{\pageref{structstd_1_1hash_3_01Pattern_01_4}}{}
\item\contentsline{section}{\hyperlink{structstd_1_1hash_3_01PatternPointer_01_4}{std\+::hash$<$ Pattern\+Pointer $>$} }{\pageref{structstd_1_1hash_3_01PatternPointer_01_4}}{}
\item\contentsline{section}{\hyperlink{classHashOrderedPatternMap}{Hash\+Ordered\+Pattern\+Map$<$ Value\+Type, Value\+Handler, Read\+Write\+Size\+Type $>$} }{\pageref{classHashOrderedPatternMap}}{}
\item\contentsline{section}{\hyperlink{classHashOrderedPatternSet}{Hash\+Ordered\+Pattern\+Set$<$ Read\+Write\+Size\+Type $>$} \\*A pattern store in the form of an ordered set (i.\+e, no duplicates). Stores only patterns, no values }{\pageref{classHashOrderedPatternSet}}{}
\item\contentsline{section}{\hyperlink{classIndexedCorpus}{Indexed\+Corpus} \\*Class for reading an entire (class encoded) corpus into memory. It provides a reverse index by \hyperlink{classIndexReference}{Index\+Reference}. The reverse index stores positions and unigrams }{\pageref{classIndexedCorpus}}{}
\item\contentsline{section}{\hyperlink{classIndexedData}{Indexed\+Data} \\*Collection of references to position in the corpus (\hyperlink{classIndexReference}{Index\+Reference}). Used by Indexed \hyperlink{classPattern}{Pattern} models }{\pageref{classIndexedData}}{}
\item\contentsline{section}{\hyperlink{classIndexedDataHandler}{Indexed\+Data\+Handler} \\*Data handler for \hyperlink{classIndexedData}{Indexed\+Data}. Deals with serialisation from/to file and conversions }{\pageref{classIndexedDataHandler}}{}
\item\contentsline{section}{\hyperlink{classIndexedPatternModel}{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$} \\*An indexed model mapping patterns to values, high-\/level interface. This is a specialised subclass of \hyperlink{classPatternMap}{Pattern\+Map} }{\pageref{classIndexedPatternModel}}{}
\item\contentsline{section}{\hyperlink{classIndexedPatternPointerModel}{Indexed\+Pattern\+Pointer\+Model$<$ Map\+Type $>$} }{\pageref{classIndexedPatternPointerModel}}{}
\item\contentsline{section}{\hyperlink{classIndexReference}{Index\+Reference} \\*Reference to a position in the corpus }{\pageref{classIndexReference}}{}
\item\contentsline{section}{\hyperlink{classInternalError}{Internal\+Error} }{\pageref{classInternalError}}{}
\item\contentsline{section}{\hyperlink{classIndexedCorpus_1_1iterator}{Indexed\+Corpus\+::iterator} }{\pageref{classIndexedCorpus_1_1iterator}}{}
\item\contentsline{section}{\hyperlink{classKeyError}{Key\+Error} }{\pageref{classKeyError}}{}
\item\contentsline{section}{\hyperlink{structMeasurement}{Measurement} }{\pageref{structMeasurement}}{}
\item\contentsline{section}{\hyperlink{classNoSuchPattern}{No\+Such\+Pattern} }{\pageref{classNoSuchPattern}}{}
\item\contentsline{section}{\hyperlink{classOrderedPatternPointerMap}{Ordered\+Pattern\+Pointer\+Map$<$ Value\+Type, Value\+Handler, Read\+Write\+Size\+Type $>$} }{\pageref{classOrderedPatternPointerMap}}{}
\item\contentsline{section}{\hyperlink{classPattern}{Pattern} \\*\hyperlink{classPattern}{Pattern} class, represents a pattern (ngram, skipgram or flexgram). Encoded in a memory-\/saving fashion. Allows numerous operations }{\pageref{classPattern}}{}
\item\contentsline{section}{\hyperlink{classPatternAlignmentModel}{Pattern\+Alignment\+Model$<$ Feature\+Type $>$} }{\pageref{classPatternAlignmentModel}}{}
\item\contentsline{section}{\hyperlink{classPatternFeatureVector}{Pattern\+Feature\+Vector$<$ Feature\+Type $>$} }{\pageref{classPatternFeatureVector}}{}
\item\contentsline{section}{\hyperlink{classPatternFeatureVectorMap}{Pattern\+Feature\+Vector\+Map$<$ Feature\+Type $>$} }{\pageref{classPatternFeatureVectorMap}}{}
\item\contentsline{section}{\hyperlink{classPatternFeatureVectorMapHandler}{Pattern\+Feature\+Vector\+Map\+Handler$<$ Feature\+Type $>$} }{\pageref{classPatternFeatureVectorMapHandler}}{}
\item\contentsline{section}{\hyperlink{classPatternMap}{Pattern\+Map$<$ Value\+Type, Value\+Handler, Read\+Write\+Size\+Type $>$} \\*A pattern map storing patterns and their values in a hash map (unordered\+\_\+map) }{\pageref{classPatternMap}}{}
\item\contentsline{section}{\hyperlink{classPatternMapStore}{Pattern\+Map\+Store$<$ Container\+Type, Value\+Type, Value\+Handler, Read\+Write\+Size\+Type, Pattern\+Type $>$} \\*Abstract class for map-\/like pattern stores, do not instantiate directly }{\pageref{classPatternMapStore}}{}
\item\contentsline{section}{\hyperlink{classPatternModel}{Pattern\+Model$<$ Value\+Type, Value\+Handler, Map\+Type, Pattern\+Type $>$} \\*A model mapping patterns to values, gigh-\/level interface }{\pageref{classPatternModel}}{}
\item\contentsline{section}{\hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} \\*Basic read-\/only interface for pattern models, abstract base class }{\pageref{classPatternModelInterface}}{}
\item\contentsline{section}{\hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} \\*Options for \hyperlink{classPattern}{Pattern} Model loading and training }{\pageref{classPatternModelOptions}}{}
\item\contentsline{section}{\hyperlink{classPatternPointer}{Pattern\+Pointer} }{\pageref{classPatternPointer}}{}
\item\contentsline{section}{\hyperlink{classPatternPointerMap}{Pattern\+Pointer\+Map$<$ Value\+Type, Value\+Handler, Read\+Write\+Size\+Type $>$} }{\pageref{classPatternPointerMap}}{}
\item\contentsline{section}{\hyperlink{classPatternPointerModel}{Pattern\+Pointer\+Model$<$ Value\+Type, Value\+Handler, Map\+Type $>$} }{\pageref{classPatternPointerModel}}{}
\item\contentsline{section}{\hyperlink{classPatternSet}{Pattern\+Set$<$ Read\+Write\+Size\+Type $>$} \\*A pattern store in the form of an unordered set (i.\+e, no duplicates). Stores only patterns, no values }{\pageref{classPatternSet}}{}
\item\contentsline{section}{\hyperlink{classPatternSetModel}{Pattern\+Set\+Model} \\*A pattern model based on an unordered set, does not hold data, only patterns. Very suitable for loading constraint models }{\pageref{classPatternSetModel}}{}
\item\contentsline{section}{\hyperlink{classPatternStore}{Pattern\+Store$<$ Container\+Type, Read\+Write\+Size\+Type, Pattern\+Type $>$} \\*Abstract \hyperlink{classPattern}{Pattern} store class, not to be instantiated directly }{\pageref{classPatternStore}}{}
\item\contentsline{section}{\hyperlink{classPatternStoreInterface}{Pattern\+Store\+Interface} \\*Limited virtual interface to pattern stores }{\pageref{classPatternStoreInterface}}{}
\item\contentsline{section}{\hyperlink{classPatternStoreValueHandler}{Pattern\+Store\+Value\+Handler$<$ Pattern\+Store\+Type $>$} \\*A complex value handler for values that are themselves pattern stores (allows building nested maps) }{\pageref{classPatternStoreValueHandler}}{}
\item\contentsline{section}{\hyperlink{classSpookyHash}{Spooky\+Hash} }{\pageref{classSpookyHash}}{}
\end{DoxyCompactList}
