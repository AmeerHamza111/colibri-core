\hypertarget{classIndexedPatternModel}{}\section{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$ Class Template Reference}
\label{classIndexedPatternModel}\index{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$@{Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}}


An indexed model mapping patterns to values, high-\/level interface. This is a specialised subclass of \hyperlink{classPatternMap}{Pattern\+Map}.  




{\ttfamily \#include $<$patternmodel.\+h$>$}

Inheritance diagram for Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=1.651917cm]{classIndexedPatternModel}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classIndexedPatternModel_ae2334d12047a541e3ffba097a88510cd}{Indexed\+Pattern\+Model} (\hyperlink{classIndexedCorpus}{Indexed\+Corpus} $\ast$corpus=N\+U\+L\+L)
\item 
\hyperlink{classIndexedPatternModel_a4c22b5b077ece88e477f6916cd40cd67}{Indexed\+Pattern\+Model} (std\+::istream $\ast$f, const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainmodel=N\+U\+L\+L, \hyperlink{classIndexedCorpus}{Indexed\+Corpus} $\ast$corpus=N\+U\+L\+L)
\item 
\hyperlink{classIndexedPatternModel_a30b96b36aac65dbd009bf42c959e55a7}{Indexed\+Pattern\+Model} (const std\+::string filename, const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainmodel=N\+U\+L\+L, \hyperlink{classIndexedCorpus}{Indexed\+Corpus} $\ast$corpus=N\+U\+L\+L)
\item 
virtual \hyperlink{classIndexedPatternModel_ae3de4425dbc90cd9db0cce63e744a64d}{$\sim$\+Indexed\+Pattern\+Model} ()
\item 
int \hyperlink{classIndexedPatternModel_a63f42808d22dd3a813242332ad42ee6c}{getmodeltype} () const 
\item 
int \hyperlink{classIndexedPatternModel_a50e185e2f7e48751f8633d4b981089bc}{getmodelversion} () const 
\item 
virtual void \hyperlink{classIndexedPatternModel_a9ae48ed363f333a57cbec0538a434497}{add} (const \hyperlink{classPattern}{Pattern} \&pattern, \hyperlink{classIndexedData}{Indexed\+Data} $\ast$value, const \hyperlink{classIndexReference}{Index\+Reference} \&ref)
\item 
virtual void \hyperlink{classIndexedPatternModel_a27d944449ea3e5f6d1c578770b07ad13}{add} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&patternpointer, \hyperlink{classIndexedData}{Indexed\+Data} $\ast$value, const \hyperlink{classIndexReference}{Index\+Reference} \&ref)
\item 
\hyperlink{classIndexedData}{Indexed\+Data} $\ast$ \hyperlink{classIndexedPatternModel_af242c0b747c2467e9e89f1cd731fe2d1}{getdata} (const \hyperlink{classPattern}{Pattern} \&pattern, bool makeifnew=false)
\item 
\hyperlink{classIndexedData}{Indexed\+Data} $\ast$ \hyperlink{classIndexedPatternModel_ac5a8ebe51c1a999a06c97ffc34d58401}{getdata} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, bool makeifnew=false)
\item 
virtual void \hyperlink{classIndexedPatternModel_ad416961213cc18e4c4a3d9f9e71d445e}{train} (std\+::istream $\ast$in, \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainbymodel=N\+U\+L\+L, bool continued=false, uint32\+\_\+t firstsentence=1, bool ignoreerrors=false)
\item 
virtual void \hyperlink{classIndexedPatternModel_a22f094eef93f4afbfed7697724975220}{train} (const std\+::string \&filename, \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainbymodel=N\+U\+L\+L, bool continued=false, uint32\+\_\+t firstsentence=1, bool ignoreerrors=false)
\item 
void \hyperlink{classIndexedPatternModel_a4fb359f3059ee9689494fd053ce4adba}{info} (std\+::ostream $\ast$O\+U\+T)
\item 
void \hyperlink{classIndexedPatternModel_ab139c59cacc6cabe5f1004c741feb9f6}{print} (std\+::ostream $\ast$out, \hyperlink{classClassDecoder}{Class\+Decoder} \&decoder)
\item 
void \hyperlink{classIndexedPatternModel_a3a2833e7343e15d7079ca40fe0d13652}{print} (std\+::ostream $\ast$out, \hyperlink{classClassDecoder}{Class\+Decoder} \&decoder, const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, bool endline=true)
\item 
virtual void \hyperlink{classIndexedPatternModel_a0bd2f75e24f53a70170468bb1dc4caaf}{trainskipgrams} (\hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options, \hyperlink{classPatternModelInterface}{Pattern\+Model\+Interface} $\ast$constrainbymodel=N\+U\+L\+L)
\item 
\hyperlink{classPattern}{Pattern} \hyperlink{classIndexedPatternModel_a107afd39015a4dc4ebaa6501d38945e6}{getpatternfromtoken} (\hyperlink{classIndexReference}{Index\+Reference} ref)
\item 
\hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classIndexedPatternModel_a5dfb36835fbf8c1f0aed894217838c78}{getskipcontent} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern)
\item 
void \hyperlink{classIndexedPatternModel_ad477f945c83813cc0c3766737be54214}{prunerelations} (\hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \&relations, unsigned int occurrencethreshold)
\item 
\hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classIndexedPatternModel_acbf5086ccea0a356aff9817647192b33}{gettemplates} (const \hyperlink{classPattern}{Pattern} \&pattern, unsigned int occurrencethreshold=0)
\item 
\hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classIndexedPatternModel_a93a9511c2b8dabf2c977b7e1b63c3fc9}{getinstances} (const \hyperlink{classPattern}{Pattern} \&pattern, unsigned int occurrencethreshold=0)
\item 
\hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classIndexedPatternModel_adbc2f3af5e9fbdab9a754ed155bb54cb}{getsubchildren} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int \hyperlink{classPatternModel_a2422cb944da209f399b3b10f3b1d2684}{size}=0)
\item 
\hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classIndexedPatternModel_ad85affa2176df3faf63b359e0c90e616}{getsubparents} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int \hyperlink{classPatternModel_a2422cb944da209f399b3b10f3b1d2684}{size}=0)
\item 
\hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classIndexedPatternModel_a1d2e54a55dce955eadd2a09e93ce9b79}{getleftneighbours} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int \hyperlink{classPatternModel_a2422cb944da209f399b3b10f3b1d2684}{size}=0, unsigned int cutoff=0)
\item 
\hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classIndexedPatternModel_a6b3626617a03ebeade50af34743d3541}{getrightneighbours} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int \hyperlink{classPatternModel_a2422cb944da209f399b3b10f3b1d2684}{size}=0, unsigned int cutoff=0)
\item 
int \hyperlink{classIndexedPatternModel_a812c9e92fbf801545c1596cc5f4cf080}{pruneskipgrams} (int threshold, int minskiptypes, int \+\_\+n=0)
\item 
virtual void \hyperlink{classIndexedPatternModel_a0f0da07b70336e9699accedc2cde5351}{computecoveragestats} (int category=0, int n=0)
\item 
\hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classIndexedPatternModel_ae49646bf2fafbf9dca7a3a450573f262}{getrightcooc} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int \hyperlink{classPatternModel_a2422cb944da209f399b3b10f3b1d2684}{size}=0, \hyperlink{classIndexedData}{Indexed\+Data} $\ast$matches=N\+U\+L\+L)
\item 
\hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classIndexedPatternModel_a0bb4086eb14053c92ca79bb792611179}{getleftcooc} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int \hyperlink{classPatternModel_a2422cb944da209f399b3b10f3b1d2684}{size}=0)
\item 
\hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \hyperlink{classIndexedPatternModel_aa262aa72330822664d2327378603b872}{getcooc} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int \hyperlink{classPatternModel_a2422cb944da209f399b3b10f3b1d2684}{size}=0, bool ordersignificant=false)
\item 
double \hyperlink{classIndexedPatternModel_a59db87907763ca11f553eb138c3a8425}{npmi} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&key1, const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&key2, int jointcount)
\item 
void \hyperlink{classIndexedPatternModel_aa666827ba3837abe86bf538782abdd96}{outputrelations} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} \&relations, \hyperlink{classClassDecoder}{Class\+Decoder} \&classdecoder, std\+::ostream $\ast$O\+U\+T, const std\+::string label=\char`\"{}R\+E\+L\+A\+T\+E\+D-\/T\+O\char`\"{})
\item 
void \hyperlink{classIndexedPatternModel_a09b446b208f4a013f07828f8650c278e}{outputrelations} (const \hyperlink{classPatternPointer}{Pattern\+Pointer} \&pattern, \hyperlink{classClassDecoder}{Class\+Decoder} \&classdecoder, std\+::ostream $\ast$O\+U\+T, bool outputheader=true)
\item 
void \hyperlink{classIndexedPatternModel_aac497b4ee70d9bf9156e69c35f3573b3}{computenpmi} (std\+::map$<$ \hyperlink{classPatternPointer}{Pattern\+Pointer}, \hyperlink{patternmodel_8h_ae13b52c8cf777358f19da17c90c7dac0}{t\+\_\+relationmap\+\_\+double} $>$ \&coocmap, double threshold, bool right=true, bool left=true)
\item 
void \hyperlink{classIndexedPatternModel_a1052616f5b2316f9ce364e5d176554ac}{computecooc} (std\+::map$<$ \hyperlink{classPatternPointer}{Pattern\+Pointer}, \hyperlink{patternmodel_8h_a8695a2b10be5a74c827cd6c11bd46fb9}{t\+\_\+relationmap} $>$ \&coocmap, int threshold, bool right=true, bool left=true)
\item 
int \hyperlink{classIndexedPatternModel_a838f141f5f7cf888ce44bfc1b7a14ba3}{computeflexgrams\+\_\+fromskipgrams} ()
\item 
int \hyperlink{classIndexedPatternModel_a7b6915f17b1afe98e84e4380a00f40e4}{computeflexgrams\+\_\+fromcooc} (double threshold)
\item 
void \hyperlink{classIndexedPatternModel_a17e2553ba9520ac45bac77f0948b1b21}{outputcooc\+\_\+npmi} (std\+::ostream $\ast$O\+U\+T, \hyperlink{classClassDecoder}{Class\+Decoder} \&classdecoder, double threshold)
\item 
void \hyperlink{classIndexedPatternModel_a7029fb323b1ef87bcf821050e78e5cd9}{outputcooc} (std\+::ostream $\ast$O\+U\+T, \hyperlink{classClassDecoder}{Class\+Decoder} \&classdecoder, double threshold)
\item 
int \hyperlink{classIndexedPatternModel_a8edee00c483b931ea640d1861e7c8f71}{flexgramsize} (const \hyperlink{classPattern}{Pattern} \&pattern, \hyperlink{classIndexReference}{Index\+Reference} \hyperlink{benchmarks_8cpp_ac7fa37beaab207886901b58632083209}{begin})
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classIndexedPatternModel_a14708a972c0c3297421b370bbdc75b65}{postread} (const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options)
\item 
virtual void \hyperlink{classIndexedPatternModel_a5314a6b877df1447d28128fb9d9e67b3}{posttrain} (const \hyperlink{classPatternModelOptions}{Pattern\+Model\+Options} options)
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
\subsubsection*{template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$class Indexed\+Pattern\+Model$<$ Map\+Type, Pattern\+Type $>$}

An indexed model mapping patterns to values, high-\/level interface. This is a specialised subclass of \hyperlink{classPatternMap}{Pattern\+Map}. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Map\+Type} & The type of container to use \\
\hline
\end{DoxyTemplParams}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classIndexedPatternModel_ae2334d12047a541e3ffba097a88510cd}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{Indexed\+Pattern\+Model(\+Indexed\+Corpus $\ast$corpus=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::{\bf Indexed\+Pattern\+Model} (
\begin{DoxyParamCaption}
\item[{{\bf Indexed\+Corpus} $\ast$}]{corpus = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_ae2334d12047a541e3ffba097a88510cd}
Begin a new pattern model, optionally pre-\/setting a reverseindex. \hypertarget{classIndexedPatternModel_a4c22b5b077ece88e477f6916cd40cd67}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{Indexed\+Pattern\+Model(std\+::istream $\ast$f, const Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainmodel=\+N\+U\+L\+L, Indexed\+Corpus $\ast$corpus=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::{\bf Indexed\+Pattern\+Model} (
\begin{DoxyParamCaption}
\item[{std\+::istream $\ast$}]{f, }
\item[{const {\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainmodel = {\ttfamily NULL}, }
\item[{{\bf Indexed\+Corpus} $\ast$}]{corpus = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_a4c22b5b077ece88e477f6916cd40cd67}
Read a pattern model from an input stream 
\begin{DoxyParams}{Parameters}
{\em f} & The input stream \\
\hline
{\em options} & Options for reading, these act as filter for the data, allowing you to raise thresholds etc \\
\hline
{\em constrainmodel} & Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
{\em corpus} & Pointer to the loaded corpus, used as a reverse index. \\
\hline
\end{DoxyParams}
\hypertarget{classIndexedPatternModel_a30b96b36aac65dbd009bf42c959e55a7}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{Indexed\+Pattern\+Model(const std\+::string filename, const Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainmodel=\+N\+U\+L\+L, Indexed\+Corpus $\ast$corpus=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::{\bf Indexed\+Pattern\+Model} (
\begin{DoxyParamCaption}
\item[{const std\+::string}]{filename, }
\item[{const {\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainmodel = {\ttfamily NULL}, }
\item[{{\bf Indexed\+Corpus} $\ast$}]{corpus = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_a30b96b36aac65dbd009bf42c959e55a7}
Read a pattern model from file 
\begin{DoxyParams}{Parameters}
{\em filename} & The filename \\
\hline
{\em options} & Options for reading, these act as filter for the data, allowing you to raise thresholds etc \\
\hline
{\em constrainmodel} & Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
{\em corpus} & Pointer to the loaded corpus, used as a reverse index. \\
\hline
\end{DoxyParams}
\hypertarget{classIndexedPatternModel_ae3de4425dbc90cd9db0cce63e744a64d}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!````~Indexed\+Pattern\+Model@{$\sim$\+Indexed\+Pattern\+Model}}
\index{````~Indexed\+Pattern\+Model@{$\sim$\+Indexed\+Pattern\+Model}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{$\sim$\+Indexed\+Pattern\+Model()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ virtual {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::$\sim${\bf Indexed\+Pattern\+Model} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_ae3de4425dbc90cd9db0cce63e744a64d}


\subsection{Member Function Documentation}
\hypertarget{classIndexedPatternModel_a9ae48ed363f333a57cbec0538a434497}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!add@{add}}
\index{add@{add}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{add(const Pattern \&pattern, Indexed\+Data $\ast$value, const Index\+Reference \&ref)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::add (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{{\bf Indexed\+Data} $\ast$}]{value, }
\item[{const {\bf Index\+Reference} \&}]{ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_a9ae48ed363f333a57cbec0538a434497}
Add a pattern, with a given position, and a value to the model. This is called during training at every time an instance of a pattern is found in the data. 
\begin{DoxyParams}{Parameters}
{\em pattern} & The pattern to add \\
\hline
{\em value} & A pointer to the value for this pattern, set to N\+U\+L\+L and it will be automatically determined \\
\hline
{\em \hyperlink{classIndexReference}{Index\+Reference}} & The position in the corpus where the patterns occurs \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classPatternModel_aeb114aa9a51e696e0922f81b73c97112}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.

\hypertarget{classIndexedPatternModel_a27d944449ea3e5f6d1c578770b07ad13}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!add@{add}}
\index{add@{add}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{add(const Pattern\+Pointer \&patternpointer, Indexed\+Data $\ast$value, const Index\+Reference \&ref)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::add (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{patternpointer, }
\item[{{\bf Indexed\+Data} $\ast$}]{value, }
\item[{const {\bf Index\+Reference} \&}]{ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_a27d944449ea3e5f6d1c578770b07ad13}


Reimplemented from \hyperlink{classPatternModel_a990365a2aa7d37adbcfb3de99cb32da3}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.



Reimplemented in \hyperlink{classIndexedPatternPointerModel_acb3c231cbc2b01e028abc6b256505551}{Indexed\+Pattern\+Pointer\+Model$<$ Map\+Type $>$}.

\hypertarget{classIndexedPatternModel_a1052616f5b2316f9ce364e5d176554ac}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!computecooc@{computecooc}}
\index{computecooc@{computecooc}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{computecooc(std\+::map$<$ Pattern\+Pointer, t\+\_\+relationmap $>$ \&coocmap, int threshold, bool right=true, bool left=true)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::computecooc (
\begin{DoxyParamCaption}
\item[{std\+::map$<$ {\bf Pattern\+Pointer}, {\bf t\+\_\+relationmap} $>$ \&}]{coocmap, }
\item[{int}]{threshold, }
\item[{bool}]{right = {\ttfamily true}, }
\item[{bool}]{left = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_a1052616f5b2316f9ce364e5d176554ac}
Compute co-\/occurence as absolute joint occurrence count, for all patterns 
\begin{DoxyParams}{Parameters}
{\em coocmap} & The map that will store the results \\
\hline
{\em threshold} & Only include pairs passing this N\+P\+M\+I threshold \\
\hline
{\em right} & Compute co-\/occurence to the right (default\+: true) \\
\hline
{\em left} & Compute co-\/occurence to the left (default\+: true) \\
\hline
\end{DoxyParams}
\hypertarget{classIndexedPatternModel_a0f0da07b70336e9699accedc2cde5351}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!computecoveragestats@{computecoveragestats}}
\index{computecoveragestats@{computecoveragestats}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{computecoveragestats(int category=0, int n=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::computecoveragestats (
\begin{DoxyParamCaption}
\item[{int}]{category = {\ttfamily 0}, }
\item[{int}]{n = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_a0f0da07b70336e9699accedc2cde5351}
Compute coverage statistics on the model, will generally be called automatically by methods who use it, and the statistics are cached after computation. 

Reimplemented from \hyperlink{classPatternModel_ace39c4eb87c43a1c1f1e38597e44edad}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.

\hypertarget{classIndexedPatternModel_a7b6915f17b1afe98e84e4380a00f40e4}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!computeflexgrams\+\_\+fromcooc@{computeflexgrams\+\_\+fromcooc}}
\index{computeflexgrams\+\_\+fromcooc@{computeflexgrams\+\_\+fromcooc}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{computeflexgrams\+\_\+fromcooc(double threshold)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ int {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::computeflexgrams\+\_\+fromcooc (
\begin{DoxyParamCaption}
\item[{double}]{threshold}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_a7b6915f17b1afe98e84e4380a00f40e4}
Compute flexgrams using co-\/occurrence 
\begin{DoxyParams}{Parameters}
{\em threshold} & Normalised Pointwise Mutual Information threshold \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of flexgrams found 
\end{DoxyReturn}
\hypertarget{classIndexedPatternModel_a838f141f5f7cf888ce44bfc1b7a14ba3}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!computeflexgrams\+\_\+fromskipgrams@{computeflexgrams\+\_\+fromskipgrams}}
\index{computeflexgrams\+\_\+fromskipgrams@{computeflexgrams\+\_\+fromskipgrams}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{computeflexgrams\+\_\+fromskipgrams()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ int {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::computeflexgrams\+\_\+fromskipgrams (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_a838f141f5f7cf888ce44bfc1b7a14ba3}
Compute flexgrams by abstracting from existing skipgrams in the model \begin{DoxyReturn}{Returns}
The number of flexgrams found 
\end{DoxyReturn}


Reimplemented from \hyperlink{classPatternModel_a833c6478ea967a4fa4c75c8ff971eac8}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.

\hypertarget{classIndexedPatternModel_aac497b4ee70d9bf9156e69c35f3573b3}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!computenpmi@{computenpmi}}
\index{computenpmi@{computenpmi}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{computenpmi(std\+::map$<$ Pattern\+Pointer, t\+\_\+relationmap\+\_\+double $>$ \&coocmap, double threshold, bool right=true, bool left=true)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::computenpmi (
\begin{DoxyParamCaption}
\item[{std\+::map$<$ {\bf Pattern\+Pointer}, {\bf t\+\_\+relationmap\+\_\+double} $>$ \&}]{coocmap, }
\item[{double}]{threshold, }
\item[{bool}]{right = {\ttfamily true}, }
\item[{bool}]{left = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_aac497b4ee70d9bf9156e69c35f3573b3}
\hypertarget{classIndexedPatternModel_a8edee00c483b931ea640d1861e7c8f71}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!flexgramsize@{flexgramsize}}
\index{flexgramsize@{flexgramsize}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{flexgramsize(const Pattern \&pattern, Index\+Reference begin)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ int {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::flexgramsize (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{{\bf Index\+Reference}}]{begin}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_a8edee00c483b931ea640d1861e7c8f71}
attempt to find the flexgram size for the given begin position, returns 0 if the flexgram was not found at all if there are multiple matches, the shortest is returned \hypertarget{classIndexedPatternModel_aa262aa72330822664d2327378603b872}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!getcooc@{getcooc}}
\index{getcooc@{getcooc}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{getcooc(const Pattern\+Pointer \&pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int size=0, bool ordersignificant=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf t\+\_\+relationmap} {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::getcooc (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{unsigned int}]{occurrencethreshold = {\ttfamily 0}, }
\item[{int}]{category = {\ttfamily 0}, }
\item[{unsigned int}]{size = {\ttfamily 0}, }
\item[{bool}]{ordersignificant = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_aa262aa72330822664d2327378603b872}
Returns all patterns in the model that co-\/occur with the given pattern in the same sentence 
\begin{DoxyParams}{Parameters}
{\em occurrencethreshold} & If set above zero, filters to only include patterns occurring above this threshold \\
\hline
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) to include only this category. Set to 0 for unfiltered (default) \\
\hline
{\em size} & Set to any value above zero to only include patterns of the specified length. \\
\hline
{\em ordersignificant} & If set to true, each co-\/occuring pair will occur at least once in the result, if false (default) it will appear twice, once in A,B form and once in B,A form. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a relation map 
\end{DoxyReturn}
\hypertarget{classIndexedPatternModel_af242c0b747c2467e9e89f1cd731fe2d1}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!getdata@{getdata}}
\index{getdata@{getdata}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{getdata(const Pattern \&pattern, bool makeifnew=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf Indexed\+Data}$\ast$ {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::getdata (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{bool}]{makeifnew = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_af242c0b747c2467e9e89f1cd731fe2d1}
Get the indices stored for the specified pattern. 
\begin{DoxyParams}{Parameters}
{\em makeifnew} & Add the pattern with empty value if it does not exist (default\+: false) \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classPatternModel_a1b6c55216886cd765ab3189c24f8da2a}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.

\hypertarget{classIndexedPatternModel_ac5a8ebe51c1a999a06c97ffc34d58401}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!getdata@{getdata}}
\index{getdata@{getdata}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{getdata(const Pattern\+Pointer \&pattern, bool makeifnew=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf Indexed\+Data}$\ast$ {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::getdata (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{bool}]{makeifnew = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_ac5a8ebe51c1a999a06c97ffc34d58401}


Reimplemented from \hyperlink{classPatternModel_ad1c89dc32115373dec3b1a4e3cbeb700}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.

\hypertarget{classIndexedPatternModel_a93a9511c2b8dabf2c977b7e1b63c3fc9}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!getinstances@{getinstances}}
\index{getinstances@{getinstances}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{getinstances(const Pattern \&pattern, unsigned int occurrencethreshold=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf t\+\_\+relationmap} {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::getinstances (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{unsigned int}]{occurrencethreshold = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_a93a9511c2b8dabf2c977b7e1b63c3fc9}
Returns all ngrams in the model that instantiate the given skipgram/flexgram. If all the gaps in a skipgram/flexgram are filled, we speak of such an instantiation. An occurrence threshold may be used to filter. \begin{DoxyReturn}{Returns}
a relation map 
\end{DoxyReturn}
\hypertarget{classIndexedPatternModel_a0bb4086eb14053c92ca79bb792611179}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!getleftcooc@{getleftcooc}}
\index{getleftcooc@{getleftcooc}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{getleftcooc(const Pattern\+Pointer \&pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int size=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf t\+\_\+relationmap} {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::getleftcooc (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{unsigned int}]{occurrencethreshold = {\ttfamily 0}, }
\item[{int}]{category = {\ttfamily 0}, }
\item[{unsigned int}]{size = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_a0bb4086eb14053c92ca79bb792611179}
Returns all patterns in the model that co-\/occur with the given pattern in the same sentence and appear to the left of the given pattern 
\begin{DoxyParams}{Parameters}
{\em occurrencethreshold} & If set above zero, filters to only include patterns occurring above this threshold \\
\hline
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) to include only this category. Set to 0 for unfiltered (default) \\
\hline
{\em size} & Set to any value above zero to only include patterns of the specified length. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a relation map 
\end{DoxyReturn}
\hypertarget{classIndexedPatternModel_a1d2e54a55dce955eadd2a09e93ce9b79}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!getleftneighbours@{getleftneighbours}}
\index{getleftneighbours@{getleftneighbours}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{getleftneighbours(const Pattern\+Pointer \&pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int size=0, unsigned int cutoff=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf t\+\_\+relationmap} {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::getleftneighbours (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{unsigned int}]{occurrencethreshold = {\ttfamily 0}, }
\item[{int}]{category = {\ttfamily 0}, }
\item[{unsigned int}]{size = {\ttfamily 0}, }
\item[{unsigned int}]{cutoff = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_a1d2e54a55dce955eadd2a09e93ce9b79}
Returns all patterns in the model that directly neighbour the given pattern at the left side 
\begin{DoxyParams}{Parameters}
{\em occurrencethreshold} & If set above zero, filters to only include patterns occurring above this threshold \\
\hline
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) to include only this category. Set to 0 for unfiltered (default) \\
\hline
{\em size} & Set to any value above zero to only include patterns of the specified length. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a relation map 
\end{DoxyReturn}
\hypertarget{classIndexedPatternModel_a63f42808d22dd3a813242332ad42ee6c}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!getmodeltype@{getmodeltype}}
\index{getmodeltype@{getmodeltype}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{getmodeltype() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ int {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::getmodeltype (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_a63f42808d22dd3a813242332ad42ee6c}
Returns the type of model (a value from Model\+Type) 

Reimplemented from \hyperlink{classPatternModel_ac4a38270c6a2dbcfccf0b8baebee11eb}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.

\hypertarget{classIndexedPatternModel_a50e185e2f7e48751f8633d4b981089bc}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!getmodelversion@{getmodelversion}}
\index{getmodelversion@{getmodelversion}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{getmodelversion() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ int {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::getmodelversion (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_a50e185e2f7e48751f8633d4b981089bc}
Returns the version of the model implementation and binary serialisation format 

Reimplemented from \hyperlink{classPatternModel_a760a01e32f97b63400d13e69384dad86}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.

\hypertarget{classIndexedPatternModel_a107afd39015a4dc4ebaa6501d38945e6}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!getpatternfromtoken@{getpatternfromtoken}}
\index{getpatternfromtoken@{getpatternfromtoken}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{getpatternfromtoken(\+Index\+Reference ref)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf Pattern} {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::getpatternfromtoken (
\begin{DoxyParamCaption}
\item[{{\bf Index\+Reference}}]{ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_a107afd39015a4dc4ebaa6501d38945e6}
Return the unigram \hyperlink{classPattern}{Pattern} that occurs on the specified position, using the reverse index. \hypertarget{classIndexedPatternModel_ae49646bf2fafbf9dca7a3a450573f262}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!getrightcooc@{getrightcooc}}
\index{getrightcooc@{getrightcooc}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{getrightcooc(const Pattern\+Pointer \&pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int size=0, Indexed\+Data $\ast$matches=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf t\+\_\+relationmap} {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::getrightcooc (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{unsigned int}]{occurrencethreshold = {\ttfamily 0}, }
\item[{int}]{category = {\ttfamily 0}, }
\item[{unsigned int}]{size = {\ttfamily 0}, }
\item[{{\bf Indexed\+Data} $\ast$}]{matches = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_ae49646bf2fafbf9dca7a3a450573f262}
Returns all patterns in the model that co-\/occur with the given pattern in the same sentence and appear to the right of the given pattern 
\begin{DoxyParams}{Parameters}
{\em occurrencethreshold} & If set above zero, filters to only include patterns occurring above this threshold \\
\hline
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) to include only this category. Set to 0 for unfiltered (default) \\
\hline
{\em size} & Set to any value above zero to only include patterns of the specified length. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a relation map 
\end{DoxyReturn}
\hypertarget{classIndexedPatternModel_a6b3626617a03ebeade50af34743d3541}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!getrightneighbours@{getrightneighbours}}
\index{getrightneighbours@{getrightneighbours}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{getrightneighbours(const Pattern\+Pointer \&pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int size=0, unsigned int cutoff=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf t\+\_\+relationmap} {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::getrightneighbours (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{unsigned int}]{occurrencethreshold = {\ttfamily 0}, }
\item[{int}]{category = {\ttfamily 0}, }
\item[{unsigned int}]{size = {\ttfamily 0}, }
\item[{unsigned int}]{cutoff = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_a6b3626617a03ebeade50af34743d3541}
Returns all patterns in the model that directly neighbour the given pattern at the right side 
\begin{DoxyParams}{Parameters}
{\em occurrencethreshold} & If set above zero, filters to only include patterns occurring above this threshold \\
\hline
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) to include only this category. Set to 0 for unfiltered (default) \\
\hline
{\em size} & Set to any value above zero to only include patterns of the specified length. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a relation map 
\end{DoxyReturn}
\hypertarget{classIndexedPatternModel_a5dfb36835fbf8c1f0aed894217838c78}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!getskipcontent@{getskipcontent}}
\index{getskipcontent@{getskipcontent}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{getskipcontent(const Pattern\+Pointer \&pattern)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf t\+\_\+relationmap} {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::getskipcontent (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_a5dfb36835fbf8c1f0aed894217838c78}
Given a skipgram, returns patterns in the model which would instantiate the skipgram if inserted into the gaps. For skipgrams with multiple gaps, these skip content patterns are themselves skipgrams. Skipgram and skip content complement eachother \begin{DoxyReturn}{Returns}
A relation map 
\end{DoxyReturn}


Reimplemented from \hyperlink{classPatternModel_ab0b9ea8b905ce180eec004413192abaf}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.

\hypertarget{classIndexedPatternModel_adbc2f3af5e9fbdab9a754ed155bb54cb}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!getsubchildren@{getsubchildren}}
\index{getsubchildren@{getsubchildren}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{getsubchildren(const Pattern\+Pointer \&pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int size=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf t\+\_\+relationmap} {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::getsubchildren (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{unsigned int}]{occurrencethreshold = {\ttfamily 0}, }
\item[{int}]{category = {\ttfamily 0}, }
\item[{unsigned int}]{size = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_adbc2f3af5e9fbdab9a754ed155bb54cb}
Returns all patterns in the model that are subsumed by the specified pattern. Subsumed patterns are smaller than the subsuming pattern. Every n-\/gram (except unigram) by definition subsumes two n-\/1-\/grams. 
\begin{DoxyParams}{Parameters}
{\em occurrencethreshold} & If set above zero, filters to only include patterns occurring above this threshold \\
\hline
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) to include only this category. Set to 0 for unfiltered (default) \\
\hline
{\em size} & Set to any value above zero to only include patterns of the specified length. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a relation map 
\end{DoxyReturn}
\hypertarget{classIndexedPatternModel_ad85affa2176df3faf63b359e0c90e616}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!getsubparents@{getsubparents}}
\index{getsubparents@{getsubparents}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{getsubparents(const Pattern\+Pointer \&pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int size=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf t\+\_\+relationmap} {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::getsubparents (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{unsigned int}]{occurrencethreshold = {\ttfamily 0}, }
\item[{int}]{category = {\ttfamily 0}, }
\item[{unsigned int}]{size = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_ad85affa2176df3faf63b359e0c90e616}
Returns all patterns in the model that subsume the specified pattern. Subsuming patterns are larger than the subsuming pattern. Every n-\/gram (except unigram) by definition subsumes two n-\/1-\/grams. 
\begin{DoxyParams}{Parameters}
{\em occurrencethreshold} & If set above zero, filters to only include patterns occurring above this threshold \\
\hline
{\em category} & Set to any value of Pattern\+Category (N\+G\+R\+A\+M,S\+K\+I\+P\+G\+R\+A\+M,F\+L\+E\+X\+G\+R\+A\+M) to include only this category. Set to 0 for unfiltered (default) \\
\hline
{\em size} & Set to any value above zero to only include patterns of the specified length. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a relation map 
\end{DoxyReturn}
\hypertarget{classIndexedPatternModel_acbf5086ccea0a356aff9817647192b33}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!gettemplates@{gettemplates}}
\index{gettemplates@{gettemplates}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{gettemplates(const Pattern \&pattern, unsigned int occurrencethreshold=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ {\bf t\+\_\+relationmap} {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::gettemplates (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern} \&}]{pattern, }
\item[{unsigned int}]{occurrencethreshold = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_acbf5086ccea0a356aff9817647192b33}
Returns all skipgrams and flexgrams in the model that are an abstraction of the specified pattern. \hyperlink{classPattern}{Pattern} itself may be a skipgram too. An optional occurrence threshold may be used to filter. \begin{DoxyReturn}{Returns}
a relation map 
\end{DoxyReturn}
\hypertarget{classIndexedPatternModel_a4fb359f3059ee9689494fd053ce4adba}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!info@{info}}
\index{info@{info}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{info(std\+::ostream $\ast$\+O\+U\+T)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::info (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{O\+U\+T}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_a4fb359f3059ee9689494fd053ce4adba}
Output information about the model to the output stream, includes some statistics and technical details such as space requirements. \hypertarget{classIndexedPatternModel_a59db87907763ca11f553eb138c3a8425}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!npmi@{npmi}}
\index{npmi@{npmi}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{npmi(const Pattern\+Pointer \&key1, const Pattern\+Pointer \&key2, int jointcount)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ double {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::npmi (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{key1, }
\item[{const {\bf Pattern\+Pointer} \&}]{key2, }
\item[{int}]{jointcount}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_a59db87907763ca11f553eb138c3a8425}
Compute normalised pointwise mutual information given two patterns and their joint occurrence count. \hypertarget{classIndexedPatternModel_a7029fb323b1ef87bcf821050e78e5cd9}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!outputcooc@{outputcooc}}
\index{outputcooc@{outputcooc}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{outputcooc(std\+::ostream $\ast$\+O\+U\+T, Class\+Decoder \&classdecoder, double threshold)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::outputcooc (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{O\+U\+T, }
\item[{{\bf Class\+Decoder} \&}]{classdecoder, }
\item[{double}]{threshold}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_a7029fb323b1ef87bcf821050e78e5cd9}
Compute and output co-\/occurrence relations as joint occurrence count 
\begin{DoxyParams}{Parameters}
{\em threshold} & Normalised Pointwise Mutual Information threshold \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classPatternModel_ab9876cdcaeffbd2c04350e73b2be0bc3}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.

\hypertarget{classIndexedPatternModel_a17e2553ba9520ac45bac77f0948b1b21}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!outputcooc\+\_\+npmi@{outputcooc\+\_\+npmi}}
\index{outputcooc\+\_\+npmi@{outputcooc\+\_\+npmi}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{outputcooc\+\_\+npmi(std\+::ostream $\ast$\+O\+U\+T, Class\+Decoder \&classdecoder, double threshold)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::outputcooc\+\_\+npmi (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{O\+U\+T, }
\item[{{\bf Class\+Decoder} \&}]{classdecoder, }
\item[{double}]{threshold}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_a17e2553ba9520ac45bac77f0948b1b21}
Compute and output co-\/occurrence relations as Normalised Pointwise Mutual Information 
\begin{DoxyParams}{Parameters}
{\em threshold} & Normalised Pointwise Mutual Information threshold \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classPatternModel_aef998f743259e8d85d48b81eede5bd00}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.

\hypertarget{classIndexedPatternModel_aa666827ba3837abe86bf538782abdd96}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!outputrelations@{outputrelations}}
\index{outputrelations@{outputrelations}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{outputrelations(const Pattern\+Pointer \&pattern, t\+\_\+relationmap \&relations, Class\+Decoder \&classdecoder, std\+::ostream $\ast$\+O\+U\+T, const std\+::string label=""R\+E\+L\+A\+T\+E\+D-\/\+T\+O"")}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::outputrelations (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{{\bf t\+\_\+relationmap} \&}]{relations, }
\item[{{\bf Class\+Decoder} \&}]{classdecoder, }
\item[{std\+::ostream $\ast$}]{O\+U\+T, }
\item[{const std\+::string}]{label = {\ttfamily \char`\"{}RELATED-\/TO\char`\"{}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_aa666827ba3837abe86bf538782abdd96}
Output the specified relation map for the specified pattern to output stream. Low-\/level function. 
\begin{DoxyParams}{Parameters}
{\em pattern} & The pattern \\
\hline
{\em relations} & A relation map \\
\hline
{\em classdecoder} & A class decoder \\
\hline
{\em O\+U\+T} & The output stream \\
\hline
{\em label} & A label to insert between relations (defaults to\+: R\+E\+L\+A\+T\+E\+D-\/\+T\+O) \\
\hline
\end{DoxyParams}
\hypertarget{classIndexedPatternModel_a09b446b208f4a013f07828f8650c278e}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!outputrelations@{outputrelations}}
\index{outputrelations@{outputrelations}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{outputrelations(const Pattern\+Pointer \&pattern, Class\+Decoder \&classdecoder, std\+::ostream $\ast$\+O\+U\+T, bool outputheader=true)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::outputrelations (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{{\bf Class\+Decoder} \&}]{classdecoder, }
\item[{std\+::ostream $\ast$}]{O\+U\+T, }
\item[{bool}]{outputheader = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_a09b446b208f4a013f07828f8650c278e}
Compute and output all possible relations for a given pattern. High-\/level function. 
\begin{DoxyParams}{Parameters}
{\em pattern} & The pattern \\
\hline
{\em classdecoder} & A class decoder \\
\hline
{\em O\+U\+T} & The output stream \\
\hline
{\em outputheader} & Output a header (default\+: true) \\
\hline
\end{DoxyParams}
\hypertarget{classIndexedPatternModel_a14708a972c0c3297421b370bbdc75b65}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!postread@{postread}}
\index{postread@{postread}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{postread(const Pattern\+Model\+Options options)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::postread (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Model\+Options}}]{options}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_a14708a972c0c3297421b370bbdc75b65}


Reimplemented from \hyperlink{classPatternModel_a0e475078b9e3501c7ae8fc5d5683f671}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.

\hypertarget{classIndexedPatternModel_a5314a6b877df1447d28128fb9d9e67b3}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!posttrain@{posttrain}}
\index{posttrain@{posttrain}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{posttrain(const Pattern\+Model\+Options options)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::posttrain (
\begin{DoxyParamCaption}
\item[{const {\bf Pattern\+Model\+Options}}]{options}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_a5314a6b877df1447d28128fb9d9e67b3}


Reimplemented from \hyperlink{classPatternModel_a4dc600e5f375d412917c30c62265d6e8}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.

\hypertarget{classIndexedPatternModel_ab139c59cacc6cabe5f1004c741feb9f6}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!print@{print}}
\index{print@{print}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{print(std\+::ostream $\ast$out, Class\+Decoder \&decoder)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::print (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{out, }
\item[{{\bf Class\+Decoder} \&}]{decoder}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_ab139c59cacc6cabe5f1004c741feb9f6}
Print the contents of the pattern model, i.\+e. all patterns and associated counts, to the output stream. 
\begin{DoxyParams}{Parameters}
{\em out} & The output stream \\
\hline
{\em decoder} & The class decoder to use \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classPatternModel_aba01edce114df253215e905e63acbee1}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.

\hypertarget{classIndexedPatternModel_a3a2833e7343e15d7079ca40fe0d13652}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!print@{print}}
\index{print@{print}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{print(std\+::ostream $\ast$out, Class\+Decoder \&decoder, const Pattern\+Pointer \&pattern, bool endline=true)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::print (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{out, }
\item[{{\bf Class\+Decoder} \&}]{decoder, }
\item[{const {\bf Pattern\+Pointer} \&}]{pattern, }
\item[{bool}]{endline = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_a3a2833e7343e15d7079ca40fe0d13652}
\hypertarget{classIndexedPatternModel_ad477f945c83813cc0c3766737be54214}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!prunerelations@{prunerelations}}
\index{prunerelations@{prunerelations}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{prunerelations(t\+\_\+relationmap \&relations, unsigned int occurrencethreshold)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::prunerelations (
\begin{DoxyParamCaption}
\item[{{\bf t\+\_\+relationmap} \&}]{relations, }
\item[{unsigned int}]{occurrencethreshold}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_ad477f945c83813cc0c3766737be54214}
Given a relation map, prune relations below the specified occurrence threshold 
\begin{DoxyParams}{Parameters}
{\em relations} & The relationmap to manipulate \\
\hline
{\em occurrencethreshold} & The occurrence threshold \\
\hline
\end{DoxyParams}
\hypertarget{classIndexedPatternModel_a812c9e92fbf801545c1596cc5f4cf080}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!pruneskipgrams@{pruneskipgrams}}
\index{pruneskipgrams@{pruneskipgrams}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{pruneskipgrams(int threshold, int minskiptypes, int \+\_\+n=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ int {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::pruneskipgrams (
\begin{DoxyParamCaption}
\item[{int}]{threshold, }
\item[{int}]{minskiptypes, }
\item[{int}]{\+\_\+n = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classIndexedPatternModel_a812c9e92fbf801545c1596cc5f4cf080}
Prune skipgrams based on an occurrence threshold, and a skiptype threshold. The latter enforces that at least the specified number of distinct patterns must fit in the gap for the skipgram to be retained. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+n} & Set to any value above zero to only include patterns of the specified length. \\
\hline
\end{DoxyParams}
\hypertarget{classIndexedPatternModel_ad416961213cc18e4c4a3d9f9e71d445e}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!train@{train}}
\index{train@{train}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{train(std\+::istream $\ast$in, Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainbymodel=\+N\+U\+L\+L, bool continued=false, uint32\+\_\+t firstsentence=1, bool ignoreerrors=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::train (
\begin{DoxyParamCaption}
\item[{std\+::istream $\ast$}]{in, }
\item[{{\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainbymodel = {\ttfamily NULL}, }
\item[{bool}]{continued = {\ttfamily false}, }
\item[{uint32\+\_\+t}]{firstsentence = {\ttfamily 1}, }
\item[{bool}]{ignoreerrors = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_ad416961213cc18e4c4a3d9f9e71d445e}
Train a pattern model on corpus data (given an input stream) 
\begin{DoxyParams}{Parameters}
{\em in} & The input stream of the corpus data ($\ast$.colibri.\+dat), may be N\+U\+L\+L if a reverse index is loaded. \\
\hline
{\em options} & Options for training \\
\hline
{\em constrainbymodel} & Pointer to another pattern model which should be used to constrain the training of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
{\em continued} & Continued training on the same corpus data \\
\hline
{\em firstsentence} & First sentence index, useful for augmenting a model with another corpus (keep continued set to false in this case), defaults to 1 \\
\hline
{\em ignoreerrors} & Try to ignore errors (use for debug only) \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classPatternModel_a0631a4a6c003e4aa18ec82ad4748ef76}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.

\hypertarget{classIndexedPatternModel_a22f094eef93f4afbfed7697724975220}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!train@{train}}
\index{train@{train}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{train(const std\+::string \&filename, Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainbymodel=\+N\+U\+L\+L, bool continued=false, uint32\+\_\+t firstsentence=1, bool ignoreerrors=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::train (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{filename, }
\item[{{\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainbymodel = {\ttfamily NULL}, }
\item[{bool}]{continued = {\ttfamily false}, }
\item[{uint32\+\_\+t}]{firstsentence = {\ttfamily 1}, }
\item[{bool}]{ignoreerrors = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_a22f094eef93f4afbfed7697724975220}
Train a pattern model on corpus data 
\begin{DoxyParams}{Parameters}
{\em filename} & The filename of the corpus data ($\ast$.colibri.\+dat) \\
\hline
{\em options} & Options for training \\
\hline
{\em constrainbymodel} & Pointer to another pattern model which should be used to constrain the training of this one, only patterns also occurring in the other model will be included. Defaults to N\+U\+L\+L (no constraining) \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classPatternModel_a143ea1e2907a1efd0550f52a51e55539}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.

\hypertarget{classIndexedPatternModel_a0bd2f75e24f53a70170468bb1dc4caaf}{}\index{Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}!trainskipgrams@{trainskipgrams}}
\index{trainskipgrams@{trainskipgrams}!Indexed\+Pattern\+Model@{Indexed\+Pattern\+Model}}
\subsubsection[{trainskipgrams(\+Pattern\+Model\+Options options, Pattern\+Model\+Interface $\ast$constrainbymodel=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Map\+Type = Pattern\+Map$<$\+Indexed\+Data,\+Indexed\+Data\+Handler$>$, class Pattern\+Type = Pattern$>$ virtual void {\bf Indexed\+Pattern\+Model}$<$ Map\+Type, {\bf Pattern\+Type} $>$\+::trainskipgrams (
\begin{DoxyParamCaption}
\item[{{\bf Pattern\+Model\+Options}}]{options, }
\item[{{\bf Pattern\+Model\+Interface} $\ast$}]{constrainbymodel = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classIndexedPatternModel_a0bd2f75e24f53a70170468bb1dc4caaf}
Train skipgrams, for indexed models only 
\begin{DoxyParams}{Parameters}
{\em options} & \hyperlink{classPattern}{Pattern} model options \\
\hline
{\em constrainbymodel} & Pointer to a pattern model to use as contraint\+: only include skipgrams that occur in the constraint model (default\+: N\+U\+L\+L) \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classPatternModel_ad18615c995fc3a6336bfed45fe21f5ac}{Pattern\+Model$<$ Indexed\+Data, Indexed\+Data\+Handler, Map\+Type, Pattern\+Type $>$}.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/\hyperlink{patternmodel_8h}{patternmodel.\+h}\end{DoxyCompactItemize}
