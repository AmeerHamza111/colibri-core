<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Colibri Core: IndexedPatternModel&lt; MapType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Colibri Core
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classIndexedPatternModel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IndexedPatternModel&lt; MapType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An indexed model mapping patterns to values, high-level interface. This is a specialised subclass of <a class="el" href="classPatternMap.html" title="A pattern map storing patterns and their values in a hash map (unordered_map). ">PatternMap</a>.  
 <a href="classIndexedPatternModel.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="patternmodel_8h_source.html">patternmodel.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IndexedPatternModel&lt; MapType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classIndexedPatternModel.png" usemap="#IndexedPatternModel&lt; MapType &gt;_map" alt=""/>
  <map id="IndexedPatternModel&lt; MapType &gt;_map" name="IndexedPatternModel&lt; MapType &gt;_map">
<area href="classPatternModel.html" alt="PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;" shape="rect" coords="188,112,555,136"/>
<area href="classPatternModelInterface.html" title="Basic read-only interface for pattern models, abstract base class. " alt="PatternModelInterface" shape="rect" coords="377,56,744,80"/>
<area href="classPatternStoreInterface.html" title="Limited virtual interface to pattern stores. " alt="PatternStoreInterface" shape="rect" coords="188,0,555,24"/>
<area href="classPatternStoreInterface.html" title="Limited virtual interface to pattern stores. " alt="PatternStoreInterface" shape="rect" coords="565,0,932,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0d53765f0498911c976744cc3670ff72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a0d53765f0498911c976744cc3670ff72">buildreverseindex</a> (const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options)</td></tr>
<tr class="separator:a0d53765f0498911c976744cc3670ff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fbb7d1f40210bda30bee3d5577546a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#af2fbb7d1f40210bda30bee3d5577546a">IndexedPatternModel</a> (<a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *corpus=NULL)</td></tr>
<tr class="separator:af2fbb7d1f40210bda30bee3d5577546a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983367ac09e96735a2075a1f780d1de4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a983367ac09e96735a2075a1f780d1de4">IndexedPatternModel</a> (std::istream *f, const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainmodel=NULL, <a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *corpus=NULL)</td></tr>
<tr class="separator:a983367ac09e96735a2075a1f780d1de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d49b0f8aea957fc80e7e8d7b4dd5ba8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a8d49b0f8aea957fc80e7e8d7b4dd5ba8">IndexedPatternModel</a> (const std::string filename, const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainmodel=NULL, <a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *corpus=NULL)</td></tr>
<tr class="separator:a8d49b0f8aea957fc80e7e8d7b4dd5ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc89a95b7ef0874ab5d763d0c453e79"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#aadc89a95b7ef0874ab5d763d0c453e79">~IndexedPatternModel</a> ()</td></tr>
<tr class="separator:aadc89a95b7ef0874ab5d763d0c453e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb6b2bce5dc4fcdd9f8ec9f723d0f5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#adeb6b2bce5dc4fcdd9f8ec9f723d0f5b">getmodeltype</a> () const </td></tr>
<tr class="separator:adeb6b2bce5dc4fcdd9f8ec9f723d0f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabaad88e64edd1c4762a56c86d1bae4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#adabaad88e64edd1c4762a56c86d1bae4">getmodelversion</a> () const </td></tr>
<tr class="separator:adabaad88e64edd1c4762a56c86d1bae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41367fc32c9fa72d1a88e60d749015a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a41367fc32c9fa72d1a88e60d749015a5">add</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, <a class="el" href="classIndexedData.html">IndexedData</a> *value, const <a class="el" href="classIndexReference.html">IndexReference</a> &amp;ref)</td></tr>
<tr class="separator:a41367fc32c9fa72d1a88e60d749015a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e3a00515a9ad419b4a2f820278c5f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a83e3a00515a9ad419b4a2f820278c5f7">add</a> (const <a class="el" href="classPatternPointer.html">PatternPointer</a> &amp;patternpointer, <a class="el" href="classIndexedData.html">IndexedData</a> *value, const <a class="el" href="classIndexReference.html">IndexReference</a> &amp;ref)</td></tr>
<tr class="separator:a83e3a00515a9ad419b4a2f820278c5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee41056c7235bf03573e6532cd5efce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexedData.html">IndexedData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a1ee41056c7235bf03573e6532cd5efce">getdata</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, bool makeifnew=false)</td></tr>
<tr class="separator:a1ee41056c7235bf03573e6532cd5efce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9311529a1123f602720b9e95f3f89236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexedData.html">IndexedData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a9311529a1123f602720b9e95f3f89236">getdata</a> (const <a class="el" href="classPatternPointer.html">PatternPointer</a> &amp;patternpointer, bool makeifnew=false)</td></tr>
<tr class="separator:a9311529a1123f602720b9e95f3f89236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fade10459a7699b856c8cb621789f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a64fade10459a7699b856c8cb621789f9">info</a> (std::ostream *OUT)</td></tr>
<tr class="separator:a64fade10459a7699b856c8cb621789f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5f41aa99e3b93a9a816e9c21b9b790"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a4a5f41aa99e3b93a9a816e9c21b9b790">print</a> (std::ostream *out, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;decoder)</td></tr>
<tr class="separator:a4a5f41aa99e3b93a9a816e9c21b9b790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4218c952b051b523d8d5a31c5c00fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#aed4218c952b051b523d8d5a31c5c00fb">print</a> (std::ostream *out, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;decoder, const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, bool endline=true)</td></tr>
<tr class="separator:aed4218c952b051b523d8d5a31c5c00fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0b5ec19f8b76b875dbef07ca0cb398"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#acf0b5ec19f8b76b875dbef07ca0cb398">trainskipgrams</a> (<a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainbymodel=NULL)</td></tr>
<tr class="separator:acf0b5ec19f8b76b875dbef07ca0cb398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205e5f3a0019a9948064084c0b92a7ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPattern.html">Pattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a205e5f3a0019a9948064084c0b92a7ce">getpatternfromtoken</a> (<a class="el" href="classIndexReference.html">IndexReference</a> ref)</td></tr>
<tr class="separator:a205e5f3a0019a9948064084c0b92a7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2478fc9fd1eabfc616c1692fc2a58d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#ac2478fc9fd1eabfc616c1692fc2a58d9">getskipcontent</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="separator:ac2478fc9fd1eabfc616c1692fc2a58d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0509989bf6bcb7d09dbc0e5c9e3dc84a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a0509989bf6bcb7d09dbc0e5c9e3dc84a">prunerelations</a> (<a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> &amp;relations, unsigned int occurrencethreshold)</td></tr>
<tr class="separator:a0509989bf6bcb7d09dbc0e5c9e3dc84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951ae48d5f211af94a3c63102f708356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a951ae48d5f211af94a3c63102f708356">gettemplates</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, unsigned int occurrencethreshold=0)</td></tr>
<tr class="separator:a951ae48d5f211af94a3c63102f708356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2942d0920ce1e646cb733c0c84fdd0d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a2942d0920ce1e646cb733c0c84fdd0d7">getinstances</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, unsigned int occurrencethreshold=0)</td></tr>
<tr class="separator:a2942d0920ce1e646cb733c0c84fdd0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785f4b6ef4229843b90ba895957a1b56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a785f4b6ef4229843b90ba895957a1b56">getsubchildren</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int <a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a>=0)</td></tr>
<tr class="separator:a785f4b6ef4229843b90ba895957a1b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2ec73f5bece8595e6f6ab4f180ce75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#aed2ec73f5bece8595e6f6ab4f180ce75">getsubparents</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int <a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a>=0)</td></tr>
<tr class="separator:aed2ec73f5bece8595e6f6ab4f180ce75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3909fc9e28191fa2f47be30b3dd99e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a7d3909fc9e28191fa2f47be30b3dd99e">getleftneighbours</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int <a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a>=0, unsigned int cutoff=0)</td></tr>
<tr class="separator:a7d3909fc9e28191fa2f47be30b3dd99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d837b1f82f65b18ab6a7fc3ba2b15c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#ab2d837b1f82f65b18ab6a7fc3ba2b15c">getrightneighbours</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int <a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a>=0, unsigned int cutoff=0)</td></tr>
<tr class="separator:ab2d837b1f82f65b18ab6a7fc3ba2b15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df4f0e3a55dd00c0fe00fc3841f66ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a0df4f0e3a55dd00c0fe00fc3841f66ed">pruneskipgrams</a> (int threshold, int minskiptypes, int _n=0)</td></tr>
<tr class="separator:a0df4f0e3a55dd00c0fe00fc3841f66ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf70c3536f4869b3e8330289f7409bf5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#acf70c3536f4869b3e8330289f7409bf5">computecoveragestats</a> ()</td></tr>
<tr class="separator:acf70c3536f4869b3e8330289f7409bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d8258d41c372a17b91f8be08f3f305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#ad0d8258d41c372a17b91f8be08f3f305">getrightcooc</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int <a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a>=0, <a class="el" href="classIndexedData.html">IndexedData</a> *matches=NULL)</td></tr>
<tr class="separator:ad0d8258d41c372a17b91f8be08f3f305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9292a132bac92267f26eeae00fd8ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a9f9292a132bac92267f26eeae00fd8ee">getleftcooc</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int <a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a>=0)</td></tr>
<tr class="separator:a9f9292a132bac92267f26eeae00fd8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6caa3a7aa9ce15087b98dd8d2b1c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#aaa6caa3a7aa9ce15087b98dd8d2b1c4b">getcooc</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, unsigned int occurrencethreshold=0, int category=0, unsigned int <a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a>=0, bool ordersignificant=false)</td></tr>
<tr class="separator:aaa6caa3a7aa9ce15087b98dd8d2b1c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c138c720ca2724457f2786626478d3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a03c138c720ca2724457f2786626478d3">npmi</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;key1, const <a class="el" href="classPattern.html">Pattern</a> &amp;key2, int jointcount)</td></tr>
<tr class="separator:a03c138c720ca2724457f2786626478d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001c634d095eee8883e8cd8fd24846d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a001c634d095eee8883e8cd8fd24846d8">outputrelations</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> &amp;relations, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;classdecoder, std::ostream *OUT, const std::string label=&quot;RELATED-TO&quot;)</td></tr>
<tr class="separator:a001c634d095eee8883e8cd8fd24846d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe968ebfe686a774ae70c810d2d9cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#abfe968ebfe686a774ae70c810d2d9cc3">outputrelations</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;classdecoder, std::ostream *OUT, bool outputheader=true)</td></tr>
<tr class="separator:abfe968ebfe686a774ae70c810d2d9cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07346735ccdee4d7e42043e95d1bc2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#ab07346735ccdee4d7e42043e95d1bc2e">computenpmi</a> (std::map&lt; <a class="el" href="classPattern.html">Pattern</a>, <a class="el" href="patternmodel_8h.html#ae13b52c8cf777358f19da17c90c7dac0">t_relationmap_double</a> &gt; &amp;coocmap, double threshold, bool right=true, bool left=true)</td></tr>
<tr class="separator:ab07346735ccdee4d7e42043e95d1bc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62d20c9507dee1edd2f133cf3de2a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#ae62d20c9507dee1edd2f133cf3de2a5f">computecooc</a> (std::map&lt; <a class="el" href="classPattern.html">Pattern</a>, <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> &gt; &amp;coocmap, int threshold, bool right=true, bool left=true)</td></tr>
<tr class="separator:ae62d20c9507dee1edd2f133cf3de2a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b8e1405429aa869501f9117664b0d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#ad3b8e1405429aa869501f9117664b0d5">computeflexgrams_fromskipgrams</a> ()</td></tr>
<tr class="separator:ad3b8e1405429aa869501f9117664b0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1a24a490466115aad4cf09058337ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a2d1a24a490466115aad4cf09058337ec">computeflexgrams_fromcooc</a> (double threshold)</td></tr>
<tr class="separator:a2d1a24a490466115aad4cf09058337ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8d1bf4017173e8214cfd37bab576c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a4e8d1bf4017173e8214cfd37bab576c1">outputcooc_npmi</a> (std::ostream *OUT, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;classdecoder, double threshold)</td></tr>
<tr class="separator:a4e8d1bf4017173e8214cfd37bab576c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab1e2d6bf0a8aeed25a39c306e51c34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a6ab1e2d6bf0a8aeed25a39c306e51c34">outputcooc</a> (std::ostream *OUT, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;classdecoder, double threshold)</td></tr>
<tr class="separator:a6ab1e2d6bf0a8aeed25a39c306e51c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd312da331baffd69a7944084cc0e4f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#abd312da331baffd69a7944084cc0e4f6">flexgramsize</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, <a class="el" href="classIndexReference.html">IndexReference</a> begin)</td></tr>
<tr class="separator:abd312da331baffd69a7944084cc0e4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPatternModel"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPatternModel')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPatternModel.html">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a></td></tr>
<tr class="memitem:ade6d8f3c3bae062c06881d96809ea4ff inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ade6d8f3c3bae062c06881d96809ea4ff">PatternModel</a> (<a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *corpus=NULL)</td></tr>
<tr class="separator:ade6d8f3c3bae062c06881d96809ea4ff inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1e66e0893ead99e75013cb578cd54a inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a9f1e66e0893ead99e75013cb578cd54a">PatternModel</a> (std::istream *f, <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainmodel=NULL, <a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *corpus=NULL)</td></tr>
<tr class="separator:a9f1e66e0893ead99e75013cb578cd54a inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd68d5b590a3b477f7fdee2921755a44 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#afd68d5b590a3b477f7fdee2921755a44">PatternModel</a> (const std::string filename, const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainmodel=NULL, <a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *corpus=NULL)</td></tr>
<tr class="separator:afd68d5b590a3b477f7fdee2921755a44 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f387acaf981af9962195bd05b3e7e2 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a> () const</td></tr>
<tr class="separator:a25f387acaf981af9962195bd05b3e7e2 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577eb056f583b4efc943ac4e7a581b1b inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a577eb056f583b4efc943ac4e7a581b1b">has</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern) const</td></tr>
<tr class="separator:a577eb056f583b4efc943ac4e7a581b1b inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94a590e3c5eacde04cb55430198acfa inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#af94a590e3c5eacde04cb55430198acfa">has</a> (const <a class="el" href="classPatternPointer.html">PatternPointer</a> &amp;pattern) const</td></tr>
<tr class="separator:af94a590e3c5eacde04cb55430198acfa inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26de418f6998cac0f484a958597afccc inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a26de418f6998cac0f484a958597afccc">load</a> (std::string filename, const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainmodel=NULL)</td></tr>
<tr class="separator:a26de418f6998cac0f484a958597afccc inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfb81964c7a6eb13d846dc11d2cc667 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#acbfb81964c7a6eb13d846dc11d2cc667">load</a> (std::istream *f, const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainmodel=NULL)</td></tr>
<tr class="separator:acbfb81964c7a6eb13d846dc11d2cc667 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837bdbf478b7ea8a51ad674418926175 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a837bdbf478b7ea8a51ad674418926175">getinterface</a> ()</td></tr>
<tr class="separator:a837bdbf478b7ea8a51ad674418926175 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e8a9a955f8da64abe95179482a6b55 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ac1e8a9a955f8da64abe95179482a6b55">train</a> (std::istream *in, <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainbymodel=NULL)</td></tr>
<tr class="separator:ac1e8a9a955f8da64abe95179482a6b55 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2390acee4c9aeecf1bce2d0b312bb4c inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ac2390acee4c9aeecf1bce2d0b312bb4c">train</a> (const std::string filename, const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainbymodel=NULL)</td></tr>
<tr class="separator:ac2390acee4c9aeecf1bce2d0b312bb4c inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a7898c399c670792af12f509adcd28 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aa8a7898c399c670792af12f509adcd28">computeskipgrams</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, int mintokens=2, const <a class="el" href="classIndexReference.html">IndexReference</a> *singleref=NULL, const <a class="el" href="classIndexedData.html">IndexedData</a> *multiplerefs=NULL, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainbymodel=NULL, std::vector&lt; <a class="el" href="classPattern.html">Pattern</a> &gt; *targetcontainer=NULL, const bool exhaustive=false, const bool DEBUG=false)</td></tr>
<tr class="separator:aa8a7898c399c670792af12f509adcd28 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b3338b6e79a3dbc9b5f95cb0171494 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a00b3338b6e79a3dbc9b5f95cb0171494">computeskipgrams</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> &amp;options, const <a class="el" href="classIndexReference.html">IndexReference</a> *singleref=NULL, const <a class="el" href="classIndexedData.html">IndexedData</a> *multiplerefs=NULL, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainbymodel=NULL, const bool exhaustive=false)</td></tr>
<tr class="separator:a00b3338b6e79a3dbc9b5f95cb0171494 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aa18a4d9e7554a3c798872e915e8a0 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classPattern.html">Pattern</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aa4aa18a4d9e7554a3c798872e915e8a0">findskipgrams</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, unsigned int occurrencethreshold=1)</td></tr>
<tr class="separator:aa4aa18a4d9e7554a3c798872e915e8a0 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fb390761ae0fc47e3a48621c94698b inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a21fb390761ae0fc47e3a48621c94698b">test</a> (MapType &amp;target, std::istream *in)</td></tr>
<tr class="separator:a21fb390761ae0fc47e3a48621c94698b inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3456e788caacd51fe3c7fb8fdf547723 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a3456e788caacd51fe3c7fb8fdf547723">write</a> (std::ostream *out)</td></tr>
<tr class="separator:a3456e788caacd51fe3c7fb8fdf547723 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73654320cd52e691fd7df037cf3ff013 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a73654320cd52e691fd7df037cf3ff013">write</a> (const std::string filename)</td></tr>
<tr class="separator:a73654320cd52e691fd7df037cf3ff013 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d63c6c6ada696e3a247e25df8487ec inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ac0d63c6c6ada696e3a247e25df8487ec">maxlength</a> () const</td></tr>
<tr class="separator:ac0d63c6c6ada696e3a247e25df8487ec inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4777ec9b1e76ef3c2ccbc981dad15129 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a4777ec9b1e76ef3c2ccbc981dad15129">minlength</a> () const</td></tr>
<tr class="separator:a4777ec9b1e76ef3c2ccbc981dad15129 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5bc659abbbdd456937e85642a97d40 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a8f5bc659abbbdd456937e85642a97d40">occurrencecount</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="separator:a8f5bc659abbbdd456937e85642a97d40 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5df3d30417804589c552320add3285a inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#af5df3d30417804589c552320add3285a">types</a> ()</td></tr>
<tr class="separator:af5df3d30417804589c552320add3285a inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac99feddfa4cf1dc44090c5148e518a inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#afac99feddfa4cf1dc44090c5148e518a">tokens</a> () const</td></tr>
<tr class="separator:afac99feddfa4cf1dc44090c5148e518a inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df468e440b875af0d9321d090f87dab inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a7df468e440b875af0d9321d090f87dab">type</a> () const</td></tr>
<tr class="separator:a7df468e440b875af0d9321d090f87dab inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56c31e031bb51d47e98cc433a46556e inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#af56c31e031bb51d47e98cc433a46556e">version</a> () const</td></tr>
<tr class="separator:af56c31e031bb51d47e98cc433a46556e inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa8d87b4b2269e796d97902f3214d22 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aafa8d87b4b2269e796d97902f3214d22">output</a> (std::ostream *)</td></tr>
<tr class="separator:aafa8d87b4b2269e796d97902f3214d22 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bad2b94ec96880f3e4307d55c42e492 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a5bad2b94ec96880f3e4307d55c42e492">coveragecount</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;key)</td></tr>
<tr class="separator:a5bad2b94ec96880f3e4307d55c42e492 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07eb601afe937b144e100cd96d091d3a inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a07eb601afe937b144e100cd96d091d3a">coverage</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;key)</td></tr>
<tr class="separator:a07eb601afe937b144e100cd96d091d3a inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b37ea19d0646bff54cae15290fc884c inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPattern.html">Pattern</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a6b37ea19d0646bff54cae15290fc884c">getreverseindex</a> (const <a class="el" href="classIndexReference.html">IndexReference</a> ref, int <a class="el" href="classPatternModel.html#a8f5bc659abbbdd456937e85642a97d40">occurrencecount</a>=0, int category=0, unsigned int <a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a>=0)</td></tr>
<tr class="separator:a6b37ea19d0646bff54cae15290fc884c inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca7b37dfacef90de4e2139acb99cedb inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classIndexReference.html">IndexReference</a>, <a class="el" href="classPattern.html">Pattern</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#abca7b37dfacef90de4e2139acb99cedb">getreverseindex_bysentence</a> (int sentence)</td></tr>
<tr class="separator:abca7b37dfacef90de4e2139acb99cedb inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c49738d4296c9dde3ee2796d6b66814 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classIndexReference.html">IndexReference</a>, <a class="el" href="classPattern.html">Pattern</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a0c49738d4296c9dde3ee2796d6b66814">getreverseindex_right</a> (const <a class="el" href="classIndexReference.html">IndexReference</a> ref)</td></tr>
<tr class="separator:a0c49738d4296c9dde3ee2796d6b66814 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec29a383939fa71f61edfea80ea1b2d0 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classIndexReference.html">IndexReference</a>, <a class="el" href="classPattern.html">Pattern</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aec29a383939fa71f61edfea80ea1b2d0">getreverseindex_left</a> (const <a class="el" href="classIndexReference.html">IndexReference</a> ref)</td></tr>
<tr class="separator:aec29a383939fa71f61edfea80ea1b2d0 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b0d7452c19849930d6b3d19888130d inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a06b0d7452c19849930d6b3d19888130d">computestats</a> ()</td></tr>
<tr class="separator:a06b0d7452c19849930d6b3d19888130d inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad5fd4ad8ed72160938ca9a30d26201 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a4ad5fd4ad8ed72160938ca9a30d26201">totaloccurrencesingroup</a> (int category, int n)</td></tr>
<tr class="separator:a4ad5fd4ad8ed72160938ca9a30d26201 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fd6f8f536a802d6653665aa4d48cbf inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a38fd6f8f536a802d6653665aa4d48cbf">totalpatternsingroup</a> (int category, int n)</td></tr>
<tr class="separator:a38fd6f8f536a802d6653665aa4d48cbf inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23de99349652ec0774db5d09593bd255 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a23de99349652ec0774db5d09593bd255">totalwordtypesingroup</a> (int category, int n)</td></tr>
<tr class="separator:a23de99349652ec0774db5d09593bd255 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5f43e06e2262fc4387729fc6265050 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aaa5f43e06e2262fc4387729fc6265050">totaltokensingroup</a> (int category, int n)</td></tr>
<tr class="separator:aaa5f43e06e2262fc4387729fc6265050 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0927686caf05d2e1accff6e158a75188 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a0927686caf05d2e1accff6e158a75188">frequency</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="separator:a0927686caf05d2e1accff6e158a75188 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3698c1c47789b2fb2eae65d96ed4e3ab inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a3698c1c47789b2fb2eae65d96ed4e3ab">prune</a> (int threshold, int _n=0)</td></tr>
<tr class="separator:a3698c1c47789b2fb2eae65d96ed4e3ab inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30da80bd942ab1bac95ac9945f465702 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a30da80bd942ab1bac95ac9945f465702">pruneskipgrams</a> (unsigned int threshold, int minskiptypes=2, int _n=0)</td></tr>
<tr class="separator:a30da80bd942ab1bac95ac9945f465702 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4429ca9cb19f12e4b0bb7b8cb0e6fe7 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ab4429ca9cb19f12e4b0bb7b8cb0e6fe7">prunenotinset</a> (const std::unordered_set&lt; <a class="el" href="classPattern.html">Pattern</a> &gt; &amp;s, int _n)</td></tr>
<tr class="separator:ab4429ca9cb19f12e4b0bb7b8cb0e6fe7 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787ccf34c969a5e14aa2e1bdcb164ee7 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a787ccf34c969a5e14aa2e1bdcb164ee7">prunebymodel</a> (<a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType2, ValueHandler2, MapType2 &gt; &amp;secondmodel)</td></tr>
<tr class="separator:a787ccf34c969a5e14aa2e1bdcb164ee7 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d110daa1691b266ad325b1a2f7a842 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classPattern.html">Pattern</a>, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ad5d110daa1691b266ad325b1a2f7a842">getpatterns</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="separator:ad5d110daa1691b266ad325b1a2f7a842 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d23339ceb528e9cb7a02640bce392c inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aa5d23339ceb528e9cb7a02640bce392c">printreverseindex</a> (std::ostream *out, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;decoder)</td></tr>
<tr class="separator:aa5d23339ceb528e9cb7a02640bce392c inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b0bf9471b82119000b38c620ffc21e inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a30b0bf9471b82119000b38c620ffc21e">printmodel</a> (std::ostream *out, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;decoder)</td></tr>
<tr class="separator:a30b0bf9471b82119000b38c620ffc21e inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa497ee9bd6b1abe6ab4451fbf7272f4 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aaa497ee9bd6b1abe6ab4451fbf7272f4">printpattern</a> (std::ostream *out, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;decoder, const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, bool endline=true)</td></tr>
<tr class="separator:aaa497ee9bd6b1abe6ab4451fbf7272f4 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c97f76cca2ba56099eb1559a7b0ddd inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a72c97f76cca2ba56099eb1559a7b0ddd">histogram</a> (std::map&lt; unsigned int, unsigned int &gt; &amp;hist, unsigned int threshold=0, unsigned int cap=0, int category=0, unsigned int <a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a>=0)</td></tr>
<tr class="separator:a72c97f76cca2ba56099eb1559a7b0ddd inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edf12738542d8d8b0cc9aa06b5a69b2 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a9edf12738542d8d8b0cc9aa06b5a69b2">histogram</a> (std::ostream *OUT, unsigned int threshold=0, unsigned int cap=0, int category=0, unsigned int <a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a>=0)</td></tr>
<tr class="separator:a9edf12738542d8d8b0cc9aa06b5a69b2 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4c12ee56b5ae88f4a5b140ac6a6a0a inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a1e4c12ee56b5ae88f4a5b140ac6a6a0a">topthreshold</a> (int amount, int category=0, int <a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a>=0)</td></tr>
<tr class="separator:a1e4c12ee56b5ae88f4a5b140ac6a6a0a inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231e5e4c9ed49764b24718e4269b4256 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a231e5e4c9ed49764b24718e4269b4256">info</a> (std::ostream *OUT)</td></tr>
<tr class="separator:a231e5e4c9ed49764b24718e4269b4256 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8c647241c7ec1a80e088b13e232a06 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aee8c647241c7ec1a80e088b13e232a06">report</a> (std::ostream *OUT)</td></tr>
<tr class="separator:aee8c647241c7ec1a80e088b13e232a06 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8881489a5a99215499809c6dcbe704e9 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPatternSet.html">PatternSet</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a8881489a5a99215499809c6dcbe704e9">extractset</a> (int <a class="el" href="classPatternModel.html#a4777ec9b1e76ef3c2ccbc981dad15129">minlength</a>=1, int <a class="el" href="classPatternModel.html#ac0d63c6c6ada696e3a247e25df8487ec">maxlength</a>=1)</td></tr>
<tr class="separator:a8881489a5a99215499809c6dcbe704e9 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa350e235140e580526d381c626355b58 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aa350e235140e580526d381c626355b58">outputrelations</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;classdecoder, std::ostream *OUT)</td></tr>
<tr class="separator:aa350e235140e580526d381c626355b58 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0fa1ea8423db319dfd6f338f7b2b40 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a3b0fa1ea8423db319dfd6f338f7b2b40">getsubchildren</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, int=0, int=0, int=0)</td></tr>
<tr class="separator:a3b0fa1ea8423db319dfd6f338f7b2b40 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb7d6ef4e82a300557f2e0350209a6f inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a5fb7d6ef4e82a300557f2e0350209a6f">getsubparents</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, int=0, int=0, int=0)</td></tr>
<tr class="separator:a5fb7d6ef4e82a300557f2e0350209a6f inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997f4cfc3e65fb218097061f9d4429ca inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a997f4cfc3e65fb218097061f9d4429ca">gettemplates</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, int=0)</td></tr>
<tr class="separator:a997f4cfc3e65fb218097061f9d4429ca inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564b582aba0eedacd4b0b6f2fa693f7d inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a564b582aba0eedacd4b0b6f2fa693f7d">getinstances</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, int=0)</td></tr>
<tr class="separator:a564b582aba0eedacd4b0b6f2fa693f7d inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7593acd2798e2e77ed5cb4e75d3f67 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aea7593acd2798e2e77ed5cb4e75d3f67">getleftneighbours</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, int=0, int=0, int=0, int=0)</td></tr>
<tr class="separator:aea7593acd2798e2e77ed5cb4e75d3f67 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34484b6262acb5967de624a14e73085 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ad34484b6262acb5967de624a14e73085">getrightneighbours</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, int=0, int=0, int=0, int=0)</td></tr>
<tr class="separator:ad34484b6262acb5967de624a14e73085 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be06240959a62b03473c7a00ccebdd1 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="patternmodel_8h.html#ae13b52c8cf777358f19da17c90c7dac0">t_relationmap_double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a0be06240959a62b03473c7a00ccebdd1">getnpmi</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, double threshold)</td></tr>
<tr class="separator:a0be06240959a62b03473c7a00ccebdd1 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0a0314553ad6237838b44f14e45309 inherit pub_methods_classPatternModel"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#abc0a0314553ad6237838b44f14e45309">computeflexgrams_fromcooc</a> ()</td></tr>
<tr class="separator:abc0a0314553ad6237838b44f14e45309 inherit pub_methods_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPatternModelInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPatternModelInterface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a></td></tr>
<tr class="memitem:a1bb04234bc1225becbec941a0efaa094 inherit pub_methods_classPatternModelInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPatternStoreInterface.html">PatternStoreInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModelInterface.html#a1bb04234bc1225becbec941a0efaa094">getstoreinterface</a> ()</td></tr>
<tr class="separator:a1bb04234bc1225becbec941a0efaa094 inherit pub_methods_classPatternModelInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb04234bc1225becbec941a0efaa094 inherit pub_methods_classPatternModelInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPatternStoreInterface.html">PatternStoreInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModelInterface.html#a1bb04234bc1225becbec941a0efaa094">getstoreinterface</a> ()</td></tr>
<tr class="separator:a1bb04234bc1225becbec941a0efaa094 inherit pub_methods_classPatternModelInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a82f5f4fffea239a4f5bde4d346691f5d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a82f5f4fffea239a4f5bde4d346691f5d">postread</a> (const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options)</td></tr>
<tr class="separator:a82f5f4fffea239a4f5bde4d346691f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a39df881afb2ef2c6c4a29afe9aa6ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexedPatternModel.html#a4a39df881afb2ef2c6c4a29afe9aa6ff">posttrain</a> (const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options)</td></tr>
<tr class="separator:a4a39df881afb2ef2c6c4a29afe9aa6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classPatternModel"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classPatternModel')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classPatternModel.html">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a></td></tr>
<tr class="memitem:a8aedb15ca2b6f5e3d619c1878d5c0639 inherit pub_types_classPatternModel"><td class="memItemLeft" align="right" valign="top">typedef MapType::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a8aedb15ca2b6f5e3d619c1878d5c0639">iterator</a></td></tr>
<tr class="separator:a8aedb15ca2b6f5e3d619c1878d5c0639 inherit pub_types_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfc44c56122e8037bb634a3d66bac0a inherit pub_types_classPatternModel"><td class="memItemLeft" align="right" valign="top">typedef MapType::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aecfc44c56122e8037bb634a3d66bac0a">const_iterator</a></td></tr>
<tr class="separator:aecfc44c56122e8037bb634a3d66bac0a inherit pub_types_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classPatternModel"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classPatternModel')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classPatternModel.html">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a></td></tr>
<tr class="memitem:a17ad27133991f964ccd23bb09bf64e5a inherit pub_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a17ad27133991f964ccd23bb09bf64e5a">reverseindex</a></td></tr>
<tr class="memdesc:a17ad27133991f964ccd23bb09bf64e5a inherit pub_attribs_classPatternModel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the reverse index for this model (or NULL)  <a href="#a17ad27133991f964ccd23bb09bf64e5a">More...</a><br /></td></tr>
<tr class="separator:a17ad27133991f964ccd23bb09bf64e5a inherit pub_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1b4eec80a00ef9c6effea477cc98f4 inherit pub_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a2f1b4eec80a00ef9c6effea477cc98f4">externalreverseindex</a></td></tr>
<tr class="memdesc:a2f1b4eec80a00ef9c6effea477cc98f4 inherit pub_attribs_classPatternModel"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if reverse index was loaded externally and passed to the model (implies it won't be destroyed when the model is) //only used by <a class="el" href="classIndexedPatternModel.html" title="An indexed model mapping patterns to values, high-level interface. This is a specialised subclass of ...">IndexedPatternModel</a> but stored here to ease things for cython  <a href="#a2f1b4eec80a00ef9c6effea477cc98f4">More...</a><br /></td></tr>
<tr class="separator:a2f1b4eec80a00ef9c6effea477cc98f4 inherit pub_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9534e66035de7df26c9cd257e2faf7d1 inherit pub_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a9534e66035de7df26c9cd257e2faf7d1">hasskipgrams</a></td></tr>
<tr class="memdesc:a9534e66035de7df26c9cd257e2faf7d1 inherit pub_attribs_classPatternModel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this model have skipgrams?  <a href="#a9534e66035de7df26c9cd257e2faf7d1">More...</a><br /></td></tr>
<tr class="separator:a9534e66035de7df26c9cd257e2faf7d1 inherit pub_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classPatternModel"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classPatternModel')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classPatternModel.html">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a></td></tr>
<tr class="memitem:af28152ff3d5060e48c18423b8629d1eb inherit pro_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#af28152ff3d5060e48c18423b8629d1eb">model_type</a></td></tr>
<tr class="separator:af28152ff3d5060e48c18423b8629d1eb inherit pro_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032f1517ae658e81fa2ca3360aba62a2 inherit pro_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a032f1517ae658e81fa2ca3360aba62a2">model_version</a></td></tr>
<tr class="separator:a032f1517ae658e81fa2ca3360aba62a2 inherit pro_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4667c917fab96ae756ee61693220f44e inherit pro_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a4667c917fab96ae756ee61693220f44e">totaltokens</a></td></tr>
<tr class="memdesc:a4667c917fab96ae756ee61693220f44e inherit pro_attribs_classPatternModel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of tokens in the original corpus, so INCLUDES TOKENS NOT COVERED BY THE MODEL!  <a href="#a4667c917fab96ae756ee61693220f44e">More...</a><br /></td></tr>
<tr class="separator:a4667c917fab96ae756ee61693220f44e inherit pro_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9de224847465b75a9be436b1990cef7 inherit pro_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#af9de224847465b75a9be436b1990cef7">totaltypes</a></td></tr>
<tr class="memdesc:af9de224847465b75a9be436b1990cef7 inherit pro_attribs_classPatternModel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of unigram/word types in the original corpus, SO INCLUDING NOT COVERED BY THE MODEL!  <a href="#af9de224847465b75a9be436b1990cef7">More...</a><br /></td></tr>
<tr class="separator:af9de224847465b75a9be436b1990cef7 inherit pro_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e501edfcca21facfe0137ed5140c87 inherit pro_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ac0e501edfcca21facfe0137ed5140c87">maxn</a></td></tr>
<tr class="separator:ac0e501edfcca21facfe0137ed5140c87 inherit pro_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed492e59e656226b1c48b10c2904618 inherit pro_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#abed492e59e656226b1c48b10c2904618">minn</a></td></tr>
<tr class="separator:abed492e59e656226b1c48b10c2904618 inherit pro_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9145b11bff161df5db3bcd33300319 inherit pro_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top">std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a2f9145b11bff161df5db3bcd33300319">cache_categories</a></td></tr>
<tr class="separator:a2f9145b11bff161df5db3bcd33300319 inherit pro_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c0c93e988cce16fdeb5a8a65e878b1 inherit pro_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top">std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a18c0c93e988cce16fdeb5a8a65e878b1">cache_n</a></td></tr>
<tr class="separator:a18c0c93e988cce16fdeb5a8a65e878b1 inherit pro_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef56e648dc462352079542e9528df09 inherit pro_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::map&lt; int, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a8ef56e648dc462352079542e9528df09">cache_grouptotal</a></td></tr>
<tr class="memdesc:a8ef56e648dc462352079542e9528df09 inherit pro_attribs_classPatternModel"><td class="mdescLeft">&#160;</td><td class="mdescRight">total occurrences (used for frequency computation, within a group)  <a href="#a8ef56e648dc462352079542e9528df09">More...</a><br /></td></tr>
<tr class="separator:a8ef56e648dc462352079542e9528df09 inherit pro_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05db7c45b9368438f34dba519df3bb3e inherit pro_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::map&lt; int, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a05db7c45b9368438f34dba519df3bb3e">cache_grouptotalpatterns</a></td></tr>
<tr class="memdesc:a05db7c45b9368438f34dba519df3bb3e inherit pro_attribs_classPatternModel"><td class="mdescLeft">&#160;</td><td class="mdescRight">total distinct patterns per group  <a href="#a05db7c45b9368438f34dba519df3bb3e">More...</a><br /></td></tr>
<tr class="separator:a05db7c45b9368438f34dba519df3bb3e inherit pro_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dee966a62bacaab4d107bb4ec5050c0 inherit pro_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::map&lt; int, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a4dee966a62bacaab4d107bb4ec5050c0">cache_grouptotalwordtypes</a></td></tr>
<tr class="memdesc:a4dee966a62bacaab4d107bb4ec5050c0 inherit pro_attribs_classPatternModel"><td class="mdescLeft">&#160;</td><td class="mdescRight">total covered word types per group  <a href="#a4dee966a62bacaab4d107bb4ec5050c0">More...</a><br /></td></tr>
<tr class="separator:a4dee966a62bacaab4d107bb4ec5050c0 inherit pro_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbf8c45dfa1993d1a9dd262b2b30783 inherit pro_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::map&lt; int, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aebbf8c45dfa1993d1a9dd262b2b30783">cache_grouptotaltokens</a></td></tr>
<tr class="memdesc:aebbf8c45dfa1993d1a9dd262b2b30783 inherit pro_attribs_classPatternModel"><td class="mdescLeft">&#160;</td><td class="mdescRight">total covered tokens per group  <a href="#aebbf8c45dfa1993d1a9dd262b2b30783">More...</a><br /></td></tr>
<tr class="separator:aebbf8c45dfa1993d1a9dd262b2b30783 inherit pro_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1070e4e96457caf4ae35d23c1e9ac5c3 inherit pro_attribs_classPatternModel"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a1070e4e96457caf4ae35d23c1e9ac5c3">gapconf</a></td></tr>
<tr class="memdesc:a1070e4e96457caf4ae35d23c1e9ac5c3 inherit pro_attribs_classPatternModel"><td class="mdescLeft">&#160;</td><td class="mdescRight">pre-computed structure of possible gap configurations various pattern lengths  <a href="#a1070e4e96457caf4ae35d23c1e9ac5c3">More...</a><br /></td></tr>
<tr class="separator:a1070e4e96457caf4ae35d23c1e9ac5c3 inherit pro_attribs_classPatternModel"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt;<br />
class IndexedPatternModel&lt; MapType &gt;</h3>

<p>An indexed model mapping patterns to values, high-level interface. This is a specialised subclass of <a class="el" href="classPatternMap.html" title="A pattern map storing patterns and their values in a hash map (unordered_map). ">PatternMap</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MapType</td><td>The type of container to use </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af2fbb7d1f40210bda30bee3d5577546a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::<a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *&#160;</td>
          <td class="paramname"><em>corpus</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin a new pattern model, optionally pre-setting a reverseindex. </p>

</div>
</div>
<a class="anchor" id="a983367ac09e96735a2075a1f780d1de4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::<a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *&#160;</td>
          <td class="paramname"><em>constrainmodel</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *&#160;</td>
          <td class="paramname"><em>corpus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a pattern model from an input stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The input stream </td></tr>
    <tr><td class="paramname">options</td><td>Options for reading, these act as filter for the data, allowing you to raise thresholds etc </td></tr>
    <tr><td class="paramname">constrainmodel</td><td>Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to NULL (no constraining) </td></tr>
    <tr><td class="paramname">corpus</td><td>Pointer to the loaded corpus, used as a reverse index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d49b0f8aea957fc80e7e8d7b4dd5ba8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::<a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *&#160;</td>
          <td class="paramname"><em>constrainmodel</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *&#160;</td>
          <td class="paramname"><em>corpus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a pattern model from file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename </td></tr>
    <tr><td class="paramname">options</td><td>Options for reading, these act as filter for the data, allowing you to raise thresholds etc </td></tr>
    <tr><td class="paramname">constrainmodel</td><td>Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to NULL (no constraining) </td></tr>
    <tr><td class="paramname">corpus</td><td>Pointer to the loaded corpus, used as a reverse index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadc89a95b7ef0874ab5d763d0c453e79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::~<a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a41367fc32c9fa72d1a88e60d749015a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexedData.html">IndexedData</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexReference.html">IndexReference</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a pattern, with a given position, and a value to the model. This is called during training at every time an instance of a pattern is found in the data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern to add </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the value for this pattern, set to NULL and it will be automatically determined </td></tr>
    <tr><td class="paramname"><a class="el" href="classIndexReference.html" title="Reference to a position in the corpus. ">IndexReference</a></td><td>The position in the corpus where the patterns occurs </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classPatternModel.html#a0cdb8badafbce0f56089f7c2b8f4716a">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a83e3a00515a9ad419b4a2f820278c5f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPatternPointer.html">PatternPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>patternpointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexedData.html">IndexedData</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexReference.html">IndexReference</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classPatternModel.html#ad16097db7894d75815cd40ef5acc99a5">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0d53765f0498911c976744cc3670ff72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::buildreverseindex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a>&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>build reverse index, requires options.DOREVERSEINDEX to be set or won't do anything. Also won't build a reverse index if one is loaded already. Note that pre-loading a reverse index when loading/training your model is generally quicker. </p>

</div>
</div>
<a class="anchor" id="ae62d20c9507dee1edd2f133cf3de2a5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::computecooc </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="classPattern.html">Pattern</a>, <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coocmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute co-occurence as absolute joint occurrence count, for all patterns </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coocmap</td><td>The map that will store the results </td></tr>
    <tr><td class="paramname">threshold</td><td>Only include pairs passing this NPMI threshold </td></tr>
    <tr><td class="paramname">right</td><td>Compute co-occurence to the right (default: true) </td></tr>
    <tr><td class="paramname">left</td><td>Compute co-occurence to the left (default: true) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf70c3536f4869b3e8330289f7409bf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::computecoveragestats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute coverage statistics on the model, will generally be called automatically by methods who use it, and the statistics are cached after computation. </p>

<p>Reimplemented from <a class="el" href="classPatternModel.html#ae36bb1e641f954ee78a5fbab98ae069a">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2d1a24a490466115aad4cf09058337ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::computeflexgrams_fromcooc </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute flexgrams using co-occurrence </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>Normalised Pointwise Mutual Information threshold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of flexgrams found </dd></dl>

</div>
</div>
<a class="anchor" id="ad3b8e1405429aa869501f9117664b0d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::computeflexgrams_fromskipgrams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute flexgrams by abstracting from existing skipgrams in the model </p><dl class="section return"><dt>Returns</dt><dd>The number of flexgrams found </dd></dl>

<p>Reimplemented from <a class="el" href="classPatternModel.html#ab393fff93aae08db7456a9e60296a0b3">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab07346735ccdee4d7e42043e95d1bc2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::computenpmi </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="classPattern.html">Pattern</a>, <a class="el" href="patternmodel_8h.html#ae13b52c8cf777358f19da17c90c7dac0">t_relationmap_double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coocmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abd312da331baffd69a7944084cc0e4f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::flexgramsize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexReference.html">IndexReference</a>&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>attempt to find the flexgram size for the given begin position, returns 0 if the flexgram was not found at all if there are multiple matches, the shortest is returned </p>

</div>
</div>
<a class="anchor" id="aaa6caa3a7aa9ce15087b98dd8d2b1c4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::getcooc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>occurrencethreshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ordersignificant</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all patterns in the model that co-occur with the given pattern in the same sentence </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">occurrencethreshold</td><td>If set above zero, filters to only include patterns occurring above this threshold </td></tr>
    <tr><td class="paramname">category</td><td>Set to any value of PatternCategory (NGRAM,SKIPGRAM,FLEXGRAM) to include only this category. Set to 0 for unfiltered (default) </td></tr>
    <tr><td class="paramname">size</td><td>Set to any value above zero to only include patterns of the specified length. </td></tr>
    <tr><td class="paramname">ordersignificant</td><td>If set to true, each co-occuring pair will occur at least once in the result, if false (default) it will appear twice, once in A,B form and once in B,A form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a relation map </dd></dl>

</div>
</div>
<a class="anchor" id="a1ee41056c7235bf03573e6532cd5efce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexedData.html">IndexedData</a>* <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::getdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>makeifnew</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the indices stored for the specified pattern. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">makeifnew</td><td>Add the pattern with empty value if it does not exist (default: false) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classPatternModel.html#aaec0fa3d026d88bc5b8e2dc5f0994015">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9311529a1123f602720b9e95f3f89236"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexedData.html">IndexedData</a>* <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::getdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPatternPointer.html">PatternPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>patternpointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>makeifnew</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classPatternModel.html#a1baf331b3a10a45fdadd6a835a744cf3">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2942d0920ce1e646cb733c0c84fdd0d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::getinstances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>occurrencethreshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all ngrams in the model that instantiate the given skipgram/flexgram. If all the gaps in a skipgram/flexgram are filled, we speak of such an instantiation. An occurrence threshold may be used to filter. </p><dl class="section return"><dt>Returns</dt><dd>a relation map </dd></dl>

</div>
</div>
<a class="anchor" id="a9f9292a132bac92267f26eeae00fd8ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::getleftcooc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>occurrencethreshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all patterns in the model that co-occur with the given pattern in the same sentence and appear to the left of the given pattern </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">occurrencethreshold</td><td>If set above zero, filters to only include patterns occurring above this threshold </td></tr>
    <tr><td class="paramname">category</td><td>Set to any value of PatternCategory (NGRAM,SKIPGRAM,FLEXGRAM) to include only this category. Set to 0 for unfiltered (default) </td></tr>
    <tr><td class="paramname">size</td><td>Set to any value above zero to only include patterns of the specified length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a relation map </dd></dl>

</div>
</div>
<a class="anchor" id="a7d3909fc9e28191fa2f47be30b3dd99e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::getleftneighbours </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>occurrencethreshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all patterns in the model that directly neighbour the given pattern at the left side </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">occurrencethreshold</td><td>If set above zero, filters to only include patterns occurring above this threshold </td></tr>
    <tr><td class="paramname">category</td><td>Set to any value of PatternCategory (NGRAM,SKIPGRAM,FLEXGRAM) to include only this category. Set to 0 for unfiltered (default) </td></tr>
    <tr><td class="paramname">size</td><td>Set to any value above zero to only include patterns of the specified length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a relation map </dd></dl>

</div>
</div>
<a class="anchor" id="adeb6b2bce5dc4fcdd9f8ec9f723d0f5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::getmodeltype </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the type of model (a value from ModelType) </p>

<p>Reimplemented from <a class="el" href="classPatternModel.html#aadea1e70400eb2aeced1ca1648cf9cd9">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="adabaad88e64edd1c4762a56c86d1bae4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::getmodelversion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the version of the model implementation and binary serialisation format </p>

<p>Reimplemented from <a class="el" href="classPatternModel.html#ac2f98f98d449951caa82894be78e9fe6">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a205e5f3a0019a9948064084c0b92a7ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPattern.html">Pattern</a> <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::getpatternfromtoken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIndexReference.html">IndexReference</a>&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the unigram <a class="el" href="classPattern.html" title="Pattern class, represents a pattern (ngram, skipgram or flexgram). Encoded in a memory-saving fashion...">Pattern</a> that occurs on the specified position, using the reverse index. </p>

</div>
</div>
<a class="anchor" id="ad0d8258d41c372a17b91f8be08f3f305"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::getrightcooc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>occurrencethreshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexedData.html">IndexedData</a> *&#160;</td>
          <td class="paramname"><em>matches</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all patterns in the model that co-occur with the given pattern in the same sentence and appear to the right of the given pattern </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">occurrencethreshold</td><td>If set above zero, filters to only include patterns occurring above this threshold </td></tr>
    <tr><td class="paramname">category</td><td>Set to any value of PatternCategory (NGRAM,SKIPGRAM,FLEXGRAM) to include only this category. Set to 0 for unfiltered (default) </td></tr>
    <tr><td class="paramname">size</td><td>Set to any value above zero to only include patterns of the specified length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a relation map </dd></dl>

</div>
</div>
<a class="anchor" id="ab2d837b1f82f65b18ab6a7fc3ba2b15c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::getrightneighbours </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>occurrencethreshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all patterns in the model that directly neighbour the given pattern at the right side </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">occurrencethreshold</td><td>If set above zero, filters to only include patterns occurring above this threshold </td></tr>
    <tr><td class="paramname">category</td><td>Set to any value of PatternCategory (NGRAM,SKIPGRAM,FLEXGRAM) to include only this category. Set to 0 for unfiltered (default) </td></tr>
    <tr><td class="paramname">size</td><td>Set to any value above zero to only include patterns of the specified length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a relation map </dd></dl>

</div>
</div>
<a class="anchor" id="ac2478fc9fd1eabfc616c1692fc2a58d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::getskipcontent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a skipgram, returns patterns which would instantiate the skipgram if inserted into the gaps. For skipgrams with multiple gaps, these skip content patterns are themselves skipgrams. Skipgram and skip content complement eachother </p><dl class="section return"><dt>Returns</dt><dd>A relation map </dd></dl>

<p>Reimplemented from <a class="el" href="classPatternModel.html#aa9d5de68d7989ba234d2628ab4af35fb">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a785f4b6ef4229843b90ba895957a1b56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::getsubchildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>occurrencethreshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all patterns in the model that are subsumed by the specified pattern. Subsumed patterns are smaller than the subsuming pattern. Every n-gram (except unigram) by definition subsumes two n-1-grams. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">occurrencethreshold</td><td>If set above zero, filters to only include patterns occurring above this threshold </td></tr>
    <tr><td class="paramname">category</td><td>Set to any value of PatternCategory (NGRAM,SKIPGRAM,FLEXGRAM) to include only this category. Set to 0 for unfiltered (default) </td></tr>
    <tr><td class="paramname">size</td><td>Set to any value above zero to only include patterns of the specified length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a relation map </dd></dl>

</div>
</div>
<a class="anchor" id="aed2ec73f5bece8595e6f6ab4f180ce75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::getsubparents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>occurrencethreshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all patterns in the model that subsume the specified pattern. Subsuming patterns are larger than the subsuming pattern. Every n-gram (except unigram) by definition subsumes two n-1-grams. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">occurrencethreshold</td><td>If set above zero, filters to only include patterns occurring above this threshold </td></tr>
    <tr><td class="paramname">category</td><td>Set to any value of PatternCategory (NGRAM,SKIPGRAM,FLEXGRAM) to include only this category. Set to 0 for unfiltered (default) </td></tr>
    <tr><td class="paramname">size</td><td>Set to any value above zero to only include patterns of the specified length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a relation map </dd></dl>

</div>
</div>
<a class="anchor" id="a951ae48d5f211af94a3c63102f708356"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::gettemplates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>occurrencethreshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all skipgrams and flexgrams in the model that are an abstraction of the specified pattern. <a class="el" href="classPattern.html" title="Pattern class, represents a pattern (ngram, skipgram or flexgram). Encoded in a memory-saving fashion...">Pattern</a> itself may be a skipgram too. An optional occurrence threshold may be used to filter. </p><dl class="section return"><dt>Returns</dt><dd>a relation map </dd></dl>

</div>
</div>
<a class="anchor" id="a64fade10459a7699b856c8cb621789f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::info </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>OUT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output information about the model to the output stream, includes some statistics and technical details such as space requirements. </p>

</div>
</div>
<a class="anchor" id="a03c138c720ca2724457f2786626478d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::npmi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>key2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>jointcount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute normalised pointwise mutual information given two patterns and their joint occurrence count. </p>

</div>
</div>
<a class="anchor" id="a6ab1e2d6bf0a8aeed25a39c306e51c34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::outputcooc </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;&#160;</td>
          <td class="paramname"><em>classdecoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute and output co-occurrence relations as joint occurrence count </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>Normalised Pointwise Mutual Information threshold </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classPatternModel.html#a107980d1345c1f20ba3284474220ee7e">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4e8d1bf4017173e8214cfd37bab576c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::outputcooc_npmi </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;&#160;</td>
          <td class="paramname"><em>classdecoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute and output co-occurrence relations as Normalised Pointwise Mutual Information </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>Normalised Pointwise Mutual Information threshold </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classPatternModel.html#a45da84761e93772df0465bca2780b9b3">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a001c634d095eee8883e8cd8fd24846d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::outputrelations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> &amp;&#160;</td>
          <td class="paramname"><em>relations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;&#160;</td>
          <td class="paramname"><em>classdecoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>label</em> = <code>&quot;RELATED-TO&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output the specified relation map for the specified pattern to output stream. Low-level function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern </td></tr>
    <tr><td class="paramname">relations</td><td>A relation map </td></tr>
    <tr><td class="paramname">classdecoder</td><td>A class decoder </td></tr>
    <tr><td class="paramname">OUT</td><td>The output stream </td></tr>
    <tr><td class="paramname">label</td><td>A label to insert between relations (defaults to: RELATED-TO) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfe968ebfe686a774ae70c810d2d9cc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::outputrelations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;&#160;</td>
          <td class="paramname"><em>classdecoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>outputheader</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute and output all possible relations for a given pattern. High-level function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern </td></tr>
    <tr><td class="paramname">classdecoder</td><td>A class decoder </td></tr>
    <tr><td class="paramname">OUT</td><td>The output stream </td></tr>
    <tr><td class="paramname">outputheader</td><td>Output a header (default: true) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82f5f4fffea239a4f5bde4d346691f5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::postread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a>&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classPatternModel.html#a3746e351f393bb6201f3b8df92881bb7">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4a39df881afb2ef2c6c4a29afe9aa6ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::posttrain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a>&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classPatternModel.html#a5447228ff966dcb3c93c8c787ce31386">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4a5f41aa99e3b93a9a816e9c21b9b790"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;&#160;</td>
          <td class="paramname"><em>decoder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the contents of the pattern model, i.e. all patterns and associated counts, to the output stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output stream </td></tr>
    <tr><td class="paramname">decoder</td><td>The class decoder to use </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classPatternModel.html#a6d645bd24603696e77d6904c09d9b39c">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aed4218c952b051b523d8d5a31c5c00fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print for one pattern only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output stream </td></tr>
    <tr><td class="paramname">decoder</td><td>The class decoder to use </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classPatternModel.html#a58bbe1d44c4daf8560872f97d124a836">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0509989bf6bcb7d09dbc0e5c9e3dc84a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::prunerelations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> &amp;&#160;</td>
          <td class="paramname"><em>relations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>occurrencethreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a relation map, prune relations below the specified occurrence threshold </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relations</td><td>The relationmap to manipulate </td></tr>
    <tr><td class="paramname">occurrencethreshold</td><td>The occurrence threshold </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0df4f0e3a55dd00c0fe00fc3841f66ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::pruneskipgrams </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minskiptypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_n</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prune skipgrams based on an occurrence threshold, and a skiptype threshold. The latter enforces that at least the specified number of distinct patterns must fit in the gap for the skipgram to be retained. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_n</td><td>Set to any value above zero to only include patterns of the specified length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf0b5ec19f8b76b875dbef07ca0cb398"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapType = PatternMap&lt;IndexedData,IndexedDataHandler&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classIndexedPatternModel.html">IndexedPatternModel</a>&lt; MapType &gt;::trainskipgrams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPatternModelOptions.html">PatternModelOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *&#160;</td>
          <td class="paramname"><em>constrainbymodel</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Train skipgrams, for indexed models only </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td><a class="el" href="classPattern.html" title="Pattern class, represents a pattern (ngram, skipgram or flexgram). Encoded in a memory-saving fashion...">Pattern</a> model options </td></tr>
    <tr><td class="paramname">constrainbymodel</td><td>Pointer to a pattern model to use as contraint: only include skipgrams that occur in the constraint model (default: NULL) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classPatternModel.html#acd4e0ecc0e796c894b994859b2c5ffb6">PatternModel&lt; IndexedData, IndexedDataHandler, MapType &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="patternmodel_8h_source.html">patternmodel.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 16 2015 13:45:50 for Colibri Core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
