<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Colibri Core: PatternModel&lt; ValueType, ValueHandler, MapType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Colibri Core
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classPatternModel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PatternModel&lt; ValueType, ValueHandler, MapType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A model mapping patterns to values, gigh-level interface.  
 <a href="classPatternModel.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="patternmodel_8h_source.html">patternmodel.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PatternModel&lt; ValueType, ValueHandler, MapType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPatternModel.png" usemap="#PatternModel&lt; ValueType, ValueHandler, MapType &gt;_map" alt=""/>
  <map id="PatternModel&lt; ValueType, ValueHandler, MapType &gt;_map" name="PatternModel&lt; ValueType, ValueHandler, MapType &gt;_map">
<area href="classPatternModelInterface.html" title="Basic read-only interface for pattern models, abstract base class. " alt="PatternModelInterface" shape="rect" coords="331,56,652,80"/>
<area href="classPatternStoreInterface.html" title="Limited virtual interface to pattern stores. " alt="PatternStoreInterface" shape="rect" coords="165,0,486,24"/>
<area href="classPatternStoreInterface.html" title="Limited virtual interface to pattern stores. " alt="PatternStoreInterface" shape="rect" coords="496,0,817,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8aedb15ca2b6f5e3d619c1878d5c0639"><td class="memItemLeft" align="right" valign="top">typedef MapType::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a8aedb15ca2b6f5e3d619c1878d5c0639">iterator</a></td></tr>
<tr class="separator:a8aedb15ca2b6f5e3d619c1878d5c0639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfc44c56122e8037bb634a3d66bac0a"><td class="memItemLeft" align="right" valign="top">typedef MapType::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aecfc44c56122e8037bb634a3d66bac0a">const_iterator</a></td></tr>
<tr class="separator:aecfc44c56122e8037bb634a3d66bac0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ade6d8f3c3bae062c06881d96809ea4ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ade6d8f3c3bae062c06881d96809ea4ff">PatternModel</a> (<a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *corpus=NULL)</td></tr>
<tr class="separator:ade6d8f3c3bae062c06881d96809ea4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1e66e0893ead99e75013cb578cd54a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a9f1e66e0893ead99e75013cb578cd54a">PatternModel</a> (std::istream *f, <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainmodel=NULL, <a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *corpus=NULL)</td></tr>
<tr class="separator:a9f1e66e0893ead99e75013cb578cd54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd68d5b590a3b477f7fdee2921755a44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#afd68d5b590a3b477f7fdee2921755a44">PatternModel</a> (const std::string filename, const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainmodel=NULL, <a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *corpus=NULL)</td></tr>
<tr class="separator:afd68d5b590a3b477f7fdee2921755a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadea1e70400eb2aeced1ca1648cf9cd9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aadea1e70400eb2aeced1ca1648cf9cd9">getmodeltype</a> () const </td></tr>
<tr class="separator:aadea1e70400eb2aeced1ca1648cf9cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f98f98d449951caa82894be78e9fe6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ac2f98f98d449951caa82894be78e9fe6">getmodelversion</a> () const </td></tr>
<tr class="separator:ac2f98f98d449951caa82894be78e9fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f387acaf981af9962195bd05b3e7e2"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a> () const </td></tr>
<tr class="separator:a25f387acaf981af9962195bd05b3e7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577eb056f583b4efc943ac4e7a581b1b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a577eb056f583b4efc943ac4e7a581b1b">has</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern) const </td></tr>
<tr class="separator:a577eb056f583b4efc943ac4e7a581b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94a590e3c5eacde04cb55430198acfa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#af94a590e3c5eacde04cb55430198acfa">has</a> (const <a class="el" href="classPatternPointer.html">PatternPointer</a> &amp;pattern) const </td></tr>
<tr class="separator:af94a590e3c5eacde04cb55430198acfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26de418f6998cac0f484a958597afccc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a26de418f6998cac0f484a958597afccc">load</a> (std::string filename, const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainmodel=NULL)</td></tr>
<tr class="separator:a26de418f6998cac0f484a958597afccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfb81964c7a6eb13d846dc11d2cc667"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#acbfb81964c7a6eb13d846dc11d2cc667">load</a> (std::istream *f, const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainmodel=NULL)</td></tr>
<tr class="separator:acbfb81964c7a6eb13d846dc11d2cc667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837bdbf478b7ea8a51ad674418926175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a837bdbf478b7ea8a51ad674418926175">getinterface</a> ()</td></tr>
<tr class="separator:a837bdbf478b7ea8a51ad674418926175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e8a9a955f8da64abe95179482a6b55"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ac1e8a9a955f8da64abe95179482a6b55">train</a> (std::istream *in, <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainbymodel=NULL)</td></tr>
<tr class="separator:ac1e8a9a955f8da64abe95179482a6b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2390acee4c9aeecf1bce2d0b312bb4c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ac2390acee4c9aeecf1bce2d0b312bb4c">train</a> (const std::string filename, const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainbymodel=NULL)</td></tr>
<tr class="separator:ac2390acee4c9aeecf1bce2d0b312bb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a7898c399c670792af12f509adcd28"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aa8a7898c399c670792af12f509adcd28">computeskipgrams</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, int mintokens=2, const <a class="el" href="classIndexReference.html">IndexReference</a> *singleref=NULL, const <a class="el" href="classIndexedData.html">IndexedData</a> *multiplerefs=NULL, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainbymodel=NULL, std::vector&lt; <a class="el" href="classPattern.html">Pattern</a> &gt; *targetcontainer=NULL, const bool exhaustive=false, const bool DEBUG=false)</td></tr>
<tr class="separator:aa8a7898c399c670792af12f509adcd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b3338b6e79a3dbc9b5f95cb0171494"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a00b3338b6e79a3dbc9b5f95cb0171494">computeskipgrams</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> &amp;options, const <a class="el" href="classIndexReference.html">IndexReference</a> *singleref=NULL, const <a class="el" href="classIndexedData.html">IndexedData</a> *multiplerefs=NULL, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainbymodel=NULL, const bool exhaustive=false)</td></tr>
<tr class="separator:a00b3338b6e79a3dbc9b5f95cb0171494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aa18a4d9e7554a3c798872e915e8a0"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classPattern.html">Pattern</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aa4aa18a4d9e7554a3c798872e915e8a0">findskipgrams</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, unsigned int occurrencethreshold=1)</td></tr>
<tr class="separator:aa4aa18a4d9e7554a3c798872e915e8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4e0ecc0e796c894b994859b2c5ffb6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#acd4e0ecc0e796c894b994859b2c5ffb6">trainskipgrams</a> (const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options, <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *constrainbymodel=NULL)</td></tr>
<tr class="separator:acd4e0ecc0e796c894b994859b2c5ffb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fb390761ae0fc47e3a48621c94698b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a21fb390761ae0fc47e3a48621c94698b">test</a> (MapType &amp;target, std::istream *in)</td></tr>
<tr class="separator:a21fb390761ae0fc47e3a48621c94698b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3456e788caacd51fe3c7fb8fdf547723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a3456e788caacd51fe3c7fb8fdf547723">write</a> (std::ostream *out)</td></tr>
<tr class="separator:a3456e788caacd51fe3c7fb8fdf547723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73654320cd52e691fd7df037cf3ff013"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a73654320cd52e691fd7df037cf3ff013">write</a> (const std::string filename)</td></tr>
<tr class="separator:a73654320cd52e691fd7df037cf3ff013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d63c6c6ada696e3a247e25df8487ec"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ac0d63c6c6ada696e3a247e25df8487ec">maxlength</a> () const </td></tr>
<tr class="separator:ac0d63c6c6ada696e3a247e25df8487ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4777ec9b1e76ef3c2ccbc981dad15129"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a4777ec9b1e76ef3c2ccbc981dad15129">minlength</a> () const </td></tr>
<tr class="separator:a4777ec9b1e76ef3c2ccbc981dad15129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5bc659abbbdd456937e85642a97d40"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a8f5bc659abbbdd456937e85642a97d40">occurrencecount</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="separator:a8f5bc659abbbdd456937e85642a97d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec0fa3d026d88bc5b8e2dc5f0994015"><td class="memItemLeft" align="right" valign="top">virtual ValueType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aaec0fa3d026d88bc5b8e2dc5f0994015">getdata</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, bool makeifnew=false)</td></tr>
<tr class="separator:aaec0fa3d026d88bc5b8e2dc5f0994015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1baf331b3a10a45fdadd6a835a744cf3"><td class="memItemLeft" align="right" valign="top">virtual ValueType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a1baf331b3a10a45fdadd6a835a744cf3">getdata</a> (const <a class="el" href="classPatternPointer.html">PatternPointer</a> &amp;patternpointer, bool makeifnew=false)</td></tr>
<tr class="separator:a1baf331b3a10a45fdadd6a835a744cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5df3d30417804589c552320add3285a"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#af5df3d30417804589c552320add3285a">types</a> ()</td></tr>
<tr class="separator:af5df3d30417804589c552320add3285a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac99feddfa4cf1dc44090c5148e518a"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#afac99feddfa4cf1dc44090c5148e518a">tokens</a> () const </td></tr>
<tr class="separator:afac99feddfa4cf1dc44090c5148e518a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df468e440b875af0d9321d090f87dab"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a7df468e440b875af0d9321d090f87dab">type</a> () const </td></tr>
<tr class="separator:a7df468e440b875af0d9321d090f87dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56c31e031bb51d47e98cc433a46556e"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#af56c31e031bb51d47e98cc433a46556e">version</a> () const </td></tr>
<tr class="separator:af56c31e031bb51d47e98cc433a46556e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa8d87b4b2269e796d97902f3214d22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aafa8d87b4b2269e796d97902f3214d22">output</a> (std::ostream *)</td></tr>
<tr class="separator:aafa8d87b4b2269e796d97902f3214d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bad2b94ec96880f3e4307d55c42e492"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a5bad2b94ec96880f3e4307d55c42e492">coveragecount</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;key)</td></tr>
<tr class="separator:a5bad2b94ec96880f3e4307d55c42e492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07eb601afe937b144e100cd96d091d3a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a07eb601afe937b144e100cd96d091d3a">coverage</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;key)</td></tr>
<tr class="separator:a07eb601afe937b144e100cd96d091d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b37ea19d0646bff54cae15290fc884c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPattern.html">Pattern</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a6b37ea19d0646bff54cae15290fc884c">getreverseindex</a> (const <a class="el" href="classIndexReference.html">IndexReference</a> ref, int <a class="el" href="classPatternModel.html#a8f5bc659abbbdd456937e85642a97d40">occurrencecount</a>=0, int category=0, unsigned int <a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a>=0)</td></tr>
<tr class="separator:a6b37ea19d0646bff54cae15290fc884c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca7b37dfacef90de4e2139acb99cedb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classIndexReference.html">IndexReference</a>, <a class="el" href="classPattern.html">Pattern</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#abca7b37dfacef90de4e2139acb99cedb">getreverseindex_bysentence</a> (int sentence)</td></tr>
<tr class="separator:abca7b37dfacef90de4e2139acb99cedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c49738d4296c9dde3ee2796d6b66814"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classIndexReference.html">IndexReference</a>, <a class="el" href="classPattern.html">Pattern</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a0c49738d4296c9dde3ee2796d6b66814">getreverseindex_right</a> (const <a class="el" href="classIndexReference.html">IndexReference</a> ref)</td></tr>
<tr class="separator:a0c49738d4296c9dde3ee2796d6b66814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec29a383939fa71f61edfea80ea1b2d0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classIndexReference.html">IndexReference</a>, <a class="el" href="classPattern.html">Pattern</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aec29a383939fa71f61edfea80ea1b2d0">getreverseindex_left</a> (const <a class="el" href="classIndexReference.html">IndexReference</a> ref)</td></tr>
<tr class="separator:aec29a383939fa71f61edfea80ea1b2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b0d7452c19849930d6b3d19888130d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a06b0d7452c19849930d6b3d19888130d">computestats</a> ()</td></tr>
<tr class="separator:a06b0d7452c19849930d6b3d19888130d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36bb1e641f954ee78a5fbab98ae069a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ae36bb1e641f954ee78a5fbab98ae069a">computecoveragestats</a> ()</td></tr>
<tr class="separator:ae36bb1e641f954ee78a5fbab98ae069a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad5fd4ad8ed72160938ca9a30d26201"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a4ad5fd4ad8ed72160938ca9a30d26201">totaloccurrencesingroup</a> (int category, int n)</td></tr>
<tr class="separator:a4ad5fd4ad8ed72160938ca9a30d26201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fd6f8f536a802d6653665aa4d48cbf"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a38fd6f8f536a802d6653665aa4d48cbf">totalpatternsingroup</a> (int category, int n)</td></tr>
<tr class="separator:a38fd6f8f536a802d6653665aa4d48cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23de99349652ec0774db5d09593bd255"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a23de99349652ec0774db5d09593bd255">totalwordtypesingroup</a> (int category, int n)</td></tr>
<tr class="separator:a23de99349652ec0774db5d09593bd255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5f43e06e2262fc4387729fc6265050"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aaa5f43e06e2262fc4387729fc6265050">totaltokensingroup</a> (int category, int n)</td></tr>
<tr class="separator:aaa5f43e06e2262fc4387729fc6265050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0927686caf05d2e1accff6e158a75188"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a0927686caf05d2e1accff6e158a75188">frequency</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="separator:a0927686caf05d2e1accff6e158a75188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdb8badafbce0f56089f7c2b8f4716a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a0cdb8badafbce0f56089f7c2b8f4716a">add</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, ValueType *value, const <a class="el" href="classIndexReference.html">IndexReference</a> &amp;ref)</td></tr>
<tr class="separator:a0cdb8badafbce0f56089f7c2b8f4716a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16097db7894d75815cd40ef5acc99a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ad16097db7894d75815cd40ef5acc99a5">add</a> (const <a class="el" href="classPatternPointer.html">PatternPointer</a> &amp;pattern, ValueType *value, const <a class="el" href="classIndexReference.html">IndexReference</a> &amp;ref)</td></tr>
<tr class="separator:ad16097db7894d75815cd40ef5acc99a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3698c1c47789b2fb2eae65d96ed4e3ab"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a3698c1c47789b2fb2eae65d96ed4e3ab">prune</a> (int threshold, int _n=0)</td></tr>
<tr class="separator:a3698c1c47789b2fb2eae65d96ed4e3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30da80bd942ab1bac95ac9945f465702"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a30da80bd942ab1bac95ac9945f465702">pruneskipgrams</a> (unsigned int threshold, int minskiptypes=2, int _n=0)</td></tr>
<tr class="separator:a30da80bd942ab1bac95ac9945f465702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4429ca9cb19f12e4b0bb7b8cb0e6fe7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ab4429ca9cb19f12e4b0bb7b8cb0e6fe7">prunenotinset</a> (const std::unordered_set&lt; <a class="el" href="classPattern.html">Pattern</a> &gt; &amp;s, int _n)</td></tr>
<tr class="separator:ab4429ca9cb19f12e4b0bb7b8cb0e6fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787ccf34c969a5e14aa2e1bdcb164ee7"><td class="memTemplParams" colspan="2">template&lt;class ValueType2 , class ValueHandler2 , class MapType2 &gt; </td></tr>
<tr class="memitem:a787ccf34c969a5e14aa2e1bdcb164ee7"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a787ccf34c969a5e14aa2e1bdcb164ee7">prunebymodel</a> (<a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType2, ValueHandler2, MapType2 &gt; &amp;secondmodel)</td></tr>
<tr class="separator:a787ccf34c969a5e14aa2e1bdcb164ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d110daa1691b266ad325b1a2f7a842"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classPattern.html">Pattern</a>, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ad5d110daa1691b266ad325b1a2f7a842">getpatterns</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="separator:ad5d110daa1691b266ad325b1a2f7a842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d645bd24603696e77d6904c09d9b39c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a6d645bd24603696e77d6904c09d9b39c">print</a> (std::ostream *out, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;decoder)</td></tr>
<tr class="separator:a6d645bd24603696e77d6904c09d9b39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d23339ceb528e9cb7a02640bce392c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aa5d23339ceb528e9cb7a02640bce392c">printreverseindex</a> (std::ostream *out, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;decoder)</td></tr>
<tr class="separator:aa5d23339ceb528e9cb7a02640bce392c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b0bf9471b82119000b38c620ffc21e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a30b0bf9471b82119000b38c620ffc21e">printmodel</a> (std::ostream *out, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;decoder)</td></tr>
<tr class="separator:a30b0bf9471b82119000b38c620ffc21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bbe1d44c4daf8560872f97d124a836"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a58bbe1d44c4daf8560872f97d124a836">print</a> (std::ostream *out, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;decoder, const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, bool endline=true)</td></tr>
<tr class="separator:a58bbe1d44c4daf8560872f97d124a836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa497ee9bd6b1abe6ab4451fbf7272f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aaa497ee9bd6b1abe6ab4451fbf7272f4">printpattern</a> (std::ostream *out, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;decoder, const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, bool endline=true)</td></tr>
<tr class="separator:aaa497ee9bd6b1abe6ab4451fbf7272f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c97f76cca2ba56099eb1559a7b0ddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a72c97f76cca2ba56099eb1559a7b0ddd">histogram</a> (std::map&lt; unsigned int, unsigned int &gt; &amp;hist, unsigned int threshold=0, unsigned int cap=0, int category=0, unsigned int <a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a>=0)</td></tr>
<tr class="separator:a72c97f76cca2ba56099eb1559a7b0ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4c12ee56b5ae88f4a5b140ac6a6a0a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a1e4c12ee56b5ae88f4a5b140ac6a6a0a">topthreshold</a> (int amount, int category=0, int <a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a>=0)</td></tr>
<tr class="separator:a1e4c12ee56b5ae88f4a5b140ac6a6a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edf12738542d8d8b0cc9aa06b5a69b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a9edf12738542d8d8b0cc9aa06b5a69b2">histogram</a> (std::ostream *OUT, unsigned int threshold=0, unsigned int cap=0, int category=0, unsigned int <a class="el" href="classPatternModel.html#a25f387acaf981af9962195bd05b3e7e2">size</a>=0)</td></tr>
<tr class="separator:a9edf12738542d8d8b0cc9aa06b5a69b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231e5e4c9ed49764b24718e4269b4256"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a231e5e4c9ed49764b24718e4269b4256">info</a> (std::ostream *OUT)</td></tr>
<tr class="separator:a231e5e4c9ed49764b24718e4269b4256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8c647241c7ec1a80e088b13e232a06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aee8c647241c7ec1a80e088b13e232a06">report</a> (std::ostream *OUT)</td></tr>
<tr class="separator:aee8c647241c7ec1a80e088b13e232a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8881489a5a99215499809c6dcbe704e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPatternSet.html">PatternSet</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a8881489a5a99215499809c6dcbe704e9">extractset</a> (int <a class="el" href="classPatternModel.html#a4777ec9b1e76ef3c2ccbc981dad15129">minlength</a>=1, int <a class="el" href="classPatternModel.html#ac0d63c6c6ada696e3a247e25df8487ec">maxlength</a>=1)</td></tr>
<tr class="separator:a8881489a5a99215499809c6dcbe704e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa350e235140e580526d381c626355b58"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aa350e235140e580526d381c626355b58">outputrelations</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;classdecoder, std::ostream *OUT)</td></tr>
<tr class="separator:aa350e235140e580526d381c626355b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0fa1ea8423db319dfd6f338f7b2b40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a3b0fa1ea8423db319dfd6f338f7b2b40">getsubchildren</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, int=0, int=0, int=0)</td></tr>
<tr class="separator:a3b0fa1ea8423db319dfd6f338f7b2b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb7d6ef4e82a300557f2e0350209a6f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a5fb7d6ef4e82a300557f2e0350209a6f">getsubparents</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, int=0, int=0, int=0)</td></tr>
<tr class="separator:a5fb7d6ef4e82a300557f2e0350209a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997f4cfc3e65fb218097061f9d4429ca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a997f4cfc3e65fb218097061f9d4429ca">gettemplates</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, int=0)</td></tr>
<tr class="separator:a997f4cfc3e65fb218097061f9d4429ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564b582aba0eedacd4b0b6f2fa693f7d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a564b582aba0eedacd4b0b6f2fa693f7d">getinstances</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, int=0)</td></tr>
<tr class="separator:a564b582aba0eedacd4b0b6f2fa693f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d5de68d7989ba234d2628ab4af35fb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aa9d5de68d7989ba234d2628ab4af35fb">getskipcontent</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="separator:aa9d5de68d7989ba234d2628ab4af35fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7593acd2798e2e77ed5cb4e75d3f67"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aea7593acd2798e2e77ed5cb4e75d3f67">getleftneighbours</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, int=0, int=0, int=0, int=0)</td></tr>
<tr class="separator:aea7593acd2798e2e77ed5cb4e75d3f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34484b6262acb5967de624a14e73085"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ad34484b6262acb5967de624a14e73085">getrightneighbours</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, int=0, int=0, int=0, int=0)</td></tr>
<tr class="separator:ad34484b6262acb5967de624a14e73085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be06240959a62b03473c7a00ccebdd1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="patternmodel_8h.html#ae13b52c8cf777358f19da17c90c7dac0">t_relationmap_double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a0be06240959a62b03473c7a00ccebdd1">getnpmi</a> (const <a class="el" href="classPattern.html">Pattern</a> &amp;pattern, double threshold)</td></tr>
<tr class="separator:a0be06240959a62b03473c7a00ccebdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab393fff93aae08db7456a9e60296a0b3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ab393fff93aae08db7456a9e60296a0b3">computeflexgrams_fromskipgrams</a> ()</td></tr>
<tr class="separator:ab393fff93aae08db7456a9e60296a0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0a0314553ad6237838b44f14e45309"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#abc0a0314553ad6237838b44f14e45309">computeflexgrams_fromcooc</a> ()</td></tr>
<tr class="separator:abc0a0314553ad6237838b44f14e45309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45da84761e93772df0465bca2780b9b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a45da84761e93772df0465bca2780b9b3">outputcooc_npmi</a> (std::ostream *OUT, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;classdecoder, double threshold)</td></tr>
<tr class="separator:a45da84761e93772df0465bca2780b9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107980d1345c1f20ba3284474220ee7e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a107980d1345c1f20ba3284474220ee7e">outputcooc</a> (std::ostream *OUT, <a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;classdecoder, double threshold)</td></tr>
<tr class="separator:a107980d1345c1f20ba3284474220ee7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPatternModelInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPatternModelInterface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPatternModelInterface.html">PatternModelInterface</a></td></tr>
<tr class="memitem:a1bb04234bc1225becbec941a0efaa094 inherit pub_methods_classPatternModelInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPatternStoreInterface.html">PatternStoreInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModelInterface.html#a1bb04234bc1225becbec941a0efaa094">getstoreinterface</a> ()</td></tr>
<tr class="separator:a1bb04234bc1225becbec941a0efaa094 inherit pub_methods_classPatternModelInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb04234bc1225becbec941a0efaa094 inherit pub_methods_classPatternModelInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPatternStoreInterface.html">PatternStoreInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModelInterface.html#a1bb04234bc1225becbec941a0efaa094">getstoreinterface</a> ()</td></tr>
<tr class="separator:a1bb04234bc1225becbec941a0efaa094 inherit pub_methods_classPatternModelInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a17ad27133991f964ccd23bb09bf64e5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a17ad27133991f964ccd23bb09bf64e5a">reverseindex</a></td></tr>
<tr class="memdesc:a17ad27133991f964ccd23bb09bf64e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the reverse index for this model (or NULL)  <a href="#a17ad27133991f964ccd23bb09bf64e5a">More...</a><br /></td></tr>
<tr class="separator:a17ad27133991f964ccd23bb09bf64e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1b4eec80a00ef9c6effea477cc98f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a2f1b4eec80a00ef9c6effea477cc98f4">externalreverseindex</a></td></tr>
<tr class="memdesc:a2f1b4eec80a00ef9c6effea477cc98f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if reverse index was loaded externally and passed to the model (implies it won't be destroyed when the model is) //only used by <a class="el" href="classIndexedPatternModel.html" title="An indexed model mapping patterns to values, high-level interface. This is a specialised subclass of ...">IndexedPatternModel</a> but stored here to ease things for cython  <a href="#a2f1b4eec80a00ef9c6effea477cc98f4">More...</a><br /></td></tr>
<tr class="separator:a2f1b4eec80a00ef9c6effea477cc98f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9534e66035de7df26c9cd257e2faf7d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a9534e66035de7df26c9cd257e2faf7d1">hasskipgrams</a></td></tr>
<tr class="memdesc:a9534e66035de7df26c9cd257e2faf7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this model have skipgrams?  <a href="#a9534e66035de7df26c9cd257e2faf7d1">More...</a><br /></td></tr>
<tr class="separator:a9534e66035de7df26c9cd257e2faf7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3746e351f393bb6201f3b8df92881bb7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a3746e351f393bb6201f3b8df92881bb7">postread</a> (const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options)</td></tr>
<tr class="separator:a3746e351f393bb6201f3b8df92881bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5447228ff966dcb3c93c8c787ce31386"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a5447228ff966dcb3c93c8c787ce31386">posttrain</a> (const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> options)</td></tr>
<tr class="separator:a5447228ff966dcb3c93c8c787ce31386"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af28152ff3d5060e48c18423b8629d1eb"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#af28152ff3d5060e48c18423b8629d1eb">model_type</a></td></tr>
<tr class="separator:af28152ff3d5060e48c18423b8629d1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032f1517ae658e81fa2ca3360aba62a2"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a032f1517ae658e81fa2ca3360aba62a2">model_version</a></td></tr>
<tr class="separator:a032f1517ae658e81fa2ca3360aba62a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4667c917fab96ae756ee61693220f44e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a4667c917fab96ae756ee61693220f44e">totaltokens</a></td></tr>
<tr class="memdesc:a4667c917fab96ae756ee61693220f44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of tokens in the original corpus, so INCLUDES TOKENS NOT COVERED BY THE MODEL!  <a href="#a4667c917fab96ae756ee61693220f44e">More...</a><br /></td></tr>
<tr class="separator:a4667c917fab96ae756ee61693220f44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9de224847465b75a9be436b1990cef7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#af9de224847465b75a9be436b1990cef7">totaltypes</a></td></tr>
<tr class="memdesc:af9de224847465b75a9be436b1990cef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of unigram/word types in the original corpus, SO INCLUDING NOT COVERED BY THE MODEL!  <a href="#af9de224847465b75a9be436b1990cef7">More...</a><br /></td></tr>
<tr class="separator:af9de224847465b75a9be436b1990cef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e501edfcca21facfe0137ed5140c87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#ac0e501edfcca21facfe0137ed5140c87">maxn</a></td></tr>
<tr class="separator:ac0e501edfcca21facfe0137ed5140c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed492e59e656226b1c48b10c2904618"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#abed492e59e656226b1c48b10c2904618">minn</a></td></tr>
<tr class="separator:abed492e59e656226b1c48b10c2904618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9145b11bff161df5db3bcd33300319"><td class="memItemLeft" align="right" valign="top">std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a2f9145b11bff161df5db3bcd33300319">cache_categories</a></td></tr>
<tr class="separator:a2f9145b11bff161df5db3bcd33300319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c0c93e988cce16fdeb5a8a65e878b1"><td class="memItemLeft" align="right" valign="top">std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a18c0c93e988cce16fdeb5a8a65e878b1">cache_n</a></td></tr>
<tr class="separator:a18c0c93e988cce16fdeb5a8a65e878b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef56e648dc462352079542e9528df09"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::map&lt; int, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a8ef56e648dc462352079542e9528df09">cache_grouptotal</a></td></tr>
<tr class="memdesc:a8ef56e648dc462352079542e9528df09"><td class="mdescLeft">&#160;</td><td class="mdescRight">total occurrences (used for frequency computation, within a group)  <a href="#a8ef56e648dc462352079542e9528df09">More...</a><br /></td></tr>
<tr class="separator:a8ef56e648dc462352079542e9528df09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05db7c45b9368438f34dba519df3bb3e"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::map&lt; int, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a05db7c45b9368438f34dba519df3bb3e">cache_grouptotalpatterns</a></td></tr>
<tr class="memdesc:a05db7c45b9368438f34dba519df3bb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">total distinct patterns per group  <a href="#a05db7c45b9368438f34dba519df3bb3e">More...</a><br /></td></tr>
<tr class="separator:a05db7c45b9368438f34dba519df3bb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dee966a62bacaab4d107bb4ec5050c0"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::map&lt; int, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a4dee966a62bacaab4d107bb4ec5050c0">cache_grouptotalwordtypes</a></td></tr>
<tr class="memdesc:a4dee966a62bacaab4d107bb4ec5050c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">total covered word types per group  <a href="#a4dee966a62bacaab4d107bb4ec5050c0">More...</a><br /></td></tr>
<tr class="separator:a4dee966a62bacaab4d107bb4ec5050c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbf8c45dfa1993d1a9dd262b2b30783"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::map&lt; int, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#aebbf8c45dfa1993d1a9dd262b2b30783">cache_grouptotaltokens</a></td></tr>
<tr class="memdesc:aebbf8c45dfa1993d1a9dd262b2b30783"><td class="mdescLeft">&#160;</td><td class="mdescRight">total covered tokens per group  <a href="#aebbf8c45dfa1993d1a9dd262b2b30783">More...</a><br /></td></tr>
<tr class="separator:aebbf8c45dfa1993d1a9dd262b2b30783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1070e4e96457caf4ae35d23c1e9ac5c3"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternModel.html#a1070e4e96457caf4ae35d23c1e9ac5c3">gapconf</a></td></tr>
<tr class="memdesc:a1070e4e96457caf4ae35d23c1e9ac5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">pre-computed structure of possible gap configurations various pattern lengths  <a href="#a1070e4e96457caf4ae35d23c1e9ac5c3">More...</a><br /></td></tr>
<tr class="separator:a1070e4e96457caf4ae35d23c1e9ac5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt;<br />
class PatternModel&lt; ValueType, ValueHandler, MapType &gt;</h3>

<p>A model mapping patterns to values, gigh-level interface. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of Value this model stores </td></tr>
    <tr><td class="paramname">ValueHandler</td><td>A handler class for this type of value </td></tr>
    <tr><td class="paramname">MapType</td><td>The type of container to use </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aecfc44c56122e8037bb634a3d66bac0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MapType::const_iterator <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::<a class="el" href="classPatternModel.html#aecfc44c56122e8037bb634a3d66bac0a">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8aedb15ca2b6f5e3d619c1878d5c0639"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MapType::iterator <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::<a class="el" href="classPatternModel.html#a8aedb15ca2b6f5e3d619c1878d5c0639">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ade6d8f3c3bae062c06881d96809ea4ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::<a class="el" href="classPatternModel.html">PatternModel</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *&#160;</td>
          <td class="paramname"><em>corpus</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin a new pattern model, optionally pre-setting a reverseindex. </p>

</div>
</div>
<a class="anchor" id="a9f1e66e0893ead99e75013cb578cd54a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::<a class="el" href="classPatternModel.html">PatternModel</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPatternModelOptions.html">PatternModelOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *&#160;</td>
          <td class="paramname"><em>constrainmodel</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *&#160;</td>
          <td class="paramname"><em>corpus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a pattern model from an input stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The input stream </td></tr>
    <tr><td class="paramname">options</td><td>Options for reading, these act as filter for the data, allowing you to raise thresholds etc </td></tr>
    <tr><td class="paramname">constrainmodel</td><td>Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to NULL (no constraining) </td></tr>
    <tr><td class="paramname">corpus</td><td>Pointer to the loaded corpus, used as a reverse index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd68d5b590a3b477f7fdee2921755a44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::<a class="el" href="classPatternModel.html">PatternModel</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *&#160;</td>
          <td class="paramname"><em>constrainmodel</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexedCorpus.html">IndexedCorpus</a> *&#160;</td>
          <td class="paramname"><em>corpus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a pattern model from file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The input filename </td></tr>
    <tr><td class="paramname">options</td><td>Options for reading, these act as filter for the data, allowing you to raise thresholds etc </td></tr>
    <tr><td class="paramname">constrainmodel</td><td>Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to NULL (no constraining) </td></tr>
    <tr><td class="paramname">corpus</td><td>Pointer to the loaded corpus, used as a reverse index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0cdb8badafbce0f56089f7c2b8f4716a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexReference.html">IndexReference</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a pattern, with a given position, and a value to the model. This is called during training at every time an instance of a pattern is found in the data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern to add </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the value for this pattern, what kind of value depends on the ValueType template parameter. </td></tr>
    <tr><td class="paramname">ref</td><td>The position in the corpus where the patterns occurs </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#a41367fc32c9fa72d1a88e60d749015a5">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad16097db7894d75815cd40ef5acc99a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPatternPointer.html">PatternPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexReference.html">IndexReference</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#a83e3a00515a9ad419b4a2f820278c5f7">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae36bb1e641f954ee78a5fbab98ae069a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::computecoveragestats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute coverage statistics on the model, will generally be called automatically by methods who use it, and the statistics are cached after computation. </p>

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#acf70c3536f4869b3e8330289f7409bf5">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abc0a0314553ad6237838b44f14e45309"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::computeflexgrams_fromcooc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab393fff93aae08db7456a9e60296a0b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::computeflexgrams_fromskipgrams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#ad3b8e1405429aa869501f9117664b0d5">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa8a7898c399c670792af12f509adcd28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::computeskipgrams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mintokens</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexReference.html">IndexReference</a> *&#160;</td>
          <td class="paramname"><em>singleref</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexedData.html">IndexedData</a> *&#160;</td>
          <td class="paramname"><em>multiplerefs</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *&#160;</td>
          <td class="paramname"><em>constrainbymodel</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPattern.html">Pattern</a> &gt; *&#160;</td>
          <td class="paramname"><em>targetcontainer</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>exhaustive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>DEBUG</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Low-level function to compute skipgrams for a given pattern . See higher-level function instead </p>

</div>
</div>
<a class="anchor" id="a00b3338b6e79a3dbc9b5f95cb0171494"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::computeskipgrams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPatternModelOptions.html">PatternModelOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexReference.html">IndexReference</a> *&#160;</td>
          <td class="paramname"><em>singleref</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexedData.html">IndexedData</a> *&#160;</td>
          <td class="paramname"><em>multiplerefs</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *&#160;</td>
          <td class="paramname"><em>constrainbymodel</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>exhaustive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Low-level function to compute skipgrams for a given pattern. See <a class="el" href="classPatternModel.html#acd4e0ecc0e796c894b994859b2c5ffb6">trainskipgrams()</a> instead. </p>

</div>
</div>
<a class="anchor" id="a06b0d7452c19849930d6b3d19888130d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::computestats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute statistics on the model, will generally be called automatically by methods who use it, and the statistics are cached after computation. </p>

</div>
</div>
<a class="anchor" id="a07eb601afe937b144e100cd96d091d3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::coverage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return coverage as a fraction of the total number of tokens in the model. For unindexed models this is a maximal projection rather than exact number. </p>

</div>
</div>
<a class="anchor" id="a5bad2b94ec96880f3e4307d55c42e492"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::coveragecount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the coverage count for the given pattern, for unindexed models, the coverage count is a mere maximum projection equal to the product of the occurence count and the size. </p>

</div>
</div>
<a class="anchor" id="a8881489a5a99215499809c6dcbe704e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPatternSet.html">PatternSet</a>&lt;uint64_t&gt; <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::extractset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minlength</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxlength</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classPatternSet.html" title="A pattern store in the form of an unordered set (i.e, no duplicates). Stores only patterns...">PatternSet</a> containing patterns of the specified length. Patterns are actively reconstructed from patterns in the model, if necessary. So this includes patterns that are not in the model explicitly (i.e, smaller patterns that have been pruned. </p>

</div>
</div>
<a class="anchor" id="aa4aa18a4d9e7554a3c798872e915e8a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="classPattern.html">Pattern</a>&gt; <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::findskipgrams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>occurrencethreshold</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a vector of all skipgrams that can be extracted from the tigven pattern </p>

</div>
</div>
<a class="anchor" id="a0927686caf05d2e1accff6e158a75188"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::frequency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the frequency of a pattern within its own group (category and size). For instance, if you pass a bigram you will get the occurence count as a fraction of the total occurrences of bigrams. </p>

<p>Implements <a class="el" href="classPatternModelInterface.html#abab22952ac502743377e3a5a524e2ae1">PatternModelInterface</a>.</p>

</div>
</div>
<a class="anchor" id="aaec0fa3d026d88bc5b8e2dc5f0994015"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ValueType* <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>makeifnew</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the value stored for the specified pattern. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">makeifnew</td><td>Add the pattern with empty value if it does not exist (default: false) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#a1ee41056c7235bf03573e6532cd5efce">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1baf331b3a10a45fdadd6a835a744cf3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ValueType* <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPatternPointer.html">PatternPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>patternpointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>makeifnew</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#a9311529a1123f602720b9e95f3f89236">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a564b582aba0eedacd4b0b6f2fa693f7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getinstances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a837bdbf478b7ea8a51ad674418926175"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPatternModelInterface.html">PatternModelInterface</a>* <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getinterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a more generic but limited <a class="el" href="classPatternModelInterface.html" title="Basic read-only interface for pattern models, abstract base class. ">PatternModelInterface</a> instance (polymorphism) </p>

</div>
</div>
<a class="anchor" id="aea7593acd2798e2e77ed5cb4e75d3f67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getleftneighbours </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aadea1e70400eb2aeced1ca1648cf9cd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getmodeltype </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the type of model (a value from ModelType) </p>

<p>Implements <a class="el" href="classPatternModelInterface.html#ad485931462c2f1c1bcd0aac13ec3028b">PatternModelInterface</a>.</p>

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#adeb6b2bce5dc4fcdd9f8ec9f723d0f5b">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac2f98f98d449951caa82894be78e9fe6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getmodelversion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the version of the model implementation and binary serialisation format </p>

<p>Implements <a class="el" href="classPatternModelInterface.html#a0d58b42e55df75e04faae361677aa777">PatternModelInterface</a>.</p>

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#adabaad88e64edd1c4762a56c86d1bae4">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0be06240959a62b03473c7a00ccebdd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="patternmodel_8h.html#ae13b52c8cf777358f19da17c90c7dac0">t_relationmap_double</a> <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getnpmi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad5d110daa1691b266ad325b1a2f7a842"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;<a class="el" href="classPattern.html">Pattern</a>, int&gt; &gt; <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getpatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get all patterns in pattern that occur in the patternmodel as a vector of pairs of Patterns and occurrence count. </p>

</div>
</div>
<a class="anchor" id="a6b37ea19d0646bff54cae15290fc884c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPattern.html">Pattern</a>&gt; <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getreverseindex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexReference.html">IndexReference</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>occurrencecount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a position in the corpus , return a vector of all the patterns that cover this position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>The position in the corpus </td></tr>
    <tr><td class="paramname">occurrencecount</td><td>If set above zero, filters to only include patterns occurring above this threshold </td></tr>
    <tr><td class="paramname">category</td><td>Set to any value of PatternCategory (NGRAM,SKIPGRAM,FLEXGRAM) to include only this category. Set to 0 for unfiltered (default) </td></tr>
    <tr><td class="paramname">size</td><td>Set to any value above zero to only include patterns of the specified length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abca7b37dfacef90de4e2139acb99cedb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;<a class="el" href="classIndexReference.html">IndexReference</a>,<a class="el" href="classPattern.html">Pattern</a>&gt; &gt; <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getreverseindex_bysentence </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sentence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns pairs of positions and patterns, consisting of all patterns found in the specified sentence (or whatever unit delimites your corpus) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sentence</td><td>The sentence index (starts at 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec29a383939fa71f61edfea80ea1b2d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;<a class="el" href="classIndexReference.html">IndexReference</a>,<a class="el" href="classPattern.html">Pattern</a>&gt; &gt; <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getreverseindex_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexReference.html">IndexReference</a>&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a position in the corpus , return a vector of all the positions and patterns (as pairs) that occur to the left of this position </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>The position in the corpus </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c49738d4296c9dde3ee2796d6b66814"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;<a class="el" href="classIndexReference.html">IndexReference</a>,<a class="el" href="classPattern.html">Pattern</a>&gt; &gt; <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getreverseindex_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexReference.html">IndexReference</a>&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a position in the corpus , return a vector of all the positions and patterns (as pairs) that occur to the right of this position </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>The position in the corpus </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad34484b6262acb5967de624a14e73085"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getrightneighbours </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa9d5de68d7989ba234d2628ab4af35fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getskipcontent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#ac2478fc9fd1eabfc616c1692fc2a58d9">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3b0fa1ea8423db319dfd6f338f7b2b40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getsubchildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5fb7d6ef4e82a300557f2e0350209a6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::getsubparents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a997f4cfc3e65fb218097061f9d4429ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="patternmodel_8h.html#a8695a2b10be5a74c827cd6c11bd46fb9">t_relationmap</a> <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::gettemplates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a577eb056f583b4efc943ac4e7a581b1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::has </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the given pattern occurs in the model </p>

<p>Implements <a class="el" href="classPatternStoreInterface.html#aec9f27496b38f8db1eced920fb2dc9fe">PatternStoreInterface</a>.</p>

</div>
</div>
<a class="anchor" id="af94a590e3c5eacde04cb55430198acfa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::has </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPatternPointer.html">PatternPointer</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does the pattern occur in the pattern store? </p>

<p>Implements <a class="el" href="classPatternStoreInterface.html#a6b3e80cd9021201ce8992ad6c293a354">PatternStoreInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a72c97f76cca2ba56099eb1559a7b0ddd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::histogram </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; unsigned int, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cap</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a histogram for the occurrence count of patterns </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>This will contain the to-be-computed histogram </td></tr>
    <tr><td class="paramname">threshold</td><td>Include only patterns at or above this occurrence threshold </td></tr>
    <tr><td class="paramname">cap</td><td>Include only this many of the top frequencies (0=unconstrained) </td></tr>
    <tr><td class="paramname">category</td><td>Set to any value of PatternCategory (NGRAM,SKIPGRAM,FLEXGRAM) to filter or to 0 to cover all </td></tr>
    <tr><td class="paramname">size</td><td>Set to any value above zero to only include only patterns of the specified length. (0 for all sizes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9edf12738542d8d8b0cc9aa06b5a69b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::histogram </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cap</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a histogram for the occurrence count of patterns and output it to the output stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OUT</td><td>the output stream </td></tr>
    <tr><td class="paramname">threshold</td><td>Include only patterns at or above this occurrence threshold </td></tr>
    <tr><td class="paramname">cap</td><td>Include only this many of the top frequencies (0=unconstrained) </td></tr>
    <tr><td class="paramname">category</td><td>Set to any value of PatternCategory (NGRAM,SKIPGRAM,FLEXGRAM) to filter or to 0 to cover all </td></tr>
    <tr><td class="paramname">size</td><td>Set to any value above zero to only include only patterns of the specified length. (0 for all sizes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a231e5e4c9ed49764b24718e4269b4256"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::info </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>OUT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output information about the model to the output stream, includes some statistics and technical details such as space requirements. </p>

</div>
</div>
<a class="anchor" id="a26de418f6998cac0f484a958597afccc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::load </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *&#160;</td>
          <td class="paramname"><em>constrainmodel</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a pattern model from file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The input filename </td></tr>
    <tr><td class="paramname">options</td><td>Options for reading, these act as filter for the data, allowing you to raise thresholds etc </td></tr>
    <tr><td class="paramname">constrainmodel</td><td>Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to NULL (no constraining) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbfb81964c7a6eb13d846dc11d2cc667"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::load </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *&#160;</td>
          <td class="paramname"><em>constrainmodel</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a pattern model from an input stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The input stream </td></tr>
    <tr><td class="paramname">options</td><td>Options for reading, these act as filter for the data, allowing you to raise thresholds etc </td></tr>
    <tr><td class="paramname">constrainmodel</td><td>Pointer to another pattern model which should be used to constrain the loading of this one, only patterns also occurring in the other model will be included. Defaults to NULL (no constraining) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0d63c6c6ada696e3a247e25df8487ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::maxlength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum length of patterns in this model </p>

<p>Implements <a class="el" href="classPatternModelInterface.html#acbe234679e86792765d3afade8ce014c">PatternModelInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a4777ec9b1e76ef3c2ccbc981dad15129"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::minlength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the minimum length of patterns in this model </p>

<p>Implements <a class="el" href="classPatternModelInterface.html#a53325f7b36c9cf0de4954b618eff2416">PatternModelInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a8f5bc659abbbdd456937e85642a97d40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::occurrencecount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the occurrenc count of the specified pattern, will return 0 if it does not exist in the model </p>

<p>Implements <a class="el" href="classPatternModelInterface.html#afd9ec4756bb723ee6bf94321f05f1b71">PatternModelInterface</a>.</p>

</div>
</div>
<a class="anchor" id="aafa8d87b4b2269e796d97902f3214d22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::output </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a107980d1345c1f20ba3284474220ee7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::outputcooc </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;&#160;</td>
          <td class="paramname"><em>classdecoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#a6ab1e2d6bf0a8aeed25a39c306e51c34">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a45da84761e93772df0465bca2780b9b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::outputcooc_npmi </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;&#160;</td>
          <td class="paramname"><em>classdecoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#a4e8d1bf4017173e8214cfd37bab576c1">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa350e235140e580526d381c626355b58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::outputrelations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;&#160;</td>
          <td class="paramname"><em>classdecoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3746e351f393bb6201f3b8df92881bb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::postread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a>&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#a82f5f4fffea239a4f5bde4d346691f5d">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5447228ff966dcb3c93c8c787ce31386"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::posttrain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a>&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#a4a39df881afb2ef2c6c4a29afe9aa6ff">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6d645bd24603696e77d6904c09d9b39c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;&#160;</td>
          <td class="paramname"><em>decoder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the contents of the pattern model, i.e. all patterns and associated counts, to the output stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output stream </td></tr>
    <tr><td class="paramname">decoder</td><td>The class decoder to use </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#a4a5f41aa99e3b93a9a816e9c21b9b790">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a58bbe1d44c4daf8560872f97d124a836"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print for one pattern only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output stream </td></tr>
    <tr><td class="paramname">decoder</td><td>The class decoder to use </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#aed4218c952b051b523d8d5a31c5c00fb">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a30b0bf9471b82119000b38c620ffc21e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::printmodel </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;&#160;</td>
          <td class="paramname"><em>decoder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just an alias for <a class="el" href="classPatternModel.html#a6d645bd24603696e77d6904c09d9b39c">print()</a> </p>

</div>
</div>
<a class="anchor" id="aaa497ee9bd6b1abe6ab4451fbf7272f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::printpattern </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for per-pattern <a class="el" href="classPatternModel.html#a6d645bd24603696e77d6904c09d9b39c">print()</a> </p>

</div>
</div>
<a class="anchor" id="aa5d23339ceb528e9cb7a02640bce392c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::printreverseindex </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassDecoder.html">ClassDecoder</a> &amp;&#160;</td>
          <td class="paramname"><em>decoder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the full reverse index, a mapping of indices and all patterns that occur at those positions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output stream </td></tr>
    <tr><td class="paramname">decoder</td><td>The class decoder to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3698c1c47789b2fb2eae65d96ed4e3ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::prune </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_n</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prune all patterns under the specified occurrence threshold (or -1 for all). Pruning can be limited to patterns of a particular size only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>The occurrence threshold (set to -1 to prune everything) </td></tr>
    <tr><td class="paramname">_n</td><td>The size constraint, limit to patterns of this size only (set to 0 for no constraint, default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of distinct patterns pruned </dd></dl>

</div>
</div>
<a class="anchor" id="a787ccf34c969a5e14aa2e1bdcb164ee7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType2 , class ValueHandler2 , class MapType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::prunebymodel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType2, ValueHandler2, MapType2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>secondmodel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prune all patterns that are not in the second model </p><dl class="section return"><dt>Returns</dt><dd>the number of distinct patterns pruned </dd></dl>

</div>
</div>
<a class="anchor" id="ab4429ca9cb19f12e4b0bb7b8cb0e6fe7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::prunenotinset </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="classPattern.html">Pattern</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prune all patterns that are not in the specified set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The set containing the patterns not to prune </td></tr>
    <tr><td class="paramname">_n</td><td>The size constraint, limit to patterns of this size only (set to 0 for no constraint, default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of distinct patterns pruned </dd></dl>

</div>
</div>
<a class="anchor" id="a30da80bd942ab1bac95ac9945f465702"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::pruneskipgrams </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minskiptypes</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_n</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prune all skipgrams under the specified occurrence threshold (or -1 for all). Pruning can be limited to patterns of a particular size only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>The occurrence threshold (set to -1 to prune everything) </td></tr>
    <tr><td class="paramname">_n</td><td>The size constraint, limit to patterns of this size only (set to 0 for no constraint, default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of distinct patterns pruned </dd></dl>

</div>
</div>
<a class="anchor" id="aee8c647241c7ec1a80e088b13e232a06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::report </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>OUT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output an elaborate statistical report to the output stream. Computes on first call when necessary. </p>

</div>
</div>
<a class="anchor" id="a25f387acaf981af9962195bd05b3e7e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of distinct patterns in the model </p>

<p>Implements <a class="el" href="classPatternStoreInterface.html#a225c319d318aad157512cd0001b05eb2">PatternStoreInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a21fb390761ae0fc47e3a48621c94698b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::test </td>
          <td>(</td>
          <td class="paramtype">MapType &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afac99feddfa4cf1dc44090c5148e518a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::tokens </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total amount of word/unigram tokens in the model </p>

<p>Implements <a class="el" href="classPatternModelInterface.html#aafea9a0f8fd453b85cffd18709a42ae7">PatternModelInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a1e4c12ee56b5ae88f4a5b140ac6a6a0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::topthreshold </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ad5fd4ad8ed72160938ca9a30d26201"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::totaloccurrencesingroup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtains statistics of the model: returns the total amount of occurrences within the specified group, the group consist of a category and a size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">category</td><td>Set to any value of PatternCategory (NGRAM,SKIPGRAM,FLEXGRAM) or to 0 to cover all </td></tr>
    <tr><td class="paramname">n</td><td>Set to any value above zero to only cover only patterns of the specified length. (0 for all sizes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38fd6f8f536a802d6653665aa4d48cbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::totalpatternsingroup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtains statistics of the model: returns the total amount of distinct patterns within the specified group, the group consist of a category and a size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">category</td><td>Set to any value of PatternCategory (NGRAM,SKIPGRAM,FLEXGRAM) or to 0 to cover all </td></tr>
    <tr><td class="paramname">n</td><td>Set to any value above zero to only cover only patterns of the specified length. (0 for all sizes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa5f43e06e2262fc4387729fc6265050"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::totaltokensingroup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtains statistics of the model: returns the total amount of covered tokens within the specified group, the group consist of a category and a size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">category</td><td>Set to any value of PatternCategory (NGRAM,SKIPGRAM,FLEXGRAM) or to 0 to cover all </td></tr>
    <tr><td class="paramname">n</td><td>Set to any value above zero to only cover only patterns of the specified length. (0 for all sizes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23de99349652ec0774db5d09593bd255"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::totalwordtypesingroup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtains statistics of the model: returns the total amount of word/unigtams types within the specified group, the group consist of a category and a size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">category</td><td>Set to any value of PatternCategory (NGRAM,SKIPGRAM,FLEXGRAM) or to 0 to cover all </td></tr>
    <tr><td class="paramname">n</td><td>Set to any value above zero to only cover only patterns of the specified length. (0 for all sizes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1e8a9a955f8da64abe95179482a6b55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::train </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPatternModelOptions.html">PatternModelOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *&#160;</td>
          <td class="paramname"><em>constrainbymodel</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Train a pattern model on corpus data (given an input stream) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The input stream of the corpus data (*.colibri.dat) </td></tr>
    <tr><td class="paramname">options</td><td>Options for training </td></tr>
    <tr><td class="paramname">constrainbymodel</td><td>Pointer to another pattern model which should be used to constrain the training of this one, only patterns also occurring in the other model will be included. Defaults to NULL (no constraining) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2390acee4c9aeecf1bce2d0b312bb4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::train </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *&#160;</td>
          <td class="paramname"><em>constrainbymodel</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Train a pattern model on corpus data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename of the corpus data (*.colibri.dat) </td></tr>
    <tr><td class="paramname">options</td><td>Options for training </td></tr>
    <tr><td class="paramname">constrainbymodel</td><td>Pointer to another pattern model which should be used to constrain the training of this one, only patterns also occurring in the other model will be included. Defaults to NULL (no constraining) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd4e0ecc0e796c894b994859b2c5ffb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::trainskipgrams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPatternModelOptions.html">PatternModelOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPatternModelInterface.html">PatternModelInterface</a> *&#160;</td>
          <td class="paramname"><em>constrainbymodel</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Train skipgrams, for indexed models only </p>

<p>Reimplemented in <a class="el" href="classIndexedPatternModel.html#acf0b5ec19f8b76b875dbef07ca0cb398">IndexedPatternModel&lt; MapType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7df468e440b875af0d9321d090f87dab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af5df3d30417804589c552320add3285a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total amount of word/unigram types in the model </p>

<p>Implements <a class="el" href="classPatternModelInterface.html#a5f3fab33835e8b01bf30b20793746e24">PatternModelInterface</a>.</p>

</div>
</div>
<a class="anchor" id="af56c31e031bb51d47e98cc433a46556e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3456e788caacd51fe3c7fb8fdf547723"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the pattern model to output stream </p>

</div>
</div>
<a class="anchor" id="a73654320cd52e691fd7df037cf3ff013"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the entire pattern model to file </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a2f9145b11bff161df5db3bcd33300319"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;int&gt; <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::cache_categories</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8ef56e648dc462352079542e9528df09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int,std::map&lt;int,unsigned int&gt; &gt; <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::cache_grouptotal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>total occurrences (used for frequency computation, within a group) </p>

</div>
</div>
<a class="anchor" id="a05db7c45b9368438f34dba519df3bb3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int,std::map&lt;int,unsigned int&gt; &gt; <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::cache_grouptotalpatterns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>total distinct patterns per group </p>

</div>
</div>
<a class="anchor" id="aebbf8c45dfa1993d1a9dd262b2b30783"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int,std::map&lt;int,unsigned int&gt; &gt; <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::cache_grouptotaltokens</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>total covered tokens per group </p>

</div>
</div>
<a class="anchor" id="a4dee966a62bacaab4d107bb4ec5050c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int,std::map&lt;int,unsigned int&gt; &gt; <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::cache_grouptotalwordtypes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>total covered word types per group </p>

</div>
</div>
<a class="anchor" id="a18c0c93e988cce16fdeb5a8a65e878b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;int&gt; <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::cache_n</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2f1b4eec80a00ef9c6effea477cc98f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::externalreverseindex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true if reverse index was loaded externally and passed to the model (implies it won't be destroyed when the model is) //only used by <a class="el" href="classIndexedPatternModel.html" title="An indexed model mapping patterns to values, high-level interface. This is a specialised subclass of ...">IndexedPatternModel</a> but stored here to ease things for cython </p>

</div>
</div>
<a class="anchor" id="a1070e4e96457caf4ae35d23c1e9ac5c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, std::vector&lt; std::vector&lt; std::pair&lt;int,int&gt; &gt; &gt; &gt; <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::gapconf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pre-computed structure of possible gap configurations various pattern lengths </p>

</div>
</div>
<a class="anchor" id="a9534e66035de7df26c9cd257e2faf7d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::hasskipgrams</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this model have skipgrams? </p>

</div>
</div>
<a class="anchor" id="ac0e501edfcca21facfe0137ed5140c87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::maxn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abed492e59e656226b1c48b10c2904618"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::minn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af28152ff3d5060e48c18423b8629d1eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::model_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a032f1517ae658e81fa2ca3360aba62a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::model_version</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a17ad27133991f964ccd23bb09bf64e5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexedCorpus.html">IndexedCorpus</a>* <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::reverseindex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the reverse index for this model (or NULL) </p>

</div>
</div>
<a class="anchor" id="a4667c917fab96ae756ee61693220f44e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::totaltokens</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of tokens in the original corpus, so INCLUDES TOKENS NOT COVERED BY THE MODEL! </p>

</div>
</div>
<a class="anchor" id="af9de224847465b75a9be436b1990cef7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, class ValueHandler = BaseValueHandler&lt;ValueType&gt;, class MapType = PatternMap&lt;ValueType, BaseValueHandler&lt;ValueType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classPatternModel.html">PatternModel</a>&lt; ValueType, ValueHandler, MapType &gt;::totaltypes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of unigram/word types in the original corpus, SO INCLUDING NOT COVERED BY THE MODEL! </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="patternmodel_8h_source.html">patternmodel.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 16 2015 13:32:48 for Colibri Core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
