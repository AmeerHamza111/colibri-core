

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Colibri Documentation &mdash; Colibri Core 0.1 documentation</title>
    
    <link rel="stylesheet" href="static/default.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <link rel="top" title="Colibri Core 0.1 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">Colibri Core 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="colibri-documentation">
<h1>Colibri Documentation<a class="headerlink" href="#colibri-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Colibri Core is a set of tools as well as a C++ and Python library for working with basic linguistic constructions such as n-grams and skipgrams (i.e patterns with one or more gaps, either of fixed or dynamic size) in a quick and memory-efficient way. At the core is the tool <tt class="docutils literal"><span class="pre">colibri-patternmodeller</span></tt> which allows you to build, view, manipulate and query pattern models.</p>
<p>The Colibri software is developed in the scope of the Ph.D. research project <strong>Constructions as Linguistic Bridges</strong>. This research examines the identification and extraction of aligned constructions or patterns across natural languages, and the usage of such constructions in Machine Translation. The aligned constructions are not identified on the basis of an extensive and explicitly defined grammar or expert database of linguistic knowledge, but rather are implicitly distilled from large amounts of example data. Our notion of constructions is broad and transcends the idea of words or variable-length phrases.</p>
<p>This documentation will illustrate how to work with the various tools and the library of colibri, as well as elaborate on the implementation of certain key aspects of the software.</p>
</div>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>Colibri is hosted on <a class="reference external" href="http://github.com/proycon/colibri-core/">github</a> and should be retrieved through the versioning control system <tt class="docutils literal"><span class="pre">git</span></tt>. Provided git is installed on your system, this is done as follows:</p>
<div class="highlight-python"><pre>$ git clone http://github.com/proycon/colibri-core.git</pre>
</div>
<p>You need to compile the software, if you want FoLiA support you will need to first to install the following dependency. By default FoLiA support is disabled.</p>
<blockquote>
<div><ul class="simple">
<li><strong>libfolia</strong>; obtainable from <a class="reference external" href="http://proycon.github.com/folia">the FoLiA website</a>,  follow the instructions included with libfolia to install it.</li>
</ul>
</div></blockquote>
<p>In addition to the C/C++ compiler (<tt class="docutils literal"><span class="pre">gcc</span></tt>), the build process for colibri makes use of <tt class="docutils literal"><span class="pre">autoconf</span></tt> and <tt class="docutils literal"><span class="pre">automake</span></tt>. Make sure these are installed on your system. Also install the package <tt class="docutils literal"><span class="pre">autoconf-archive</span></tt> if available on your distribution. Colibri can now be compiled and installed:</p>
<div class="highlight-python"><pre>$ cd colibri
$ bash bootstrap
$ ./configure [--with-folia --with-folia-path=/path/to/libfolia]
$ make
$ make install</pre>
</div>
<p>You can optionally pass a prefix if you want to install colibri in a different location:</p>
<div class="highlight-python"><pre>$ ./configure --prefix=/usr/local/</pre>
</div>
<div class="section" id="keeping-colibri-up-to-date">
<h3>Keeping colibri up to date<a class="headerlink" href="#keeping-colibri-up-to-date" title="Permalink to this headline">¶</a></h3>
<p>Colibri is always under heavy development. Update your colibri copy by issuing a git pull:</p>
<div class="highlight-python"><pre>$ git pull</pre>
</div>
<p>And then recompile as per the above instructions.</p>
</div>
<div class="section" id="general-usage-instructions">
<h3>General usage instructions<a class="headerlink" href="#general-usage-instructions" title="Permalink to this headline">¶</a></h3>
<p>Colibri consist of various programs, each of which will output an extensive overview of available parameters if the parameter <tt class="docutils literal"><span class="pre">-h</span></tt> is passed. Each program is designed for a specialised purpose, with specific input and output formats. It is often needed to call multiple programs in succession to obtain the final analysis or model you desire.</p>
</div>
</div>
<div class="section" id="corpus-class-encoding">
<h2>Corpus Class Encoding<a class="headerlink" href="#corpus-class-encoding" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Introduction<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Computation on large datasets begs for solutions to keep memory consumption
manageable. Colibri requires that input corpora are converted into a compressed
binary form. In this form each word-type in the corpus is represented by a
numeric class. Highly frequent word-types get assigned low class numbers and
less frequent word-types get higher class numbers. The class is represented in
a dynamic-width byte-array, rather than a fixed-width integer.Patterns are
encoded per word, each word starts with a size marker of one byte indicating the number of bytes
are used for that word. The specified number of bytes that follow encode the
word class. Instead of a size marker, byte values of 128 and above are reserved for special markers,
such as encoding gaps and structural data. Finally, the pattern as a whole is
ended by a null byte.</p>
<p>All internal computations of all tools in colibri proceed on this internal
representation rather than actual textual strings, keeping running time shorter
and memory footprint significantly smaller.</p>
</div>
<div class="section" id="class-encoding-your-corpus">
<h3>Class-encoding your corpus<a class="headerlink" href="#class-encoding-your-corpus" title="Permalink to this headline">¶</a></h3>
<p>When working with colibri, you first want to <strong>class encode</strong> your corpus. This is done by the program <tt class="docutils literal"><span class="pre">colibri-classencode</span></tt>. It takes as input a <em>tokenised</em> monolingual corpus in plain text format, containing <em>one sentence per line</em>. Each line should be delimited by a single newline character (unix line endings). Colibri is completely agnostic when it comes to the character encoding of the input. Given a corpus file <tt class="docutils literal"><span class="pre">yourcorpus</span></tt>, class encoding is done as follows:</p>
<div class="highlight-python"><pre>$ colibri-classencode yourcorpus</pre>
</div>
<p>This results in two files:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">yourcorpus.colibri.cls</span></tt> - This is the class file; it lists all word-types and class numbers.</li>
<li><tt class="docutils literal"><span class="pre">yourcorpus.colibri.dat</span></tt> - This is the corpus is encoded binary form. It is a lossless compression that is roughly half the size of the original</li>
</ul>
</div></blockquote>
<p>If your corpus is not tokenised yet, you can consider using the tokeniser <a class="reference external" href="http://ilk.uvt.nl/ucto">ucto</a> (not part of colibri), this will also do sentence detection and output one line per sentence:</p>
<div class="highlight-python"><pre>$ ucto -L en -n untokenisedcorpus.txt &gt; tokenisedcorpus.txt</pre>
</div>
<p>The above sample is for English (<tt class="docutils literal"><span class="pre">-L</span> <span class="pre">en</span></tt>), several other languages are also supported.</p>
<p>In addition to this plain text input. The class encoder also supports <em>FoLiA XML</em> (<a class="reference external" href="http://proycon.github.com/folia">folia website</a>) if you compiled with FoLiA support, make sure such files end with the extension <tt class="docutils literal"><span class="pre">xml</span></tt> and they will be automatically interpreted as FoLiA XML:</p>
<div class="highlight-python"><pre>$ colibri-classencode yourcorpus.xml</pre>
</div>
<p>It is possible to encode multiple corpus files similtaneously, but generating a joined class file:</p>
<div class="highlight-python"><pre>$ colibri-classencode yourcorpus1 yourcorpus2</pre>
</div>
<p>This results in <tt class="docutils literal"><span class="pre">yourcorpus1.colibri.cls</span></tt> and <tt class="docutils literal"><span class="pre">yourcorpus1.colibri.dat</span></tt> and <tt class="docutils literal"><span class="pre">yourcorpus2.colibri.dat</span></tt>. The class file spans both despite the name. An explicit name can be passed with the <tt class="docutils literal"><span class="pre">-o</span></tt> flag. It is also possible to encode multiple corpora in a single unified file by passing the <tt class="docutils literal"><span class="pre">-u</span></tt> flag. This is often desired if you want to train a pattern model on all the joined data:</p>
<div class="highlight-python"><pre>$ colibri-classencode -o out -u yourcorpus1 yourcorpus2</pre>
</div>
<p>This will produce <tt class="docutils literal"><span class="pre">out.colibri.dat</span></tt> and <tt class="docutils literal"><span class="pre">out.colibri.cls</span></tt>.</p>
<p>If you want to specify a large number of files, you can use the <tt class="docutils literal"><span class="pre">-l</span></tt> flag and specify a filename from which all input filenames will be read, one per line.</p>
</div>
<div class="section" id="class-decoding-your-corpus">
<h3>Class-decoding your corpus<a class="headerlink" href="#class-decoding-your-corpus" title="Permalink to this headline">¶</a></h3>
<p>Given an encoded corpus and a class file, the original corpus can always be reconstructed. This we call <em>class decoding</em> and is done using the <tt class="docutils literal"><span class="pre">colibri-classdecode</span></tt> program:</p>
<div class="highlight-python"><pre>$ colibri-classdecode -f yourcorpus.colibri.dat -c yourcorpus.colibri.cls</pre>
</div>
<p>Partial decoding can be done by specifying start and end line numbers using the
flags <tt class="docutils literal"><span class="pre">-s</span></tt> and <tt class="docutils literal"><span class="pre">-e</span></tt> respectively.</p>
<p>Output will be to <tt class="docutils literal"><span class="pre">stdout</span></tt>, you can redirect it to a file as follows:</p>
<div class="highlight-python"><pre>$ colibri-classdecode -f yourcorpus.colibri.dat -c yourcorpus.colibri.cls &gt; yourcorpus.txt</pre>
</div>
</div>
<div class="section" id="class-encoding-with-existing-classes">
<h3>Class-encoding with existing classes<a class="headerlink" href="#class-encoding-with-existing-classes" title="Permalink to this headline">¶</a></h3>
<p>Sometimes you want to encode new data using the same classes already used for another data set. For instance when comparing corpora, it is vital that the same classes are used, i.e. that identical words are assigned identical numerical classes. This also applies when you are working with a training set and a separate test set, or are otherwise interested in a comparative analysis between two comparable datasets. The initial class file is built on the training set, and it can be reused to encode the test set:</p>
<p>You can encode a dataset, here named <tt class="docutils literal"><span class="pre">testset.txt</span></tt> using an existing class file, <tt class="docutils literal"><span class="pre">trainset.colibri.cls</span></tt>, as follows:</p>
<div class="highlight-python"><pre>$ colibri-classencode -f testset.txt -c trainset.colibri.cls</pre>
</div>
<p>This will result in an encoded corpus <tt class="docutils literal"><span class="pre">testset.colibri.dat</span></tt> and an <em>extended</em> class file <tt class="docutils literal"><span class="pre">testset.colibri.cls</span></tt>, which is a superset of the original <tt class="docutils literal"><span class="pre">trainset.cls</span></tt>, adding only those classes that did not yet exist in the training data.</p>
</div>
</div>
<div class="section" id="pattern-modeller">
<h2>Pattern Modeller<a class="headerlink" href="#pattern-modeller" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id2">
<h3>Introduction<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">colibri-patternmodeller</span></tt> program is used to create pattern models capturing recurring patterns from a monolingual corpus. The extracted patterns are n-grams or skip-grams, where a skip-gram is an n-gram with one or more gaps of either a predefined size, thus containing unspecified or wildcard tokens, or of dynamic width.</p>
<p>In the internal pattern representation, in the place of the size marker, byte
value 128 is used for a fixed gap of a single token, and can be repeated for
gaps of longer length, byte value 129 is used for a gap of unspecified dynamic
width.</p>
<p>The pattern finding algorithm is iterative in nature and is guaranteed to find
all n-grams above a specified occurrence threshold and optionally given a
maximum size for n. It does so by iterating over the corpus n times, iterating
over all possible values for n in ascending order. At each iteration, a sliding
window extracts all n-grams in the corpus for the size is question. An n-gram
is counted in a hashmap data structure only if both n-1-grams it by definition
contains are found during the previous iteration with an occurrence above the
set threshold.  The exception are unigrams, which are all by definition counted
if they reach the threshold, as they are already atomic in nature. At the end
of each iteration, n-grams not making the occurrence threshold are
pruned. This simple iterative technique reduces the memory footprint compared
to the more naive approach of immediately storing all in a hashmap, as it
prevents the storing of lots of patterns not making the threshold by discarding
them at an earlier stage.</p>
<p>At the beginning of each iteration of n, all possible ways in which any n-gram
of size n can contain gaps is computed. When an n-gram is found, various
skip-grams are tried in accordance with these gap configurations. This is
accomplished by &#8216;punching holes&#8217; in the n-gram, resulting in a skip-gram. If
all consecutive parts of this skip-gram were counted during previous iterations
and thus made the threshold, then the skip-gram as a whole is counted,
otherwise it is discarded. After each iteration, pruning again takes places to
prune skip-grams that are not frequent enough.</p>
<p>The pattern finder can create either indexed or unindexed models. For indexed
models, the precise location of where an n-gram or skipgram instance was found
in the corpus is recorded. This comes at the cost of much higher memory usage,
but is necessary for more strongly constrained skip extraction, as well as for
extracting relations between patterns at a later stage. Indexed models by
default also maintain a reverse index allowing, and even unindexed models do so
during building.</p>
<p>Note that for fixed-size skipgrams in indexed models, the various fillings
for the gaps can be reconstructed precisely.</p>
<p>If you are only interested in simple n-gram or simple skip-gram counts, then an
unindexed model may suffice.</p>
</div>
<div class="section" id="creating-a-pattern-model">
<h3>Creating a pattern model<a class="headerlink" href="#creating-a-pattern-model" title="Permalink to this headline">¶</a></h3>
<p>First make sure to have class-encoded your corpus. Given this encoded corpus,
<tt class="docutils literal"><span class="pre">colibri-patternmodeller</span></tt> can be invoked to produce an indexed pattern model.
Always specify the output file using the <tt class="docutils literal"><span class="pre">-o</span></tt> flag. The occurrence threshold
is specified with parameter <tt class="docutils literal"><span class="pre">-t</span></tt>, patterns occuring less will not be counted.
The default value is two.  The maximum value for n, i.e. the maximum
n-gram/skipgram size, can be restricted using the parameter <tt class="docutils literal"><span class="pre">-l</span></tt>.:</p>
<div class="highlight-python"><pre>$ colibri-patternmodeller -f yourcorpus.dat -t 10 -o yourcorpus.colibri.indexedpatternmodel</pre>
</div>
<p>This outputted model <tt class="docutils literal"><span class="pre">yourcorpus.colibri.indexedpatternmodel</span></tt> is stored in a
binary format. To print it into a human readable presentation it needs to be
decoded. The <tt class="docutils literal"><span class="pre">colibri-patternmodeller</span></tt> program can do this by specifying an
input model using the <tt class="docutils literal"><span class="pre">-i</span></tt> flag, the class file using the <tt class="docutils literal"><span class="pre">-c</span></tt> parameter,
and the desired action to print it all using <tt class="docutils literal"><span class="pre">-P</span></tt>:</p>
<div class="highlight-python"><pre>$ colibri-patternmodeller -i yourcorpus.colibri.indexedpatternmodel -c yourcorpus.colibri.cls -P</pre>
</div>
<p>Optionally, instead of or in addition to outputting a model to file using
<tt class="docutils literal"><span class="pre">-o</span></tt>, you can also print it directly with <tt class="docutils literal"><span class="pre">-P</span></tt>.</p>
<p>Output will be to <tt class="docutils literal"><span class="pre">stdout</span></tt> in a tab delimited format, with the first line
reserved for the header. This facilitates easy parsing as you can just load it
into any software accepting CSV files, such as spreadsheets. An excerpt
follows:</p>
<div class="highlight-python"><pre>PATTERN     COUNT   TOKENS  COVERAGE        CATEGORY        SIZE    FREQUENCY       REFERENCES
For 2       2       0.0059  ngram   1       0.0121  11:0 15:0
death       2       2       0.0059  ngram   1       0.0121  11:5 23:7
who 2       2       0.0059  ngram   1       0.0121  15:1 21:5
.   4       4       0.0118  ngram   1       0.0242  5:6 9:4 10:6 13:4
be  4       4       0.0118  ngram   1       0.0242  1:1 1:5 9:2 35:3
flee        2       2       0.0059  ngram   1       0.0121  36:1 36:5
not to      4       8       0.0235  ngram   2       0.1538  1:3 36:3 37:3 38:3</pre>
</div>
<p>The various columns are:</p>
<ul class="simple">
<li><strong>Pattern</strong> - The actual pattern. Gaps in skipgrams are represented as <tt class="docutils literal"><span class="pre">{*x*}</span></tt> where x is a number representing the size of the skip. Variable-width skipgrams are just <tt class="docutils literal"><span class="pre">{*}</span></tt>.</li>
<li><strong>Occurrence count</strong> - The absolute number of times this pattern occurs</li>
<li><strong>Tokens</strong> - The absolute number of tokens in the corpus that this pattern covers. Computed as <tt class="docutils literal"><span class="pre">occurrencecount</span> <span class="pre">*</span> <span class="pre">n</span></tt>.</li>
<li><strong>Coverage</strong> - The number of covered tokens, as a fraction of the total number of tokens.</li>
<li><strong>Category</strong> - The type of pattern.</li>
<li><strong>Size</strong> - The length of the n-gram or skipgram in words/tokens.</li>
<li><strong>Frequency</strong> - The frequency of the pattern <em>within its category and
size class</em>, so for an ngram of size two, the frequency indicates the
frequency amongst all bigrams.</li>
<li><strong>References</strong> - A space-delimited list of indices in the corpus that correspond to a occurrence of this pattern. Indices are in the form <tt class="docutils literal"><span class="pre">sentence:token</span></tt> where sentence starts at one and token starts at zero. This column is only available for indexed models.</li>
</ul>
<p>The pattern model created in the previous example did not yet include skip-grams, these have to be explicitly enabled with the <tt class="docutils literal"><span class="pre">-s</span></tt> flag. When this is used, another options becomes available for consideration:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-T</span> <span class="pre">[value]</span></tt> - Only skipgrams that have at least this many different types
as skip content, i.e. possible options filling the gaps, will be considered.
The default is set to two.</li>
</ul>
<p>Here is an example of generating an indexed pattern model including skipgrams:</p>
<div class="highlight-python"><pre>$ colibri-patternmodeller -f yourcorpus.colibri.dat -t 10 -s -T 3 -o yourcorpus.colibri.indexedpatternmodel</pre>
</div>
<p>If you want to generate unindexed models, simply add the flag <tt class="docutils literal"><span class="pre">-u</span></tt>. Do note
that for unindexed models the parameter <tt class="docutils literal"><span class="pre">-T</span></tt> has no effect, it will extract
all skipgrams it can find as if <tt class="docutils literal"><span class="pre">-T</span></tt> were set to one! If you want decent
skpigrams, you&#8217;re best off with an indexed model. Note that indexed models can
always be read and printed in an unindexed way (with the <tt class="docutils literal"><span class="pre">-u</span></tt> flag); but
unindexed models can not be read in an indexed way, as they simply lack
indices:</p>
<div class="highlight-python"><pre>$ colibri-patternmodeller -i yourcorpus.colibri.indexedpatternmodel -c yourcorpus.colibri.cls -u -P
$ colibri-patternmodeller -i yourcorpus.colibri.unindexedpatternmodel -c yourcorpus.colibri.cls -u -P</pre>
</div>
</div>
<div class="section" id="statistical-reports-and-histograms">
<h3>Statistical reports and histograms<a class="headerlink" href="#statistical-reports-and-histograms" title="Permalink to this headline">¶</a></h3>
<p>If you have a pattern model, you can generate a statistical report which includes information on the number of occurrences and number of types for patterns, grouped for n-grams or skipgrams for a specific value of <em>n</em>. A report is generated using the <tt class="docutils literal"><span class="pre">-R</span></tt> flag, the input model is specified using <tt class="docutils literal"><span class="pre">-i</span></tt>:</p>
<div class="highlight-python"><pre>$ colibri-patternmodeller -i yourcorpus.colibri.indexedpatternmodel -R</pre>
</div>
<p>Example output:</p>
<div class="highlight-python"><pre>REPORT
----------------------------------
                            PATTERNS    TOKENS  COVERAGE     TYPES
Total:                             -       340         -       177
Uncovered:                         -       175    0.5147       136
Covered:                          69       165    0.4853        41

  CATEGORY N (SIZE)   PATTERNS    TOKENS  COVERAGE     TYPES OCCURRENCES
       all       all        69       165    0.4853        41         243
       all         1        40       165    0.4853        40         165
       all         2        11        26    0.0765        13          26
       all         3         7        17    0.0500         9          19
       all         4         5        10    0.0294         9          14
       all         5         5         9    0.0265         9          17
       all         6         1         2    0.0059         6           2
    n-gram       all        62       165    0.4853        40         215
    n-gram         1        40       165    0.4853        40         165
    n-gram         2        11        26    0.0765        13          26
    n-gram         3         5        12    0.0353         8          12
    n-gram         4         3         6    0.0176         6           6
    n-gram         5         2         4    0.0118         6           4
    n-gram         6         1         2    0.0059         6           2
  skipgram       all         7         7    0.0206         6          28
  skipgram         3         2         7    0.0206         4           7
  skipgram         4         2         4    0.0118         4           8
  skipgram         5         3         5    0.0147         5          13</pre>
</div>
<p>Some explanation is in order to correctly interpret this data. There are three
columns:</p>
<blockquote>
<div><ul class="simple">
<li><strong>Pattern</strong> - The number of distinct patterns</li>
<li><strong>Tokens</strong> - The number of tokens that is covered. This is only available
for indexed models, for unindexed models it is either omitted or the
number shown is maximum projection.</li>
<li><strong>Coverage</strong> - The number of tokens covered as a fraction of the total number of tokens. Only for indexed models.</li>
<li><strong>Types</strong> - The number of unique <strong>word</strong> types covered</li>
<li><strong>Occurrences</strong> - Cumulative occurrence count of all the patterns in
the group. Used as a basis for computing frequency.</li>
</ul>
</div></blockquote>
<p>Pattern models store how many of the tokens and types in the original corpus were covered. Tokens and types not covered did not make the set thresholds. Make sure to use indexed models if you want accurate coverage data.</p>
<p>Similarly, a histogram can also be generated, using the <tt class="docutils literal"><span class="pre">-H</span></tt> flag:</p>
<div class="highlight-python"><pre>$ colibri-patternmodeller -i yourcorpus.colibri.indexedpatternmodel -H</pre>
</div>
<p>Example output:</p>
<div class="highlight-python"><pre>OCCURRENCES   PATTERNS
2   39
3   5
4   13
5   5
6   1
7   1
8   1
10  1
13  1
14  1
15  1</pre>
</div>
</div>
<div class="section" id="filtering-models">
<h3>Filtering models<a class="headerlink" href="#filtering-models" title="Permalink to this headline">¶</a></h3>
<p>Patterns models can be read with <tt class="docutils literal"><span class="pre">-i</span></tt> and filtered by setting stricter thresholds prior to printing, reporting or outputting to file. An example:</p>
<div class="highlight-python"><pre>$ colibri-patternmodeller -i yourcorpus.colibri.indexedpatternmodel -t 20 -T 10 -o yourcorpus_filtered.colibri.indexedpatternmodel -P</pre>
</div>
</div>
<div class="section" id="training-and-testing-coverage">
<h3>Training and testing coverage<a class="headerlink" href="#training-and-testing-coverage" title="Permalink to this headline">¶</a></h3>
<p>An important quality of pattern models lies in the fact that pattern models can
be compared. More specifically, you can train a pattern model on a corpus and
test it on another corpus, which yields another pattern model containing only
those patterns that occur in both training and test data. The difference in
count, frequency and coverage can then be easily be compared. You build such a
model by taking the intersection with a training model using the <tt class="docutils literal"><span class="pre">-j</span></tt> flag.
Make sure to always use the same class file for all datasets you are comparing.
Instructions for this were given in <em class="xref std std-ref">classencodetraintest</em>.</p>
<dl class="docutils">
<dt>Training::</dt>
<dd>$ colibri-patternmodeller -f trainset.colibri.dat -o trainset.colibri.indexedpatternmodel</dd>
</dl>
<p>This results in a model <tt class="docutils literal"><span class="pre">trainset.colibri.indexedpatternmodel</span></tt>. Now proceed
with testing on another corpus:</p>
<dl class="docutils">
<dt>Testing::</dt>
<dd>$ colibri-patternmodeller -f testset.colibri.dat -j trainset.indexedpatternmodel.colibri -o testset.colibri.indexedpatternmodel</dd>
</dl>
<p>This results in a model <tt class="docutils literal"><span class="pre">testset.colibri.indexedpatternmodel</span></tt> that only contains patterns that also occur in the specified training model.</p>
<p>Such an intersection of models can also be created at any later stage using
<tt class="docutils literal"><span class="pre">-i</span></tt> and <tt class="docutils literal"><span class="pre">-j</span></tt>.</p>
</div>
<div class="section" id="query-mode">
<h3>Query mode<a class="headerlink" href="#query-mode" title="Permalink to this headline">¶</a></h3>
<p>The pattern modeller has query mode which allows you to quickly extract patterns from test sentences or fragments thereof. The query mode is invoked by loading a pattern model (<tt class="docutils literal"><span class="pre">-i</span></tt>), a class file (<tt class="docutils literal"><span class="pre">-c</span></tt>) and the <tt class="docutils literal"><span class="pre">-Q</span></tt> flag. The query mode can be run interactively as it takes input from <tt class="docutils literal"><span class="pre">stdin</span></tt>, one <em>tokenised</em> sentence per line. The following example illustrates this, the sentence <em>&#8220;To be or not to be&#8221;</em> was typed as input:</p>
<div class="highlight-python"><pre>$ colibri-patternmodeller -i /tmp/data.colibri.patternmodel -c /tmp/hamlet.colibri.cls -Q
Loading class decoder from file /tmp/hamlet.colibri.cls
Loading class encoder from file /tmp/hamlet.colibri.cls
Loading indexed pattern model /tmp/data.colibri.patternmodel as input model...
Colibri Patternmodeller -- Interactive query mode.
Type ctrl-D to quit, type X to switch between exact mode and extensive mode (default: extensive mode).
1&gt;&gt; To be or not to be
1:0 To      8               8       0.0235294       ngram   1       0.0484848   1:0 5:7 9:5 10:0 22:0 36:0 37:0 38:0
1:1 be      4               4       0.0117647       ngram   1       0.0242424   1:1 1:5 9:2 35:3
1:2 or      4               4       0.0117647       ngram   1       0.0242424   1:2 36:2 37:2 38:2
1:3 not     5               5       0.0147059       ngram   1       0.030303    1:3 27:7 36:3 37:3 38:3
1:4 to      13              13      0.0382353       ngram   1       0.0787879   1:4 2:6 4:1 5:10 6:7 8:4 9:1 9:8 10:4 27:2 36:4 37:4 38:4
1:2 or not  4               8       0.0235294       ngram   2       0.153846    1:2 36:2 37:2 38:2
1:3 not to  4               8       0.0235294       ngram   2       0.153846    1:3 36:3 37:3 38:3
1:2 or not to       4               12      0.0352941       ngram   3       0.333333    1:2 36:2 37:2 38:2</pre>
</div>
<p>The output starts with an index in the format <tt class="docutils literal"><span class="pre">sentence:token</span></tt>, specifying
where the pattern found was found in your input. The next columns are the same
as the print output.The interactive query mode distinguishes two modes,
extensive mode and exact mode. In extensive mode, your input string will be
scanned for all patterns occurring in it. In exact mode, the input you
specified needs to match exactly and as a whole. Type <tt class="docutils literal"><span class="pre">X</span></tt> to switch between
the modes.</p>
<p>In addition to interactive query mode, there is also a command line query mode
<tt class="docutils literal"><span class="pre">-q</span></tt> in which you specify the pattern you want to query as argument on the command
line. Multiple patterns can be specified by repeating the <tt class="docutils literal"><span class="pre">-q</span></tt> flag. This
mode always behaves according to exact mode:</p>
<div class="highlight-python"><pre>$ colibri-patternmodeller -i /tmp/data.colibri.patternmodel -c /tmp/hamlet.colibri.cls -q "to be"
Loading class decoder from file /tmp/hamlet.colibri.cls
Loading class encoder from file /tmp/hamlet.colibri.cls
Loading indexed pattern model /tmp/data.colibri.patternmodel as input model...
to be       2               4       0.0117647       ngram   2       0.0769231   1:4 9:1</pre>
</div>
</div>
<div class="section" id="pattern-relations">
<h3>Pattern Relations<a class="headerlink" href="#pattern-relations" title="Permalink to this headline">¶</a></h3>
<p>A pattern model contains a wide variety of patterns; the relationships between those can be made explicit. These relationships can be imagined as a directed graph, in which the nodes represent the various patterns (n-grams and skipgrams), and the edges represent the relations. The following relations are distinguished; note that as the graph is directed relations often come in pairs; one relationship for each direction:</p>
<ul class="simple">
<li><strong>Subsumption relations</strong> - Patterns that are subsumed by larger patterns are called <em>subsumption children</em>, the larger patterns are called <em>subsumption parents</em>. These are the two subsumption relations that can be extracted from an indexed pattern model.</li>
<li><strong>Successor relations</strong>  - Patterns that follow eachother are in a left-of/right-of relation.</li>
<li><strong>Instantiation relations</strong> - There is a relation between skipgrams and
patterns that instantiate them <tt class="docutils literal"><span class="pre">to</span> <span class="pre">be</span> <span class="pre">{*1*}</span> <span class="pre">not</span> <span class="pre">{*1*}</span> <span class="pre">be</span></tt> is instantiated
by <tt class="docutils literal"><span class="pre">to</span> <span class="pre">{*1*}</span> <span class="pre">or</span></tt>, also referred to as the skip content.</li>
</ul>
<p>You can all of these extract relations using the <tt class="docutils literal"><span class="pre">-r</span></tt> flag, which is to be
used in combination with the query mode <tt class="docutils literal"><span class="pre">-Q</span></tt> or <tt class="docutils literal"><span class="pre">-q</span></tt>. Consider the
following sample:</p>
<div class="highlight-python"><pre>$ colibri-patternmodeller -i /tmp/data.colibri.patternmodel -c /tmp/hamlet.colibri.cls -q "to be" -r
Loading class decoder from file /tmp/hamlet.colibri.cls
Loading class encoder from file /tmp/hamlet.colibri.cls
Loading indexed pattern model /tmp/data.colibri.patternmodel as input model...
Post-read processing (indexedmodel)
to be       2               4       0.0117647       ngram   2       0.0769231       1:4 9:1
#   PATTERN1        RELATION        PATTERN2        REL.COUNT       REL.FREQUENCY   COUNT2
    to be   SUBSUMES        to      2       0.5     13
    to be   SUBSUMES        be      2       0.5     4
    to be   RIGHT-NEIGHBOUR-OF      To {*1*} or not 1       0.25    4
    to be   RIGHT-NEIGHBOUR-OF      To {*2*} not    1       0.25    4
    to be   RIGHT-NEIGHBOUR-OF      not     1       0.25    5
    to be   RIGHT-NEIGHBOUR-OF      or not  1       0.25    4</pre>
</div>
<p>The following columns are reported, all are indented with a single tab so
possible parsers can distinguish the numbers for the queried pattern itself from the relationships with other patterns.</p>
<blockquote>
<div><ul class="simple">
<li><strong>Pattern 1</strong> &#8211; The pattern you queried</li>
<li><strong>Relation</strong> &#8211; The nature of the relationship between pattern 1 and pattern 2</li>
<li><strong>Pattern 2</strong> &#8211; The pattern that is related to the queried pattern</li>
<li><strong>Relation Count</strong> &#8211; The number of times pattern 1 and pattern 2 occur in this relation</li>
<li><strong>Relation Frequency</strong> &#8211; The number of times pattern 1 and pattern 2 occur in this relationas a fraction of all relations of this type</li>
<li><strong>Count 2</strong> &#8211; The absolute number of occurrences of pattern 2 in the model</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="python-api-reference">
<h2>Python API Reference<a class="headerlink" href="#python-api-reference" title="Permalink to this headline">¶</a></h2>
<p>Colibri Core offers both a C++ API as well as a Python API. It exposes all of
the functionality, and beyond, of the tools outlined above. The Python API is
more limited than the C++ API, yet still offers most higher-level functionality.</p>
<span class="target" id="module-colibricore"></span><dl class="class">
<dt id="colibricore.Category">
<em class="property">class </em><tt class="descclassname">colibricore.</tt><tt class="descname">Category</tt><a class="headerlink" href="#colibricore.Category" title="Permalink to this definition">¶</a></dt>
<dd><p>Pattern Category</p>
<dl class="attribute">
<dt id="colibricore.Category.FLEXGRAM">
<tt class="descname">FLEXGRAM</tt><em class="property"> = 3</em><a class="headerlink" href="#colibricore.Category.FLEXGRAM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.Category.NGRAM">
<tt class="descname">NGRAM</tt><em class="property"> = 1</em><a class="headerlink" href="#colibricore.Category.NGRAM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.Category.SKIPGRAM">
<tt class="descname">SKIPGRAM</tt><em class="property"> = 2</em><a class="headerlink" href="#colibricore.Category.SKIPGRAM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.Category.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'colibricore'</em><a class="headerlink" href="#colibricore.Category.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="colibricore.ClassDecoder">
<em class="property">class </em><tt class="descclassname">colibricore.</tt><tt class="descname">ClassDecoder</tt><a class="headerlink" href="#colibricore.ClassDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>The Class Decoder allows Patterns to be decoded back to their string representation. An instance of ClassDecoder is passed to Pattern.tostring()</p>
<dl class="attribute">
<dt id="colibricore.ClassDecoder.__len__">
<tt class="descname">__len__</tt><a class="headerlink" href="#colibricore.ClassDecoder.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of classes</p>
</dd></dl>

<dl class="staticmethod">
<dt id="colibricore.ClassDecoder.__new__">
<em class="property">static </em><tt class="descname">__new__</tt><big>(</big><em>S</em>, <em>...</em><big>)</big> &rarr; a new object with type S, a subtype of T<a class="headerlink" href="#colibricore.ClassDecoder.__new__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="colibricore.ClassEncoder">
<em class="property">class </em><tt class="descclassname">colibricore.</tt><tt class="descname">ClassEncoder</tt><a class="headerlink" href="#colibricore.ClassEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>The class encoder allows patterns to be built from their string representation. Load in a class file and invoke the <tt class="docutils literal"><span class="pre">buildpattern()</span></tt> method</p>
<dl class="attribute">
<dt id="colibricore.ClassEncoder.__len__">
<tt class="descname">__len__</tt><a class="headerlink" href="#colibricore.ClassEncoder.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of classes</p>
</dd></dl>

<dl class="staticmethod">
<dt id="colibricore.ClassEncoder.__new__">
<em class="property">static </em><tt class="descname">__new__</tt><big>(</big><em>S</em>, <em>...</em><big>)</big> &rarr; a new object with type S, a subtype of T<a class="headerlink" href="#colibricore.ClassEncoder.__new__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="colibricore.ClassEncoder.buildpattern">
<tt class="descname">buildpattern</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.ClassEncoder.buildpattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a pattern: converts a string representation into a Pattern</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>text</strong> (<em>str</em>) &#8211; The actual text of the pattern</li>
<li><strong>allowunknown</strong> (<em>bool</em>) &#8211; Encode unknown classes as &#8216;unknown&#8217;, a single class for all, rather than failing with an exception if a word type is unseen (bool, default=False)</li>
<li><strong>autoaddunknown</strong> (<em>bool</em>) &#8211; Automatically add unknown classes to the model (bool, default=False)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Pattern</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="colibricore.IndexedData">
<em class="property">class </em><tt class="descclassname">colibricore.</tt><tt class="descname">IndexedData</tt><a class="headerlink" href="#colibricore.IndexedData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>IndexedData is essentially a set of indexes in the form of (sentence,token) tuples, sentence is generally 1-indexed, token is always 0-indexed. It is used by Indexed Pattern Models to keep track of exact occurrences of all the patterns. Use len() to if you&#8217;re merely interested in the number of occurrences, rather than their exact wherabouts.</p>
<dl class="attribute">
<dt id="colibricore.IndexedData.__contains__">
<tt class="descname">__contains__</tt><a class="headerlink" href="#colibricore.IndexedData.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if the specified (sentence,token) tuple is in the set</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.IndexedData.__int__">
<tt class="descname">__int__</tt><a class="headerlink" href="#colibricore.IndexedData.__int__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__int__() &lt;==&gt; int(x)</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.IndexedData.__iter__">
<tt class="descname">__iter__</tt><a class="headerlink" href="#colibricore.IndexedData.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all (sentence,token) tuples in the set</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.IndexedData.__len__">
<tt class="descname">__len__</tt><a class="headerlink" href="#colibricore.IndexedData.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of occurrences, i.e. the length of the set</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.IndexedData.__long__">
<tt class="descname">__long__</tt><a class="headerlink" href="#colibricore.IndexedData.__long__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__long__() &lt;==&gt; long(x)</p>
</dd></dl>

<dl class="staticmethod">
<dt id="colibricore.IndexedData.__new__">
<em class="property">static </em><tt class="descname">__new__</tt><big>(</big><em>S</em>, <em>...</em><big>)</big> &rarr; a new object with type S, a subtype of T<a class="headerlink" href="#colibricore.IndexedData.__new__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.IndexedData.__pyx_vtable__">
<tt class="descname">__pyx_vtable__</tt><em class="property"> = &lt;capsule object NULL at 0x2d00030&gt;</em><a class="headerlink" href="#colibricore.IndexedData.__pyx_vtable__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="colibricore.IndexedPatternModel">
<em class="property">class </em><tt class="descclassname">colibricore.</tt><tt class="descname">IndexedPatternModel</tt><a class="headerlink" href="#colibricore.IndexedPatternModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Indexed Pattern Model</p>
<p>Initialise a pattern model. Either an empty one or loading from file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; The name of the file to load, must be a valid colibri patternmodel file</li>
<li><strong>options</strong> (<em>PatternModelOptions</em>) &#8211; An instance of PatternModelOptions, containing the options used for loading</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="colibricore.IndexedPatternModel.__contains__">
<tt class="descname">__contains__</tt><a class="headerlink" href="#colibricore.IndexedPatternModel.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if a pattern is in the model:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">pattern</span> <span class="ow">in</span> <span class="n">patternmodel</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.IndexedPatternModel.__getitem__">
<tt class="descname">__getitem__</tt><a class="headerlink" href="#colibricore.IndexedPatternModel.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the value for the pattern</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int (for Unindexed Models), IndexData (for Indexed models)</td>
</tr>
</tbody>
</table>
<p>Example (unindexed model):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">occurrences</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="n">pattern</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.IndexedPatternModel.__init__">
<tt class="descname">__init__</tt><a class="headerlink" href="#colibricore.IndexedPatternModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise a pattern model. Either an empty one or loading from file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; The name of the file to load, must be a valid colibri patternmodel file</li>
<li><strong>options</strong> (<em>PatternModelOptions</em>) &#8211; An instance of PatternModelOptions, containing the options used for loading</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.IndexedPatternModel.__iter__">
<tt class="descname">__iter__</tt><a class="headerlink" href="#colibricore.IndexedPatternModel.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all patterns in this model</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.IndexedPatternModel.__len__">
<tt class="descname">__len__</tt><a class="headerlink" href="#colibricore.IndexedPatternModel.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of distinct patterns in the model</p>
</dd></dl>

<dl class="staticmethod">
<dt id="colibricore.IndexedPatternModel.__new__">
<em class="property">static </em><tt class="descname">__new__</tt><big>(</big><em>S</em>, <em>...</em><big>)</big> &rarr; a new object with type S, a subtype of T<a class="headerlink" href="#colibricore.IndexedPatternModel.__new__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.IndexedPatternModel.__pyx_vtable__">
<tt class="descname">__pyx_vtable__</tt><em class="property"> = &lt;capsule object NULL at 0x2d00240&gt;</em><a class="headerlink" href="#colibricore.IndexedPatternModel.__pyx_vtable__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.coverage">
<tt class="descname">coverage</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.coverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of tokens all instances of the specified pattern cover in the training data, as a fraction of the total amount of tokens</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.coveragecount">
<tt class="descname">coveragecount</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.coveragecount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of tokens all instances of the specified pattern cover in the training data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.frequency">
<tt class="descname">frequency</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the frequency of the pattern within its category (ngram/skipgram/flexgram) and exact size class. For a bigram it will thus return the bigram frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.getleftneighbours">
<tt class="descname">getleftneighbours</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.getleftneighbours" title="Permalink to this definition">¶</a></dt>
<dd><p>Get left neighbours for the specified pattern
:param pattern: The pattern
:type pattern: Pattern
:rtype: generator over (Pattern,value) tuples. The values correspond to the number of occurrences for this particularrelationship</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.getrightneighbours">
<tt class="descname">getrightneighbours</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.getrightneighbours" title="Permalink to this definition">¶</a></dt>
<dd><p>Get right neighbours for the specified pattern
:param pattern: The pattern
:type pattern: Pattern
:rtype: generator over (Pattern,value) tuples. The values correspond to the number of occurrences for this particularrelationship</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.getskipcontent">
<tt class="descname">getskipcontent</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.getskipcontent" title="Permalink to this definition">¶</a></dt>
<dd><p>Get skip content for the specified pattern
:param pattern: The pattern
:type pattern: Pattern
:rtype: generator over (Pattern,value) tuples. The values correspond to the number of occurrence for this particularrelationship</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.getsubchildren">
<tt class="descname">getsubchildren</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.getsubchildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Get subsumption children for the specified pattern
:param pattern: The pattern
:type pattern: Pattern
:rtype: generator over (Pattern,value) tuples. The values correspond to the number of occurrences for this particularrelationship</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.getsubparents">
<tt class="descname">getsubparents</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.getsubparents" title="Permalink to this definition">¶</a></dt>
<dd><p>Get subsumption parents for the specified pattern
:param pattern: The pattern
:type pattern: Pattern
:rtype: generator over (Pattern,value) tuples. The values correspond to the number of occurrences for this particularrelationship</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.histogram">
<tt class="descname">histogram</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a histogram to stdout</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.items">
<tt class="descname">items</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.items" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all patterns and their index data (IndexedData instances) in this model</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.load">
<tt class="descname">load</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a patternmodel from file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; The name of the file to load, must be a valid colibri patternmodel file</li>
<li><strong>options</strong> (<em>PatternModelOptions</em>) &#8211; An instance of PatternModelOptions, containing the options used for loading</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.maxlength">
<tt class="descname">maxlength</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.maxlength" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum pattern length in the model</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.minlength">
<tt class="descname">minlength</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.minlength" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the minimum pattern length in the model</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.occurrencecount">
<tt class="descname">occurrencecount</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.occurrencecount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of times the specified pattern occurs in the training data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.outputrelations">
<tt class="descname">outputrelations</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.outputrelations" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute and output (to stdout) all relations for the specified pattern:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pattern</strong> (<em>Pattern</em>) &#8211; The pattern to output relations for</li>
<li><strong>decoder</strong> (<em>ClassDecoder</em>) &#8211; The class decoder</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.printmodel">
<tt class="descname">printmodel</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.printmodel" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the entire pattern model to stdout, a detailed overview</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>decoder</strong> (<em>ClassDecoder</em>) &#8211; The class decoder</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.prune">
<tt class="descname">prune</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Prune all patterns occurring below the threshold.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>threshold</strong> (<em>int</em>) &#8211; the threshold value (minimum number of occurrences)</li>
<li><strong>n</strong> (<em>int</em>) &#8211; prune only patterns of the specified size, use 0 (default) for no size limitation</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.report">
<tt class="descname">report</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.report" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a detailed statistical report to stdout</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.tokens">
<tt class="descname">tokens</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of tokens in the training data</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.totaloccurrencesingroup">
<tt class="descname">totaloccurrencesingroup</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.totaloccurrencesingroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of occurrences in the specified group, within the specified category and/or size class, you can set either to zero (default) to consider all. Example, category=Category.SKIPGRAM and n=0 would consider give the total occurrence count over all skipgrams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>category</strong> (<em>int</em>) &#8211; The category constraint (Category.NGRAM, Category.SKIPGRAM, Category.FLEXGRAM or 0 for no-constraint, default)</li>
<li><strong>n</strong> (<em>int</em>) &#8211; The size constraint (0= no constraint, default)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.totalpatternsingroup">
<tt class="descname">totalpatternsingroup</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.totalpatternsingroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of distinct patterns in the specified group, within the specified category and/or size class, you can set either to zero (default) to consider all. Example, category=Category.SKIPGRAM and n=0 would consider give the total number of distrinct skipgrams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>category</strong> (<em>int</em>) &#8211; The category constraint (Category.NGRAM, Category.SKIPGRAM, Category.FLEXGRAM or 0 for no-constraint, default)</li>
<li><strong>n</strong> (<em>int</em>) &#8211; The size constraint (0= no constraint, default)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.totaltokensingroup">
<tt class="descname">totaltokensingroup</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.totaltokensingroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of covered tokens in the specified group, within the specified category and/or size class, you can set either to zero (default) to consider all. Example, category=Category.SKIPGRAM and n=0 would consider give the total number of covered tokens over all skipgrams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>category</strong> (<em>int</em>) &#8211; The category constraint (Category.NGRAM, Category.SKIPGRAM, Category.FLEXGRAM or 0 for no-constraint, default)</li>
<li><strong>n</strong> (<em>int</em>) &#8211; The size constraint (0= no constraint, default)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.totalwordtypesingroup">
<tt class="descname">totalwordtypesingroup</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.totalwordtypesingroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of covered word types (unigram types) in the specified group, within the specified category and/or size class, you can set either to zero (default) to consider all. Example, category=Category.SKIPGRAM and n=0 would consider give the total number of covered word types over all skipgrams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>category</strong> (<em>int</em>) &#8211; The category constraint (Category.NGRAM, Category.SKIPGRAM, Category.FLEXGRAM or 0 for no-constraint, default)</li>
<li><strong>n</strong> (<em>int</em>) &#8211; The size constraint (0= no constraint, default)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.train">
<tt class="descname">train</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Train the patternmodel on the specified corpus data (a <a href="#id3"><span class="problematic" id="id4">*</span></a>.colibri.dat file)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; The name of the file to load, must be a valid colibri.dat file</li>
<li><strong>options</strong> (<em>PatternModelOptions</em>) &#8211; An instance of PatternModelOptions, containing the options used for loading</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.type">
<tt class="descname">type</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the model type (10 = UNINDEXED, 20 = INDEXED)</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.types">
<tt class="descname">types</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of distinct word types in the training data</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.version">
<tt class="descname">version</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.version" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the version of the model type</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.IndexedPatternModel.write">
<tt class="descname">write</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.IndexedPatternModel.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a patternmodel to file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>str</em>) &#8211; The name of the file to write to</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="colibricore.Pattern">
<em class="property">class </em><tt class="descclassname">colibricore.</tt><tt class="descname">Pattern</tt><a class="headerlink" href="#colibricore.Pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>The Pattern class contains an ngram, skipgram or flexgram, and allows a wide variety of actions to be performed on it. It is stored in a memory-efficient fashion and facilitating fast operation and comparison. Use ClassEncoder.buildpattern to build a pattern.</p>
<dl class="attribute">
<dt id="colibricore.Pattern.__add__">
<tt class="descname">__add__</tt><a class="headerlink" href="#colibricore.Pattern.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate two patterns together, forming a larger one:</p>
<p>pattern3 = pattern1 + pattern2</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.Pattern.__contains__">
<tt class="descname">__contains__</tt><a class="headerlink" href="#colibricore.Pattern.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the specified pattern occurs within this larger pattern.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; the subpattern to look for</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">subpattern</span> <span class="ow">in</span> <span class="n">pattern</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="colibricore.Pattern.__copy__">
<tt class="descname">__copy__</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.Pattern.__copy__" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a copy of the pattern (deep):</p>
<p>pattern2 = copy(pattern)</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.Pattern.__deepcopy__">
<tt class="descname">__deepcopy__</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.Pattern.__deepcopy__" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a copy of the pattern (deep):</p>
<p>pattern2 = copy(pattern)</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.Pattern.__eq__">
<tt class="descname">__eq__</tt><a class="headerlink" href="#colibricore.Pattern.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__eq__(y) &lt;==&gt; x==y</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.Pattern.__ge__">
<tt class="descname">__ge__</tt><a class="headerlink" href="#colibricore.Pattern.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__ge__(y) &lt;==&gt; x&gt;=y</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.Pattern.__getitem__">
<tt class="descname">__getitem__</tt><a class="headerlink" href="#colibricore.Pattern.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves a word/token from the pattern:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">unigram</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<p>Or retrieves a subpattern:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">subpattern</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">[</span><span class="n">begin</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>item</strong> &#8211; an index or slice</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">a Pattern instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.Pattern.__gt__">
<tt class="descname">__gt__</tt><a class="headerlink" href="#colibricore.Pattern.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__gt__(y) &lt;==&gt; x&gt;y</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.Pattern.__hash__">
<tt class="descname">__hash__</tt><a class="headerlink" href="#colibricore.Pattern.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the hashed value for this pattern</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.Pattern.__iter__">
<tt class="descname">__iter__</tt><a class="headerlink" href="#colibricore.Pattern.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over all words/tokens in this pattern</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.Pattern.__le__">
<tt class="descname">__le__</tt><a class="headerlink" href="#colibricore.Pattern.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__le__(y) &lt;==&gt; x&lt;=y</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.Pattern.__len__">
<tt class="descname">__len__</tt><a class="headerlink" href="#colibricore.Pattern.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the length of the pattern in words/tokens:</p>
<p>len(pattern)</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.Pattern.__lt__">
<tt class="descname">__lt__</tt><a class="headerlink" href="#colibricore.Pattern.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__lt__(y) &lt;==&gt; x&lt;y</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.Pattern.__ne__">
<tt class="descname">__ne__</tt><a class="headerlink" href="#colibricore.Pattern.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__ne__(y) &lt;==&gt; x!=y</p>
</dd></dl>

<dl class="staticmethod">
<dt id="colibricore.Pattern.__new__">
<em class="property">static </em><tt class="descname">__new__</tt><big>(</big><em>S</em>, <em>...</em><big>)</big> &rarr; a new object with type S, a subtype of T<a class="headerlink" href="#colibricore.Pattern.__new__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.Pattern.__pyx_vtable__">
<tt class="descname">__pyx_vtable__</tt><em class="property"> = &lt;capsule object NULL at 0x2b80fc0&gt;</em><a class="headerlink" href="#colibricore.Pattern.__pyx_vtable__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.Pattern.__radd__">
<tt class="descname">__radd__</tt><a class="headerlink" href="#colibricore.Pattern.__radd__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__radd__(y) &lt;==&gt; y+x</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.Pattern.bytesize">
<tt class="descname">bytesize</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.Pattern.bytesize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of bytes used to encode this pattern in memory</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.Pattern.category">
<tt class="descname">category</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.Pattern.category" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the category of this pattern
:rtype: Category.NGRAM (1), Category.SKIPGRAM (2), or Category.FLEXGRAM (3)</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.Pattern.concat">
<tt class="descname">concat</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.Pattern.concat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="colibricore.Pattern.gaps">
<tt class="descname">gaps</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.Pattern.gaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator iterating over the gaps in a skipgram or flexgram, return a tuple (begin,length) for each. For flexgrams, the minimum length (1) is always returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">generator over (begin, length) tuples</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.Pattern.ngrams">
<tt class="descname">ngrams</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.Pattern.ngrams" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator iterating over all ngrams of a particular size that are enclosed within this pattern. Despite the name, this may also return skipgrams!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>int</em>) &#8211; The desired size to obtain</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">generator over Pattern instances</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.Pattern.parts">
<tt class="descname">parts</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.Pattern.parts" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating iterating over the consecutive non-gappy parts in a skipgram of flexgram</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">generator over Pattern instances</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.Pattern.skipcount">
<tt class="descname">skipcount</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.Pattern.skipcount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of gaps in this pattern</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.Pattern.subngrams">
<tt class="descname">subngrams</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.Pattern.subngrams" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator iterating over all ngrams of all sizes that are enclosed within this pattern. Despite the name, this may also return skipgrams!
:param minn: minimum length (default 1)
:type minn: int
:param maxn: maximum length (default unlimited)
:type maxn: int
:rtype: generator over Pattern instances</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.Pattern.toflexgram">
<tt class="descname">toflexgram</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.Pattern.toflexgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a skipgram to a flexgram</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Pattern</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.Pattern.tostring">
<tt class="descname">tostring</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.Pattern.tostring" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Pattern back to a str</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>decoder</strong> (<em>ClassDecoder</em>) &#8211; the class decoder to use</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="colibricore.PatternDict_float">
<em class="property">class </em><tt class="descclassname">colibricore.</tt><tt class="descname">PatternDict_float</tt><a class="headerlink" href="#colibricore.PatternDict_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This is a simple low-level dictionary that takes Pattern instances as keys, and float (double) as value. For complete pattern models, use IndexedPatternModel or UnindexPatternModel instead.</p>
<dl class="attribute">
<dt id="colibricore.PatternDict_float.__contains__">
<tt class="descname">__contains__</tt><a class="headerlink" href="#colibricore.PatternDict_float.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the pattern is in the dictionary</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_float.__delitem__">
<tt class="descname">__delitem__</tt><a class="headerlink" href="#colibricore.PatternDict_float.__delitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__delitem__(y) &lt;==&gt; del x[y]</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_float.__getitem__">
<tt class="descname">__getitem__</tt><a class="headerlink" href="#colibricore.PatternDict_float.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the value for a pattern in the dictionary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_float.__iter__">
<tt class="descname">__iter__</tt><a class="headerlink" href="#colibricore.PatternDict_float.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all patterns in the dictionary</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_float.__len__">
<tt class="descname">__len__</tt><a class="headerlink" href="#colibricore.PatternDict_float.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of patterns in the dictionary</p>
</dd></dl>

<dl class="staticmethod">
<dt id="colibricore.PatternDict_float.__new__">
<em class="property">static </em><tt class="descname">__new__</tt><big>(</big><em>S</em>, <em>...</em><big>)</big> &rarr; a new object with type S, a subtype of T<a class="headerlink" href="#colibricore.PatternDict_float.__new__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_float.__pyx_vtable__">
<tt class="descname">__pyx_vtable__</tt><em class="property"> = &lt;capsule object NULL at 0x2d00150&gt;</em><a class="headerlink" href="#colibricore.PatternDict_float.__pyx_vtable__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_float.__setitem__">
<tt class="descname">__setitem__</tt><a class="headerlink" href="#colibricore.PatternDict_float.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value for a pattern in the dictionary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pattern</strong> &#8211; the pattern</li>
<li><strong>value</strong> &#8211; its value</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.PatternDict_float.has">
<tt class="descname">has</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.PatternDict_float.has" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="colibricore.PatternDict_float.items">
<tt class="descname">items</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.PatternDict_float.items" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all patterns and their values in the dictionary</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="colibricore.PatternDict_int">
<em class="property">class </em><tt class="descclassname">colibricore.</tt><tt class="descname">PatternDict_int</tt><a class="headerlink" href="#colibricore.PatternDict_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This is a simple low-level dictionary that takes Pattern instances as keys, and integer (unsigned 64 bit) as value. For complete pattern models, use IndexedPatternModel or UnindexPatternModel instead.</p>
<dl class="attribute">
<dt id="colibricore.PatternDict_int.__contains__">
<tt class="descname">__contains__</tt><a class="headerlink" href="#colibricore.PatternDict_int.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the pattern is in the dictionary</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_int.__delitem__">
<tt class="descname">__delitem__</tt><a class="headerlink" href="#colibricore.PatternDict_int.__delitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__delitem__(y) &lt;==&gt; del x[y]</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_int.__getitem__">
<tt class="descname">__getitem__</tt><a class="headerlink" href="#colibricore.PatternDict_int.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the value for a pattern in the dictionary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_int.__iter__">
<tt class="descname">__iter__</tt><a class="headerlink" href="#colibricore.PatternDict_int.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all patterns in the dictionary</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_int.__len__">
<tt class="descname">__len__</tt><a class="headerlink" href="#colibricore.PatternDict_int.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of patterns in the dictionary</p>
</dd></dl>

<dl class="staticmethod">
<dt id="colibricore.PatternDict_int.__new__">
<em class="property">static </em><tt class="descname">__new__</tt><big>(</big><em>S</em>, <em>...</em><big>)</big> &rarr; a new object with type S, a subtype of T<a class="headerlink" href="#colibricore.PatternDict_int.__new__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_int.__pyx_vtable__">
<tt class="descname">__pyx_vtable__</tt><em class="property"> = &lt;capsule object NULL at 0x2d00120&gt;</em><a class="headerlink" href="#colibricore.PatternDict_int.__pyx_vtable__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_int.__setitem__">
<tt class="descname">__setitem__</tt><a class="headerlink" href="#colibricore.PatternDict_int.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value for a pattern in the dictionary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pattern</strong> &#8211; the pattern</li>
<li><strong>value</strong> &#8211; its value</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.PatternDict_int.has">
<tt class="descname">has</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.PatternDict_int.has" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="colibricore.PatternDict_int.items">
<tt class="descname">items</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.PatternDict_int.items" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all patterns and their values in the dictionary</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="colibricore.PatternDict_int32">
<em class="property">class </em><tt class="descclassname">colibricore.</tt><tt class="descname">PatternDict_int32</tt><a class="headerlink" href="#colibricore.PatternDict_int32" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This is a simple low-level dictionary that takes Pattern instances as keys, and integer (max 32 bit, unsigned) as value. For complete pattern models, use IndexedPatternModel or UnindexPatternModel instead.</p>
<dl class="attribute">
<dt id="colibricore.PatternDict_int32.__contains__">
<tt class="descname">__contains__</tt><a class="headerlink" href="#colibricore.PatternDict_int32.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the pattern is in the dictionary</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_int32.__delitem__">
<tt class="descname">__delitem__</tt><a class="headerlink" href="#colibricore.PatternDict_int32.__delitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__delitem__(y) &lt;==&gt; del x[y]</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_int32.__getitem__">
<tt class="descname">__getitem__</tt><a class="headerlink" href="#colibricore.PatternDict_int32.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the value for a pattern in the dictionary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_int32.__iter__">
<tt class="descname">__iter__</tt><a class="headerlink" href="#colibricore.PatternDict_int32.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all patterns in the dictionary</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_int32.__len__">
<tt class="descname">__len__</tt><a class="headerlink" href="#colibricore.PatternDict_int32.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of patterns in the dictionary</p>
</dd></dl>

<dl class="staticmethod">
<dt id="colibricore.PatternDict_int32.__new__">
<em class="property">static </em><tt class="descname">__new__</tt><big>(</big><em>S</em>, <em>...</em><big>)</big> &rarr; a new object with type S, a subtype of T<a class="headerlink" href="#colibricore.PatternDict_int32.__new__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_int32.__pyx_vtable__">
<tt class="descname">__pyx_vtable__</tt><em class="property"> = &lt;capsule object NULL at 0x2d000f0&gt;</em><a class="headerlink" href="#colibricore.PatternDict_int32.__pyx_vtable__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternDict_int32.__setitem__">
<tt class="descname">__setitem__</tt><a class="headerlink" href="#colibricore.PatternDict_int32.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value for a pattern in the dictionary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pattern</strong> &#8211; the pattern</li>
<li><strong>value</strong> &#8211; its value</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.PatternDict_int32.has">
<tt class="descname">has</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.PatternDict_int32.has" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="colibricore.PatternDict_int32.items">
<tt class="descname">items</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.PatternDict_int32.items" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all patterns and their values in the dictionary</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="colibricore.PatternModelOptions">
<em class="property">class </em><tt class="descclassname">colibricore.</tt><tt class="descname">PatternModelOptions</tt><a class="headerlink" href="#colibricore.PatternModelOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Options for Pattern model, you can get and set the following attributes:</p>
<ul class="simple">
<li>MINTOKENS - The token threshold, patterns with an occurrence below this will be pruned</li>
<li>MAXLENGTH - Maximum pattern length</li>
<li>DOSKIPGRAMS - Compute skipgrams?</li>
<li>DOSKIPGRAMS_EXHAUSTIVE - Compute skipgrams exhaustively?</li>
<li>MINSKIPTYPES - Minimum amount of different skip content types</li>
<li>DOREVERSEINDEX - Build reverse index? (default: True)</li>
<li>DEBUG</li>
<li>QUIET (default: False)</li>
</ul>
<p>These can also be passed at keyword arguments to the constructor, in a case insensitive fashion:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">options</span> <span class="o">=</span> <span class="n">PatternModelOptions</span><span class="p">(</span><span class="n">mintokens</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="colibricore.PatternModelOptions.__delattr__">
<tt class="descname">__delattr__</tt><a class="headerlink" href="#colibricore.PatternModelOptions.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__delattr__(&#8216;name&#8217;) &lt;==&gt; del x.name</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.PatternModelOptions.__getattr__">
<tt class="descname">__getattr__</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.PatternModelOptions.__getattr__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternModelOptions.__getattribute__">
<tt class="descname">__getattribute__</tt><a class="headerlink" href="#colibricore.PatternModelOptions.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__getattribute__(&#8216;name&#8217;) &lt;==&gt; x.name</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternModelOptions.__init__">
<tt class="descname">__init__</tt><a class="headerlink" href="#colibricore.PatternModelOptions.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="staticmethod">
<dt id="colibricore.PatternModelOptions.__new__">
<em class="property">static </em><tt class="descname">__new__</tt><big>(</big><em>S</em>, <em>...</em><big>)</big> &rarr; a new object with type S, a subtype of T<a class="headerlink" href="#colibricore.PatternModelOptions.__new__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternModelOptions.__setattr__">
<tt class="descname">__setattr__</tt><a class="headerlink" href="#colibricore.PatternModelOptions.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__setattr__(&#8216;name&#8217;, value) &lt;==&gt; x.name = value</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="colibricore.PatternSet">
<em class="property">class </em><tt class="descclassname">colibricore.</tt><tt class="descname">PatternSet</tt><a class="headerlink" href="#colibricore.PatternSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This is a simple low-level set that contains Pattern instances</p>
<dl class="attribute">
<dt id="colibricore.PatternSet.__contains__">
<tt class="descname">__contains__</tt><a class="headerlink" href="#colibricore.PatternSet.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the pattern is in the dictionary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternSet.__iter__">
<tt class="descname">__iter__</tt><a class="headerlink" href="#colibricore.PatternSet.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all patterns in the dictionary</p>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternSet.__len__">
<tt class="descname">__len__</tt><a class="headerlink" href="#colibricore.PatternSet.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of patterns in the dictionary</p>
</dd></dl>

<dl class="staticmethod">
<dt id="colibricore.PatternSet.__new__">
<em class="property">static </em><tt class="descname">__new__</tt><big>(</big><em>S</em>, <em>...</em><big>)</big> &rarr; a new object with type S, a subtype of T<a class="headerlink" href="#colibricore.PatternSet.__new__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.PatternSet.__pyx_vtable__">
<tt class="descname">__pyx_vtable__</tt><em class="property"> = &lt;capsule object NULL at 0x2d00090&gt;</em><a class="headerlink" href="#colibricore.PatternSet.__pyx_vtable__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="colibricore.PatternSet.add">
<tt class="descname">add</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.PatternSet.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a pattern to the set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; The pattern to add</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.PatternSet.has">
<tt class="descname">has</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.PatternSet.has" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="colibricore.UnindexedPatternModel">
<em class="property">class </em><tt class="descclassname">colibricore.</tt><tt class="descname">UnindexedPatternModel</tt><a class="headerlink" href="#colibricore.UnindexedPatternModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Unindexed Pattern Model, less flexible and powerful than its indexed counterpart, but smaller memory footprint</p>
<p>Initialise a pattern model. Either an empty one or loading from file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; The name of the file to load, must be a valid colibri patternmodel file</li>
<li><strong>options</strong> (<em>PatternModelOptions</em>) &#8211; An instance of PatternModelOptions, containing the options used for loading</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="colibricore.UnindexedPatternModel.__contains__">
<tt class="descname">__contains__</tt><a class="headerlink" href="#colibricore.UnindexedPatternModel.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if a pattern is in the model:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">pattern</span> <span class="ow">in</span> <span class="n">patternmodel</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.UnindexedPatternModel.__getitem__">
<tt class="descname">__getitem__</tt><a class="headerlink" href="#colibricore.UnindexedPatternModel.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the value for the pattern</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int (for Unindexed Models), IndexData (for Indexed models)</td>
</tr>
</tbody>
</table>
<p>Example (unindexed model):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">occurrences</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="n">pattern</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.UnindexedPatternModel.__init__">
<tt class="descname">__init__</tt><a class="headerlink" href="#colibricore.UnindexedPatternModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise a pattern model. Either an empty one or loading from file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; The name of the file to load, must be a valid colibri patternmodel file</li>
<li><strong>options</strong> (<em>PatternModelOptions</em>) &#8211; An instance of PatternModelOptions, containing the options used for loading</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.UnindexedPatternModel.__iter__">
<tt class="descname">__iter__</tt><a class="headerlink" href="#colibricore.UnindexedPatternModel.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over all patterns in the model.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">model</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">pattern</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">classdecoder</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="colibricore.UnindexedPatternModel.__len__">
<tt class="descname">__len__</tt><a class="headerlink" href="#colibricore.UnindexedPatternModel.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of distinct patterns in the model</p>
</dd></dl>

<dl class="staticmethod">
<dt id="colibricore.UnindexedPatternModel.__new__">
<em class="property">static </em><tt class="descname">__new__</tt><big>(</big><em>S</em>, <em>...</em><big>)</big> &rarr; a new object with type S, a subtype of T<a class="headerlink" href="#colibricore.UnindexedPatternModel.__new__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="colibricore.UnindexedPatternModel.__pyx_vtable__">
<tt class="descname">__pyx_vtable__</tt><em class="property"> = &lt;capsule object NULL at 0x2d00270&gt;</em><a class="headerlink" href="#colibricore.UnindexedPatternModel.__pyx_vtable__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.coverage">
<tt class="descname">coverage</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.coverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of tokens all instances of the specified pattern cover in the training data, as a fraction of the total amount of tokens</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.coveragecount">
<tt class="descname">coveragecount</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.coveragecount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of tokens all instances of the specified pattern cover in the training data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.frequency">
<tt class="descname">frequency</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the frequency of the pattern within its category (ngram/skipgram/flexgram) and exact size class. For a bigram it will thus return the bigram frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.getdata">
<tt class="descname">getdata</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.getdata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.histogram">
<tt class="descname">histogram</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a histogram to stdout</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.items">
<tt class="descname">items</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.items" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all patterns and their occurrence count in this model</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.load">
<tt class="descname">load</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a patternmodel from file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; The name of the file to load, must be a valid colibri patternmodel file</li>
<li><strong>options</strong> (<em>PatternModelOptions</em>) &#8211; An instance of PatternModelOptions, containing the options used for loading</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.maxlength">
<tt class="descname">maxlength</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.maxlength" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum pattern length in the model</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.minlength">
<tt class="descname">minlength</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.minlength" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the minimum pattern length in the model</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.occurrencecount">
<tt class="descname">occurrencecount</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.occurrencecount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of times the specified pattern occurs in the training data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> (<em>Pattern</em>) &#8211; A pattern</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.printmodel">
<tt class="descname">printmodel</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.printmodel" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the entire pattern model to stdout, a detailed overview</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>decoder</strong> (<em>ClassDecoder</em>) &#8211; The class decoder</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.prune">
<tt class="descname">prune</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Prune all patterns occurring below the threshold.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>threshold</strong> (<em>int</em>) &#8211; the threshold value (minimum number of occurrences)</li>
<li><strong>n</strong> (<em>int</em>) &#8211; prune only patterns of the specified size, use 0 (default) for no size limitation</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.report">
<tt class="descname">report</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.report" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a detailed statistical report to stdout</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.tokens">
<tt class="descname">tokens</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of tokens in the training data</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.totaloccurrencesingroup">
<tt class="descname">totaloccurrencesingroup</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.totaloccurrencesingroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of occurrences in the specified group, within the specified category and/or size class, you can set either to zero (default) to consider all. Example, category=Category.SKIPGRAM and n=0 would consider give the total occurrence count over all skipgrams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>category</strong> (<em>int</em>) &#8211; The category constraint (Category.NGRAM, Category.SKIPGRAM, Category.FLEXGRAM or 0 for no-constraint, default)</li>
<li><strong>n</strong> (<em>int</em>) &#8211; The size constraint (0= no constraint, default)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.totalpatternsingroup">
<tt class="descname">totalpatternsingroup</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.totalpatternsingroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of distinct patterns in the specified group, within the specified category and/or size class, you can set either to zero (default) to consider all. Example, category=Category.SKIPGRAM and n=0 would consider give the total number of distrinct skipgrams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>category</strong> (<em>int</em>) &#8211; The category constraint (Category.NGRAM, Category.SKIPGRAM, Category.FLEXGRAM or 0 for no-constraint, default)</li>
<li><strong>n</strong> (<em>int</em>) &#8211; The size constraint (0= no constraint, default)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.totaltokensingroup">
<tt class="descname">totaltokensingroup</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.totaltokensingroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of covered tokens in the specified group, within the specified category and/or size class, you can set either to zero (default) to consider all. Example, category=Category.SKIPGRAM and n=0 would consider give the total number of covered tokens over all skipgrams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>category</strong> (<em>int</em>) &#8211; The category constraint (Category.NGRAM, Category.SKIPGRAM, Category.FLEXGRAM or 0 for no-constraint, default)</li>
<li><strong>n</strong> (<em>int</em>) &#8211; The size constraint (0= no constraint, default)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.totalwordtypesingroup">
<tt class="descname">totalwordtypesingroup</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.totalwordtypesingroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of covered word types (unigram types) in the specified group, within the specified category and/or size class, you can set either to zero (default) to consider all. Example, category=Category.SKIPGRAM and n=0 would consider give the total number of covered word types over all skipgrams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>category</strong> (<em>int</em>) &#8211; The category constraint (Category.NGRAM, Category.SKIPGRAM, Category.FLEXGRAM or 0 for no-constraint, default)</li>
<li><strong>n</strong> (<em>int</em>) &#8211; The size constraint (0= no constraint, default)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.train">
<tt class="descname">train</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Train the patternmodel on the specified corpus data (a <a href="#id5"><span class="problematic" id="id6">*</span></a>.colibri.dat file)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; The name of the file to load, must be a valid colibri.dat file</li>
<li><strong>options</strong> (<em>PatternModelOptions</em>) &#8211; An instance of PatternModelOptions, containing the options used for loading</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.type">
<tt class="descname">type</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the model type (10 = UNINDEXED, 20 = INDEXED)</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.types">
<tt class="descname">types</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of distinct word types in the training data</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.version">
<tt class="descname">version</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.version" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the version of the model type</p>
</dd></dl>

<dl class="method">
<dt id="colibricore.UnindexedPatternModel.write">
<tt class="descname">write</tt><big>(</big><big>)</big><a class="headerlink" href="#colibricore.UnindexedPatternModel.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a patternmodel to file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>str</em>) &#8211; The name of the file to write to</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Colibri Documentation</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#installation">Installation</a><ul>
<li><a class="reference internal" href="#keeping-colibri-up-to-date">Keeping colibri up to date</a></li>
<li><a class="reference internal" href="#general-usage-instructions">General usage instructions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#corpus-class-encoding">Corpus Class Encoding</a><ul>
<li><a class="reference internal" href="#id1">Introduction</a></li>
<li><a class="reference internal" href="#class-encoding-your-corpus">Class-encoding your corpus</a></li>
<li><a class="reference internal" href="#class-decoding-your-corpus">Class-decoding your corpus</a></li>
<li><a class="reference internal" href="#class-encoding-with-existing-classes">Class-encoding with existing classes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pattern-modeller">Pattern Modeller</a><ul>
<li><a class="reference internal" href="#id2">Introduction</a></li>
<li><a class="reference internal" href="#creating-a-pattern-model">Creating a pattern model</a></li>
<li><a class="reference internal" href="#statistical-reports-and-histograms">Statistical reports and histograms</a></li>
<li><a class="reference internal" href="#filtering-models">Filtering models</a></li>
<li><a class="reference internal" href="#training-and-testing-coverage">Training and testing coverage</a></li>
<li><a class="reference internal" href="#query-mode">Query mode</a></li>
<li><a class="reference internal" href="#pattern-relations">Pattern Relations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#python-api-reference">Python API Reference</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">Colibri Core 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Maarten van Gompel.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>